---
title: 对象的创建与销毁注意事项（二）
date: 2017-12-27 23:32:33
tags: [java]
categories: Java
---


------
上一篇主要讲了一些创建对象的方法，那么这一节，主要讲的就是在创建对象的时候需要注意的事情，以及如何销毁对象。

------

## 1 避免创建不必要的对象
但我们已经创建了一个对象，又想创建该对象的时候，我们就要问，这两个对象的功能是一样的吗，如果一样，我们为什么要去重新创建它呢？

> Effective Java：最好能重用对象而不是在每次需要的时候就创建一个相同功能的对象。

#### 例子
判断该时间是否在某个时间段之间
```java
class CompareTool{
    private Date time;
    ...

    public boolean isBetween(){
        Calendar cal = Calendar.getInstance();
        
        cal.set(1999, Calendar.JANUARY, 1, 0, 0, 0);
        Date start = cal.getTime();
        cal.set(2017, Calendar.JANUARY, 1, 0, 0, 0);
        Date end = cal.getTime();
        
        return time.compareTo(start) >= 0 && 
                time.compareTo(end) < 0;
    }
}
```
在这个例子中，当我们每次调用isBetween()方法的时候，都会去创建两个新的Date对象和一个新的Calendar对象。如果我们调用成千上万次，那么这些对象就要被创建成千上万次，这是相当没效率的做法。
根据“相同功能重用”的原则，我们应该将这个方法里不变的对象抽取出来。
```java
class CompareTool{
    private Date time;
    private final Date start;
    private final Date end;
    ...
    
    static{
        Calendar cal = Calendar.getInstance();
        cal.set(1999, Calendar.JANUARY, 1, 0, 0, 0);
        start = cal.getTime();
        cal.set(2017, Calendar.JANUARY, 1, 0, 0, 0);
        end = cal.getTime();
    }
    
    public boolean isBetween(){
        return time.compareTo(start) >= 0 && 
                time.compareTo(end) < 0;
    }
}
```
这里将不变的两个Date对象start和end声明为final，并在static块中初始化，这样，不管我们调用多少次isBetween()方法，这些Date对象都只会执行一次。
那么你可能会有疑问，如果我们调用这个类的其他方法呢，这两个Date对象一样会去实例化，这是不是就降低效率了？
没错的，只要调用了这个类，就会去实例化这两个Date对象，但是，我们只能去取舍，在多次被调用或可能会被多次调用的情况下，我们都要去优化对象的创建。



------

## 2 消除过期的对象引用
Java提供了垃圾回收机制，但这并不意味这我们就不需自己来管理内存和对象。

#### 问题Demo
```java
class MyStack<T>{
    ...
    public T pop(){
        if(size == 0){
            throw new EmptyStackException();
        }
        
        return (T)(elements[--size]);
    }
    ...
}
```
以上是一个自定义栈的出栈方法pop()，我们会将所有的元素存放在elements中，而size代表的是栈中元素的数量。
在这里我们应该可以看出上面这段代码的问题，我们的所有元素是放在elements数组中的，而栈中的元素其实只是elements的一个子集。
因为当我们执行pop操作的时候，我们只是将size自减，返回elements中的某一个元素，只要我们管理的size不会出错，这个程序就不会出错。但，其实，当我们执行pop的时候，elements中的元素并没有变化，也就是说，当我们pop的时候，从elements中取出来的元素并没有被垃圾回收，而我们也不会再使用这些对象。
这就是我们经常听到的，“过期引用”。
这种内存泄漏是很隐蔽的，很难被发现，所以当我们在编写这类由类自己管理多对象存储的时候，需要相当小心。
而当我们发现这类的问题的时候，解决并不难。
```java
public T pop(){
    if(size == 0){
            throw new EmptyStackException();
        }
        
        T t = (T)(elements[--size]);
        elements[size] = null;
        return t;
}
```



------

## ３ 终结方法 -- 避免使用
在Java中，当一个对象变为不可达的时候，垃圾回收器会回收这个对象相关的存储空间。
但Java还是提供了终结方法，然而却没有保证该方法能被及时地执行，甚至是不保证能够被执行。
所以我们在对资源或是锁机制等的处理，都不应该去依赖终结方法来更新重要的持久性状态。

那么我们该怎么来释放我们的资源或终止某些操作呢？
```java
try{
    //do something ...
} finally{
    //释放资源或释放锁等操作
}
```