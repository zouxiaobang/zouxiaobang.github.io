---
title: Linux（1）-- 磁盘分区
date: 2018-01-03 18:23:25
tags: [Linux, 磁盘]
categories: [Linux]
---

------

**在linux系统，所有的设备都是文件。**

------

## 磁盘的种类

现在磁盘接口的种类主要有IDE接口和SATA接口，其中SATA接口比较主流，而IDE接口依然还会存在于较多的老主机上。

### 1 IDE接口
通常主机上有两个IDE接口，而每个IDE接口都可以连接两个IDE设备，所以一台主机总共可以连接4个IDE设备。

| 接口 | 主设备Master | 从设备Slave |
| --------   | -----:  | :----:  |
|IDE1|/dev/hda|/dev/hdb|
|IDE2|/dev/hdc|/dev/hdd|


### 2 SATA接口

SATA接口对设备的文件名和IDE接口的命名方式不同，并不是顺序命名，而是根据Linux内核检测的磁盘的顺序。
也就是说，如果我们将两个SATA设备插入SATA1和SATA5接口，一个USB插入SATA2接口，那么：

 - SATA1上设备的名称：/dev/sda
 - SATA5上设备的名称：/dev/sdb
 - SATA2上设备的名称：/dev/sdc

### 3 磁盘分区表
**磁盘的第一个扇面主要记录了两个重要的信息：主引导分区(MBR)和分区表。**
主引导分区：安装引导加载程序的地方
分区表：记录整个磁盘分区的信息

这里我们先讲磁盘分区表。
磁盘分区表由64bytes来表示，也就是8个字，可以分为4组，用来记录4个区段的开始和结束的柱面号码。
![磁盘分区表的作用示意图](/img/linux_1/p1.png)
例如我们把该磁盘的大小假设为只有400个柱面，如上图所示。
黑色块表示磁盘分区表，只有64bytes，里面记录着后面4个分区的柱面号码。
这4个分区名字如下：
/dev/hda1
/dev/hda2
/dev/hda3
/dev/hda4

**重点：**

 - 分区就是根据磁盘分区表中的记录来设置的
 - 磁盘默认只能写入4个分区的信息
 - 这4个分区信息称为主分区(Primary)和扩展分区(Extended)
 - 分区的最小单位为柱面

### 4 扩展分区与逻辑分区
由上面的知识我们知道，第一个扇区的磁盘分区表只能记录4个分区信息，所以我们只能分出4个分区出来。
但有时我们希望能分出更多的分区，该怎么办？
这时就要用到扩展分区，使用额外的扇区来记录分区信息，从而将扩展分区切出多个逻辑分区。
![扩展分区和逻辑分区示意图](/img/linux_1/p2.png)
如上图所示，第一个扇区的分区记录表只分出两个分区：主分区和扩展分区。
而扩展分区的额外扇区里又拥有一个分区记录表，这个记录表不只64bytes那么大了，其中记录了5个分区的信息，这些分区称为逻辑分区，是由扩展分区切出来的。
所以上图的各个分区的设备名称如下：

 - /dev/hda1
 - /dev/hda2
 - /dev/hda5
 - /dev/hda6
 - /dev/hda7
 - /dev/hda8
 - /dev/hda9

可以看出，其中没有hda3、hda4，那是因为hda3、hda4默认留给Primary或Extended分区使用，如果没有分出那么多的Primary或Extended分区，这留空等待有的时候可以使用。也就是说，逻辑分区的名称都是从5开始的。(以上内容适用于SATA类型磁盘)

**重点：**

 - 主分区和扩展分区总共只能有4个
 - 扩展分区只能有一个，主分区可以有多个(最多3个)
 - 逻辑分区是由扩展分区切割出来的
 - 主分区和逻辑分区都可以格式化，而扩展分区不能格式化
 - IDE磁盘最多可以切出59个逻辑分区(5 - 63)，而SATA磁盘最大只能切出11个逻辑分区(5 - 15)

### 5 磁盘分区模式
磁盘分区最常见的有两种模式：

 - P-P-P-E
 - P-E
 
这两种模式的环境如图：
![PPPE](/img/linux_1/PPPE.gif)
![PE](/img/linux_1/PE.gif)

### 6 主引导分区(开机流程)
先说两个知识点：
BIOS：是一个写入到主板上的一个韧体，也就是写入到硬件上的一个软件程序，在开机的时候计算机系统会主动执行它。
COMS：记录各项硬件参数且嵌入到主板上面的存储器。

开机流程：

 1. BIOS：开机主动执行的韧体，会去认识第一个可开机的设备(MBR)
 2. MBR：第一个可开机设备的第一个扇区内记录的主引导分区，里面包含引导加载程序
 3. 引导加载程序(Boot loader)：一个可读取内核文件来执行的软件
 4. 内核文件：开始操作系统的功能

MBR只有446bytes这么大，所以其中的引导加载程序非常小，也近乎完美。
Boot loader的主要任务如下：

 - 提供菜单：用户可以选择不同的开机选项
 - 载入内核文件：直接指向可开机的程序区段
 - 转交给其他Boot loader：交给其他分区的引导加载程序去执行
 
 了解上面的3个任务后再来理解。
![引导程序的工作示意图](/img/linux_1/p3.gif)
举个例子，如上面的图所示，MBR的引导加载程序启动后，会提供两个菜单项给我们选择，分别为M1,M2，其中M1指向Windows系统，而M2指向Linux系统。
如果我们选择M1，则直接加载Windows的内核文件，就可以进行开机。而如果选择的是M2，引导加载程序会转交给第二个分区的引导加载程序(第二个分区是Linux系统)，第二个引导加载程序启动后，里面只有一个开机菜单项，就是Linux系统，因此使用Linux的内核文件来开机。

### 7 挂载
Linux的所有数据都是以文件的形式存在，所以Liux系统以目录树结构的形式来规范这些文件。
**根目录("/")**：所有的文件都和根目录相关。
例如：
/dev
/etc
/home/dmtsai

我们都知道，数据实际是放置到磁盘中的，但我们需要以更可观的形式来看到这些数据，也就需要处理一个问题：目录树的架构与磁盘内的数据如何关联起来。
这就引入了一个概念 -- **挂载**

**挂载就是利用一个目录为进入点，将磁盘分区放置到该目录下面。
此时进入该目录，就是在读取该磁盘中的数据。**
整个放置过程我们称为挂载，而这个目录，我们称为挂载点。
![目录树与磁盘分区之间的关系](/img/linux_1/p4.png)
如上图所示，分区1挂载到根目录“/”下面，而分区2挂载到"/home"目录下，那么如果我们要把数据存放到/home目录下时，如上图，创建一个test文件，则该数据会写入到分区2中去。