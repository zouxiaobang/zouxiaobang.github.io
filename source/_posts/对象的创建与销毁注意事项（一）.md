---
title: 对象的创建与销毁注意事项（一）
date: 2017-12-27 23:30:44
tags: [java]
categories: Java
---


------
## 1 使用静态方法来创建对象
类可以提供一个公有的静态方法来返回一个类的实例。
这个静态方法绕过了构造方法来创建对象。
在Effective Java中强烈推荐的一种创建对象的方式。

#### 常用静态方法命名：

> * valueOf(): 该方法返回的实例的值与它传入参数的值是相同的。
	例如String.valueOf(1):将int类型的值“1”转换为string类型“1”
> * getInstance(): 是通过其传入的参数来确定其实例。
	主要应用在单例设计模式中。通过getInstance(var )来调用该类的构造方法（有参或无参）
> * newInstance(): 类似于getInstance()方法，但它每次调用时创建的对象都不同，这就是与getInstance()的区别。
> * getType(): 如果该静态方法和要创建的对象的类并不是同一个类，那么就使用它来替代getInstance()
	例如在Demo类中声明了getType()方法，要在getType()创建一个User对象，那么就可以使用getType()
	这里需要注意的是，getType()同样是应用于单例设计模式中。
> * newType(): 类似于getType()，其作用相当于newInstance()之于getInstance()。

#### 实例

### 1.1 getInstance()
该方法主要在单例设计模式中呈现：
```java
class ExampleClass{
    private int num;
    private static ExampleClass sInstance;
    
    private ExampleClass(){
        this(0);
    }
    
    private ExampleClass(int number){
        this.num = number;
    }
    
    public static ExampleClass getInstance(){
        if(sInstance == null){
            synchronized(this){
                if(sInstance == null){
                    sInstance = new ExampleClass();
                }
            }
        }
        
        return sInstance;
    }
    
    ublic static ExampleClass getInstance(final int number){
        if(sInstance == null){
            synchronized(this){
                if(sInstance == null){
                    sInstance = new ExampleClass(number);
                }
            }
        }
        
        return sInstance;
    }
}
```

### 1.2 newInstance()
这个方法与getInstance()作用差不多，只不过它所创建的对象并不是唯一的。
```java
class ExampleClass{
    private int num;
    private static ExampleClass sInstance;
    
    private ExampleClass(){
        this(0);
    }
    
    private ExampleClass(int number){
        this.num = number;
    }
    
    public static ExampleClass newInstance(){
        return new ExampleClass();
    }
    
    ublic static ExampleClass newInstance(final int number){
        return new ExampleClass(number);
    }
}
```

### 1.3 getType()
这个方法与getInstance()作用差不多，但是它和要创建对象所属的类并不在同一个类中。
```java
class ExampleClass{
    private int num;
    private static ExampleClass sInstance;
    
    public ExampleClass(){
        this(0);
    }
    
    public ExampleClass(int number){
        this.num = number;
    }
}

class Demo{
    private static ExampleClass sExInstance;

    public static final ExampleClass getExampleClass(){
        if(sExInstance == null){
            synchronized(this){
                if(sExInstance == null){
                    sExInstance = new ExampleClass();
                }
            }
        }
        return sExInstance;
    }
    
    public static final ExampleClass getExampleClass(fianl
                    int number){
        if(sExInstance == null){
            synchronized(this){
                if(sExInstance == null){
                    sExInstance = new ExampleClass(number);
                }
            }
        }
        return sExInstance;
    }
}
```

### 1.4 newType()
这newType()方法就是在getType()方法的基础上，让其返回的是一个不唯一的对象即可。代码省略。


> 这里在参数和方法方面都尽量使用了 **fianl**来修饰，是因为final可以保证该方法或参数不会被随意地更改或重写，同时在编译的时候虚拟机会对final类型的参数和方法进行性能的优化。
所以强烈建议，应尽可能地使用final来修饰。

------

## 2 构造器有多个参数 -- 使用建造者模式
面对无参或只有少数参数的构造器的时候，我们建议使用静态方法来创建对象。那如果该构造器有多个参数呢，使用原生的构造方法或静态方法来创建对象都是灾难性的。你应该试过每次构建对象的时候都要一个参数一个参数地对比着填入，这样都还经常填错顺序。
这种时候，建造者模式的使用，就再合适不过了。

#### 疑问
> * 为什么不能使用多参数构造方法？
> * 为什么不使用setter()的形式来导入参数？

#### 解答
> * 多参构造器是可以使用的，在Android源码中随处可见。
但是并不推荐，首先是其可读性较低，读者很难知道该参数代表的是什么类型，其意义是什么。并且在调用者眼里，这就是灾难性的，每次调用要去阅读大量的文档来认识每一个参数的意义和用法。最后在API提供者眼里，也是特别麻烦的，如果要求传入参数的个数不同而创建不同的对象，那么就需要重写多个构造器。所以说，尽管这种方法可用，但我们并不推荐。
> * 先创建一个无参构造方法，然后使用setter形式来传入参数。这种JavaBean的形式在某些功能上相当受欢迎，例如在修改个人信息的功能上，我们可以通过setter方法来修改某一个信息。当这个便利性也为它创造了一个局限性--可修改。
对于构造一个对象，我们应该希望能在一个调用过程中完成，而不是分成多个调用过程。例如使用setter来传递参数，那么构建一个完整的对象，就需要多次调用setter方法，在这个过程中，对象是处于一个不一致的状态。如果我们在创建过程中去调用它，那么将会失败，而且这种失败并不想包含错误代码的错误那么简单可以调式的。所以在构建对象上面，我们也不推荐setter形式。

#### 解决方法
> 当然，解决方案肯定是有的，那就是使用建造者模式 -- Builder
这个模式刚好完美地结合了构造方法的安全性，和setter方法的可读性。

### 2.1 Builder解读
Builder并不会直接去生成一个的对象，而是让调用者先传入所有必要的参数(吸取setter方法的优点)，每次传入参数都会返回一个Builder对象，所以可以使用链式方式来传参(传统的Builder模式和Android源码中使用的Builder在创建形式上有所不同，在这里使用的是更为可读的Android中的Builder模式)。
等待所有的参数都传入完毕后，再根据这个Builder对象来生成我们想要的对象。

### 2.2 Demo

```java
public class User{
    private final String name;
    private final String password;
    private final int sex;
    private final int age;
    
    private String phone;
    
    private User(Builder builder){
        this.name = builder.name;
        this.password = builder.password;
        this.sex = builder.sex;
        this.age = builder.age;
    }
    
    public static class Builder{
        this.name = name;
        this.password = password;
        this.sex = sex;
        this.age = age;
        
        public Builder name(String name){
            this.name = name;
            return this;
        }
        
        public Builder password(String password){
            this.password = password;
            return this;
        }
        
        public Builder sex(String sex){
            this.sex = sex;
            return this;
        }
        
        public Builder age(String age){
            this.age = age;
            return this;
        }
        
        public User build(){
            return User(this);
        }
    }
    
    public void setPhone(String phone){
        this.phone = phone;
    }
}
```
当然，Builder模式的编写是很烦躁的，因为为了一个Builder对象，我们需要写大量的东西，但是，对于可读性，可扩展性来说，这一切是值得的(当然我很希望有一个能快速编写Builder的工具)。
调用：
```java
User user = User.Builder()
            .name("John")
            .password("123456")
            .sex(1)
            .age(18)
            .build();
user.setPhone("18812345678");
```
它的调用是简洁且阅读是轻松的。

### 2.3 建造者模式的有缺点
**优点**
> * Builder模式可以在build()方法对传入的参数进行检验，而不用在每一个参数传入的时候去检验
> * Builder比之于构造方法，好在能拥有多个可变参数，而不用去写多个重载方法
> * 在多线程中，Builder比Setter更加安全。

**缺点**
> * 为了创建对象，必须先构建它的Builder构建器，这会降低一点点性能，当然如果对性能不是要求特别特别严厉的话，这个模式是优雅的
> * Builder模式在编写的时候比重载构造方法来要多代码，所以这里推荐，只有在参数多于或等于4个的时候，才去使用这个模式，不然，得不偿失。

------

## ３ 单例设计模式之使用枚举类型或静态内部类
Singleton，在Effect Java中的定义为：仅仅被实例化一次的类。
也就是说，这个Singleton类的对象，在整个项目中，我们的期望应该是唯一的。这就是我们所说的单例设计模式。
单例设计模式对于几乎所有的工程师而言，肯定是相当熟悉的。但是，往往因为它的简单，而被忽略了一些细节。

### 3.1 Singlton的普通用法和问题
我们在单线程中编写Singleton类，是相当简单的，而在多线程中编写，我们第一反应就是synchronized。但是，使用锁机制，就真的安全吗？
我们来看代码，并跟着流程走一遍：
```java
class Singleton{
    private static Singleton sInstance;
    private Singleton(){}
    
    public final static Singleton getInstance(){
        if(sInstance == null){
            synchronized(this){
                if(sInstance == null){
                    sInstance = new Singleton();[@]
                }
            }
        }
        
        return sInstance;
    }
}
```
现有两个线程来创建这个Singleton对象，我们取名为ThreadA，ThreadB。
出现问题的步骤：
> step 1: ThreadA进入getInstance()方法，顺序执行到[@]处，但该实例化过程只执行了一半；
> step 2: 此时ThreadB进入并占用了ThreadA，进入getInstance()方法，判断sInstance不为空，直接返回sInstance。
> 这个时候ThreadB所返回的Singleton对象是一个不完整的对象。

所以说，即使使用了synchronized，也同样有可能不安全，那么应该怎么来写Singleton类呢？
Effective java提供了两种方法：静态内部类和枚举。

### 3.2 静态内部类编写Singleton
```java
class Singleton{
    private Singleton(){}
    
    public static final Singleton getInstance(){
        return Holder.INSTANCE;
    }
    
    private final static class Holder{
        private static final Singleton INSTANCE = new Singleton();
    }
}
```

### 3.3 枚举编写Singleton
```java
class Singleton{}

enum SingletonCreator{
    INSTANCE;
    
    Singleton instance;
    SingletonCreator(){
        instance = new Singleton();
    }
    
    public Singleton getInstance(){
        return instance;
    }
}
```
枚举类中的实例是被保证只被实例化一次的。所以INSTANCE也就只被执行一次。
```java
Singleton singleton = SingletonCreator.INSTANCE.getInstance();
```

------

## 4 谨慎使用无构造方法的类
我们经常会使用到一些只有静态方法和静态域的类，例如我们常用的工具类。这种类其实并不是很优雅，名声也不太好。因为当你调用该类的时候，所有的静态方法和静态域都会被初始化到。
但并不是说就不能使用它，毕竟在作为工具类，将一类对象的相关方法组合起来，便于使用，它还是能工作得很好的。

我们来说当我们使用它的时候，需要注意什么。
首先，是该类的方法数量，我们应该尽可能地少，这样能在我们调用该类的时候提高它的性能。
其次，是它的构造方法，但我们没有写它的构造方法的时候，会默认给我们一个无参的构造方法，所以，为了避免我们在使用它的时候，不小心去实例化它，我们需要将它的构造方法给隐藏起来。
```java
public class Tools{
    private Tools(){
        throw new AssertionError();
    }
}
```
在构造方法中抛出异常，是为了防止该类内部去实例化它。
private是为了防止其他类去实例化它。


