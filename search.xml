<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Gradle入门篇]]></title>
      <url>http://yoursite.com/2018/08/05/Gradle%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="Gradle的基础"><a href="#Gradle的基础" class="headerlink" title="Gradle的基础"></a>Gradle的基础</h2><h3 id="认识Gradle"><a href="#认识Gradle" class="headerlink" title="认识Gradle"></a>认识Gradle</h3><p>如果你要自己来构建一个Android项目，那么google会更加推荐你使用Gradle来构建。</p>
<blockquote>
<p>Gradle是一个构建脚本。</p>
</blockquote>
<p>Gradle有约定优于配置的原则，也就是说，它为设置和属性提供了默认值。</p>
<p>Gradle脚本使用的是Groovy语言（DSL）。由于Groovy是基于Java的，所以我们在看Gradle脚本的时候，其实并不是很费劲，这也是它的好处之一。<br>而正是由于它是基于Java虚拟机的，所以我们可以使用Java或者其他基于Java虚拟机的语言来编写我们的自定义插件。</p>
<h3 id="项目与任务"><a href="#项目与任务" class="headerlink" title="项目与任务"></a>项目与任务</h3><p>项目也就是我们创建的一个project。<br>任务对象包括一系列的动作对象，这些动作会按顺序执行（不能循环执行）。<br>任务类似于Java中的方法块。</p>
<p>每一个build.gradle代表着一个项目。而任务定义在构建脚本里。</p>
<h3 id="构建生命周期"><a href="#构建生命周期" class="headerlink" title="构建生命周期"></a>构建生命周期</h3><p>一个Gradle的构建通常有如下3个阶段：</p>
<ul>
<li>初始化：项目实例会在该阶段被创建。如果一个项目有多个模块，而且每个模块都有自己对应的build.gradle文件，则会创建多个项目实例</li>
<li>配置：在该阶段，构建脚本会被执行，并为每个项目实例创建和配置任务</li>
<li>执行：Gradle将会决定哪个任务会被执行。是否被执行取决于开始该次构建的参数配置和对应Gradle文件的当前目录</li>
</ul>
<h2 id="构建配置文件"><a href="#构建配置文件" class="headerlink" title="构建配置文件"></a>构建配置文件</h2><p>每一个由Gradle构建的项目，都应该<strong>至少</strong>有一个build.gradle文件。</p>
<p>我们看看Android中一个build.gradle文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">buildscript&#123;</div><div class="line">    repositories&#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dependencies&#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:1.2.3&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面例子中的元素是必须存在的。<br>repositories中的JCenter库为整个项目构建过程的依赖仓库。<br>Gradle中有很多仓库可供选择，我们可以提供自己本地的或是远程仓库。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Android插件提供了构建和测试所需要的一切。<br>每个Android项目都需要申请一个类似以下的插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply pulugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure></p>
<p>插件用于扩展Gradle构建脚本的能力。在一个项目中应用一个插件，该项目就可以使用该插件预定义一些属性和任务。</p>
<p>当然，你不能在一个模块中同时定义两个插件。例如你的模块为一个依赖库，那么你定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.library&apos;</div></pre></td></tr></table></figure></p>
<p>那么你就不能继续申请其他插件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.library&apos;</div><div class="line">apply plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure></p>
<p>这是错误的。</p>
<p>当你使用Android插件的时候，你不仅可以配置只用于Android的一些约定，还能生成只作用于Android的任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android&#123;</div><div class="line">    compileSdkVersion 22</div><div class="line">    buildToolsVersion &apos;22.0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子就是配置Android参数的一个例子。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>一个项目的结构大致如下：<br><img src="/img/gradle/project_picture.png" alt="project结构"><br>在这张图中，我们可以看到有两个build.gradle，外层的build.gradle为整个项目中唯一的Gradle配置文件，而app中的build.gradle为Application模块Gradle的配置文件。<br>Gradle会使用源集来编译代码。</p>
<blockquote>
<p>源集就是一组源文件，它们会被一起执行和编译。</p>
</blockquote>
<p>在Android项目中，main就是一个源集，它包含了所有的源代码和资源。<br>一般的源集如下图：<br><img src="/img/gradle/app_picture.png" alt="project结构"></p>
<p>我们在为Android应用编写测试代码的时候，也可以将所有测试相关的源代码放到一个单独的源集中，这个源集叫做“androidTest”。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存泄漏的几种情况]]></title>
      <url>http://yoursite.com/2018/08/01/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="单例设计模式导致的内存泄漏"><a href="#单例设计模式导致的内存泄漏" class="headerlink" title="单例设计模式导致的内存泄漏"></a>单例设计模式导致的内存泄漏</h2><p>单例设计模式在我们的开发过程中经常出现，虽然它的形式很简单，但有些小细节我们不注意的话，就容易出错。例如我们今天讲的内存泄漏问题。<br>我们都知道单例设计模式的一个特性就是它的引用是一个静态变量，而一个static变量的生命周期是和整个Application挂钩的，所以就会引发一个问题，如果我们向单例中传入一个Activity或Service实例，那么在Activity或Service销毁的时候，被静态引用持有的Activity或Service实例就无法被回收，那么就会导致内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final INSTANCE ;</div><div class="line">private Context mContext;</div><div class="line"></div><div class="line">private Singleton(Context context)&#123;</div><div class="line">    mContext = context;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Singleton getInstance(Context context)&#123;</div><div class="line">    if(INSTANCE == null)&#123;</div><div class="line">        INSTANCE = new Singleton(context);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上面的代码，如果我们在Activity或Service中去调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton singleton = Singleton.getInstance(this);</div></pre></td></tr></table></figure></p>
<p>此时就是将我们的Activity或Service的引用作为参数来构建Singleton。而在Activity或Service的onDestroy()方法调用的时候，Singleton还存在于堆中，而Singleton中又有着Activity或Service的引用，故此会让Activity或Service无法进行销毁回收。</p>
<p>那么我们该怎么来解决这样的问题呢？其实很简单，就是将Context用App的Context来设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton singleton = Singleton.getInstance(this.getApplicationContext());</div></pre></td></tr></table></figure></p>
<p>或者直接在单例类中就进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static final INSTANCE ;</div><div class="line">private Context mContext;</div><div class="line"></div><div class="line">private Singleton(Context context)&#123;</div><div class="line">    mContext = context.getApplicationContext();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Singleton getInstance(Context context)&#123;</div><div class="line">    if(INSTANCE == null)&#123;</div><div class="line">        INSTANCE = new Singleton(context);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>也就是说，我们在使用单例模式的时候，要尽量使用全局的Context。</p>
</blockquote>
<h2 id="非静态内部类导致的内存泄漏"><a href="#非静态内部类导致的内存泄漏" class="headerlink" title="非静态内部类导致的内存泄漏"></a>非静态内部类导致的内存泄漏</h2><p>非静态内部类都会<strong>默认</strong>持有一个外部类的引用（匿名内部类也是），当内部类的生命周期比外部类的生命周期长的时候，就容易引发内存泄漏。</p>
<h3 id="Handler引发的内存泄漏"><a href="#Handler引发的内存泄漏" class="headerlink" title="Handler引发的内存泄漏"></a>Handler引发的内存泄漏</h3><p>一般我们在使用Handler的时候，都是这么写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private Handler mHandler = new Handler()&#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg)&#123;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的mHandler对象中会默认持有外部的Activity的引用，这个在“<a href="https://zouxiaobang.github.io/2018/07/12/%E7%9F%A5%E8%AF%86%E7%82%B9-Handler/" target="_blank" rel="external">知识点 – Handler</a>”一节已经说得很清楚了，其中的Message对象会存放在Activity所在线程的MessageQueue中。如果我们的Activity销毁时，Message对象还在继续执行或未执行，那么对应的Activity也就无法销毁回收，这就导致了内存泄漏。</p>
<h3 id="Thread或AsyncTask引发的内存泄漏"><a href="#Thread或AsyncTask引发的内存泄漏" class="headerlink" title="Thread或AsyncTask引发的内存泄漏"></a>Thread或AsyncTask引发的内存泄漏</h3><p>我们在Activity中直接去实例化Thread和AsyncTask对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Thread thread = new Thread()&#123;</div><div class="line">    @Override</div><div class="line">    public void run()&#123;</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(2000);</div><div class="line">        &#125; catch(Exception ex)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">thread.start();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">new AsyncTask&lt;Void, Void, Void&gt;()&#123;</div><div class="line">    @Override</div><div class="line">    public void doInBackground(Void... params)&#123;</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(2000);</div><div class="line">        &#125; catch(Exception ex)&#123;&#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;.execute();</div></pre></td></tr></table></figure>
<p>同样的这种内部类会持有外部类的引用，所以在耗时操作的时候有可能会造成内存泄漏。</p>
<h3 id="非静态内部类导致的内存泄漏的解决方案"><a href="#非静态内部类导致的内存泄漏的解决方案" class="headerlink" title="非静态内部类导致的内存泄漏的解决方案"></a>非静态内部类导致的内存泄漏的解决方案</h3><p>那么我们是如何来解决这个问题的？</p>
<blockquote>
<p>静态内部类 + 弱引用</p>
</blockquote>
<p>我们以Handler为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">private static class MyHandler extends Handler&#123;</div><div class="line">    private WeakReference&lt;MainActivity&gt; mActivity ;</div><div class="line">    </div><div class="line">    public MyHandler(MainActivity activity)&#123;</div><div class="line">        mActivity = new WeakReference&lt;&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    pbulic void handleMessage(Message msg)&#123;</div><div class="line">        MainActivity activity = mActivity.get();</div><div class="line">        if(activity != null)&#123;</div><div class="line">            //TODO : Message的执行...</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过将外部类的引用以弱引用的方式作为参数传进去Handler，当GC时，activity由于是弱引用，所以也会被回收并释放内存，这样就不会发生内存泄漏的问题。<br>而当Activity引用不见之后，Message就已经不会在进行执行了，但是，msg依然存在于MessageQueue中，那么我们应该在onDestroy()方法中去remove掉Message：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected void onDestroy()&#123;</div><div class="line">    super.onDestroy();</div><div class="line">    </div><div class="line">    mHandler.removeCallbacksAndMessages(null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Thread和AsyncTask的例子也是一样的处理。</p>
<h2 id="未取消注册或回调导致的内存泄漏"><a href="#未取消注册或回调导致的内存泄漏" class="headerlink" title="未取消注册或回调导致的内存泄漏"></a>未取消注册或回调导致的内存泄漏</h2><p>我们经常会在Activity中去注册一个广播，而却忘了去注销广播，或注册和注销的执行生命方法没有对应。由于广播与非静态内部类一样都会默认持有外部类的引用，所以处理不当一样会造成内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle saveInstanceState)&#123;</div><div class="line">    ....</div><div class="line">    </div><div class="line">    registerReceiver(mReceiver, mIntentFilter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected void onDestroy()&#123;</div><div class="line">    ...</div><div class="line">    unregisterReceiver(mReceiver);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类似于以上的做法，如果在onResume()方法中注册，则对应的在onPause()方法中注销。</p>
<h2 id="计时器的使用导致的内存泄漏"><a href="#计时器的使用导致的内存泄漏" class="headerlink" title="计时器的使用导致的内存泄漏"></a>计时器的使用导致的内存泄漏</h2><p>对于Timer+TimerTask的结合使用，我们经常会在Timer中设置时长来执行TimerTask中的任务。此时TimerTask中持有外部类的引用，而如果外部类在销毁时，TimerTask中的任务尚未完成，那么就会导致内存泄漏。<br>所以我们在Activity销毁的时候，要手动去cancel掉Timer和TimerTask。</p>
<h2 id="集合中存在对象导致的内存泄漏"><a href="#集合中存在对象导致的内存泄漏" class="headerlink" title="集合中存在对象导致的内存泄漏"></a>集合中存在对象导致的内存泄漏</h2><p>当我们将对象使用一个容器（List、Map等）存储起来，这样可以很方便地执行一些逻辑，例如对对象的管理等。但是，其产生内存泄漏的原因也很好解释，就是容器中持有着这个对象的引用，而如果这个对象想要销毁时，容器还存在，那就会造成内存泄漏。<br>此时的解决方法就是在我们已经确定不需要使用到该对象的时候，就要把该对象从容器中remove掉。</p>
<h2 id="资源未关闭或释放导致的内存泄漏"><a href="#资源未关闭或释放导致的内存泄漏" class="headerlink" title="资源未关闭或释放导致的内存泄漏"></a>资源未关闭或释放导致的内存泄漏</h2><p>最典型的例子就是IO流的使用，我们一直强调在使用完IO流之后，要对该IO流进行关闭，也就是在finally块中去执行IO流的close()方法。</p>
<p>当然，除了IO流，还有File、Cursor、sqlite等，这些操作一般都会使用到缓冲来进行资源数据的读写，如果没有及时关闭的话，它们就是一直占用着资源而得不到释放，这样就会造成内存的泄漏。</p>
<h2 id="属性动画导致的内存泄漏"><a href="#属性动画导致的内存泄漏" class="headerlink" title="属性动画导致的内存泄漏"></a>属性动画导致的内存泄漏</h2><p>属性动画通常是对某个控件来执行动画操作，而这个动画其实也是一个耗时的任务。当我们在销毁掉Activity的时候，我们当然就已经看不到动画现象了，但是其实不然，这个动画会一直播放，知道播放完成。但是这个控件并没有办法在Activity销毁的时候进行释放，这就导致了内存泄漏。</p>
<p>这个解决方法就是在onDestroy()方法中执行该动画的cancel()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protected void onDestroy()&#123;</div><div class="line">    ...</div><div class="line">    mAnimator.cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="WebView导致的内存泄漏"><a href="#WebView导致的内存泄漏" class="headerlink" title="WebView导致的内存泄漏"></a>WebView导致的内存泄漏</h2><p>WebView加载网页后会长期占用内存而不会释放，这样就是造成内存泄漏的原因了。<br>我们应该在onDestroy()方法中去销毁这个WebView并进行释放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void onDestroy()&#123;</div><div class="line">    ...</div><div class="line">    //这里注意要把WebView从视图中移除</div><div class="line">    mWebViewContainer.removeView(mWebView);</div><div class="line">    mWebView.stopLoading();</div><div class="line">    mWebView.getSettings().setJavaScriptEnabled(false);</div><div class="line">    mWebView.clearHistory();</div><div class="line">    mWebView.removeAllViews();</div><div class="line">    mWebView.destroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本文参考自“<a href="https://mp.weixin.qq.com/s/FQ3isLxFU5addqNyyzGWlA" target="_blank" rel="external">Android内存优化——常见内存泄漏及优化方案（面试必问）</a>”（微信链接），特此感谢</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android实现边录音边播放功能]]></title>
      <url>http://yoursite.com/2018/07/30/Android%E5%AE%9E%E7%8E%B0%E8%BE%B9%E5%BD%95%E9%9F%B3%E8%BE%B9%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<hr>
<p>最近来了个需求，需要做一个通过adb命令来启动APP并进行手机音频测试。<br>具体的样子我就不多说了，今天主要是来说一下其中的一种测试模式，一边录音一边播放的功能。</p>
<h2 id="缺点提前"><a href="#缺点提前" class="headerlink" title="缺点提前"></a>缺点提前</h2><p>在编写代码之前，我需要先告知一下大家，这个功能有一个很严重的问题，就是在外部录音外放的过程，将会有很大的噪音出现，至于原因等下分析。也希望有知道怎么处理的兄弟姐妹们，留言告知，感激不尽。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="录音与播放所使用的类"><a href="#录音与播放所使用的类" class="headerlink" title="录音与播放所使用的类"></a>录音与播放所使用的类</h3><p>首先，因为要让录音和播放同时执行，那么我们就不能使用MediaRecorder和MediaPlayer了，因为这两个都需要去写入和读取文件来操作。<br><strong>那么我们应该选择哪个类呢？</strong><br><strong>先说说录音，我们选择的是AudioRecorder</strong>。你可能会有疑问，MediaRecorder也是继承自AudioRecorder的，其功能不是更强大吗？是的，但是由于MediaRecorder进一步地进行处理，它同时失去了一些比较灵活的音频采集方式。AudioRecorder是先获取一帧一帧的PCM，然后再进行处理的。而我们需要在录音时能播放音频，就需要这种一帧帧处理的PCM了。<br><strong>而播放呢，我们选择了AudioTrack</strong>。因为Adroid给出AudioTrack的用法就是，可播放解码后的PCM数据的裸流。</p>
<p>讲完要使用的类，那么我们来看看这两个类需要怎么来实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes)</div><div class="line"></div><div class="line">AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode);</div></pre></td></tr></table></figure></p>
<p>AudioRecorder具体参数我们来解析一下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">audioSource</td>
<td style="text-align:center">音频源：指的是从哪里获取的音频。我们一般从MIC麦克风中获取，所以一般使用MIC参数。</td>
</tr>
<tr>
<td style="text-align:center">sampleRateInHz</td>
<td style="text-align:center">采样率：音频的采样频率（赫兹）。每秒钟能够采样的次数，值越高，音质越好。一般的参数有44100、22050、11025.当然，如果是音质要求不高的话，直接使用8000、4000就可以。</td>
</tr>
<tr>
<td style="text-align:center">channelConfig</td>
<td style="text-align:center">声道：声道有双声道和单声道，双声道是立体声。分别为MONO（单声道）、STEREO（立体声）。</td>
</tr>
<tr>
<td style="text-align:center">autoFormat</td>
<td style="text-align:center">编码和采样大小：将采集到的数据进行PCM编码（脉冲代码进行调制的编码。PCM通过抽样、量化、编码三个步骤将连续变化的虚拟信号转换成数字信号）。android支持的采样大小为16bit和8bit，采样大小越大，包含的信息量也就越大，音质也就越好。</td>
</tr>
<tr>
<td style="text-align:center">bufferSizeInBytes</td>
<td style="text-align:center">采集音频数据的缓存区大小：一般为getMinBufferSize()的整数倍。</td>
</tr>
</tbody>
</table>
<p>而AudioTrack的参数和AudioRecorder的参数差不多，只是第一个参数不同，且最后多了一个mode参数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">streamType</td>
<td style="text-align:center">播放类型：一般有闹钟类型、来电类型、音乐类型播放等。我们一般使用MUSIC模式，此时的音量就由音乐类型的音量控制。</td>
</tr>
<tr>
<td style="text-align:center">mode</td>
<td style="text-align:center">使用的数据类型：有STREAMING、STATIC两种类型。一般我们使用流–AudioTrack.MODE_STREAM。</td>
</tr>
</tbody>
</table>
<h3 id="各种参数的初始化"><a href="#各种参数的初始化" class="headerlink" title="各种参数的初始化"></a>各种参数的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">private static final int FREQUENCY = 44100;</div><div class="line"></div><div class="line">protected int mInBuffSize;</div><div class="line">/**</div><div class="line"> * 录制音频对象</div><div class="line"> */</div><div class="line">private AudioRecord mInRec;</div><div class="line">/**</div><div class="line"> * 录入的字节数组</div><div class="line"> */</div><div class="line">private byte[] mInBytes;</div><div class="line">/**</div><div class="line"> * 存放录入字节数组的大小</div><div class="line"> */</div><div class="line">private LinkedList&lt;byte[]&gt; mInQueue;</div><div class="line">/**</div><div class="line"> * AudioTrack 播放缓冲大小</div><div class="line"> */</div><div class="line">private int mOutBuffSize;</div><div class="line">/**</div><div class="line"> * 播放音频对象</div><div class="line"> */</div><div class="line">private AudioTrack mOutTrack;</div><div class="line">/**</div><div class="line"> * 播放的字节数组</div><div class="line"> */</div><div class="line">private byte[] mOutBytes;</div><div class="line">/**</div><div class="line"> * 录制音频线程</div><div class="line"> */</div><div class="line">private Thread mRecord;</div><div class="line">/**</div><div class="line"> * 播放音频线程</div><div class="line"> */</div><div class="line">private Thread mPlay;</div><div class="line">private boolean isRecording = false;</div><div class="line"></div><div class="line">private void init()&#123;</div><div class="line">    // AudioRecord 得到录制最小缓冲区的大小</div><div class="line">    mInBuffSize = AudioRecord.getMinBufferSize(FREQUENCY,</div><div class="line">            AudioFormat.CHANNEL_CONFIGURATION_STEREO,</div><div class="line">            AudioFormat.ENCODING_PCM_16BIT) * 4;</div><div class="line">    // 实例化一个字节数组，长度为最小缓冲区的长度</div><div class="line">    mInBytes = new byte[mInBuffSize];</div><div class="line">    // 实例化一个链表，用来存放字节组数</div><div class="line">    mInQueue = new LinkedList&lt;byte[]&gt;();</div><div class="line"></div><div class="line"></div><div class="line">    // AudioTrack 得到播放最小缓冲区的大小</div><div class="line">    mOutBuffSize = AudioTrack.getMinBufferSize(FREQUENCY,</div><div class="line">            AudioFormat.CHANNEL_CONFIGURATION_STEREO,</div><div class="line">            AudioFormat.ENCODING_PCM_16BIT) * 4;</div><div class="line">    // 实例化一个长度为播放最小缓冲大小的字节数组</div><div class="line">    mOutBytes = new byte[mOutBuffSize];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们对录音播放的启动和暂停操作，则利用isRecording这个boolean变量来控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">if (!isRecording)&#123;</div><div class="line">        isRecording = true;</div><div class="line">        // 实例化播放音频对象</div><div class="line">        mInRec = new AudioRecord(MediaRecorder.AudioSource.MIC, FREQUENCY,</div><div class="line">                AudioFormat.CHANNEL_CONFIGURATION_STEREO,</div><div class="line">                AudioFormat.ENCODING_PCM_16BIT, mInBuffSize);</div><div class="line"></div><div class="line">        // 实例化播放音频对象</div><div class="line">        mOutTrack = new AudioTrack(AudioManager.STREAM_MUSIC, FREQUENCY,</div><div class="line">                AudioFormat.CHANNEL_CONFIGURATION_STEREO,</div><div class="line">                AudioFormat.ENCODING_PCM_16BIT, mOutBuffSize,</div><div class="line">                AudioTrack.MODE_STREAM);</div><div class="line"></div><div class="line">        flag = true;</div><div class="line">        mRecord = new Thread(new recordSound());</div><div class="line">        mPlay = new Thread(new playRecord());</div><div class="line">        // 启动录制线程</div><div class="line">        mRecord.start();</div><div class="line">        // 启动播放线程</div><div class="line">        mPlay.start();</div><div class="line">    &#125; else &#123;</div><div class="line">        isRecording = false;</div><div class="line">        flag = false;</div><div class="line">        mInRec.stop();</div><div class="line">        mInRec.release();</div><div class="line">        mInRec = null;</div><div class="line">        mOutTrack.stop();</div><div class="line">        mOutTrack.release();</div><div class="line">        mOutTrack = null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，我们应该发现了，我们这里的record和play是两个线程。把录音和播放放在两个线程中，而不要都放在UI线程里面，容易造成ANR。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class recordSound implements Runnable&#123;</div><div class="line">    @Override</div><div class="line">    public void run()&#123;</div><div class="line">        byte[] bytes_pkg;</div><div class="line">        // 开始录音</div><div class="line">        mInRec.startRecording();</div><div class="line"></div><div class="line">        while (flag) &#123;</div><div class="line">            mInRec.read(mInBytes, 0, mInBuffSize);</div><div class="line">            bytes_pkg = mInBytes.clone();</div><div class="line">            Log.i(TAG, &quot;........recordSound bytes_pkg==&quot; + bytes_pkg.length);</div><div class="line">            if (mInQueue.size() &gt;= 2)&#123;</div><div class="line">                mInQueue.removeFirst();</div><div class="line">            &#125;</div><div class="line">            mInQueue.add(bytes_pkg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class playRecord implements Runnable &#123;</div><div class="line">    @Override</div><div class="line">    public void run()&#123;</div><div class="line"></div><div class="line">        byte[] bytes_pkg = null;</div><div class="line">        // 开始播放</div><div class="line">        mOutTrack.play();</div><div class="line"></div><div class="line">        while (flag)&#123;</div><div class="line">            try&#123;</div><div class="line">                mOutBytes = mInQueue.getFirst();</div><div class="line">                bytes_pkg = mOutBytes.clone();</div><div class="line">                mOutTrack.write(bytes_pkg, 0, bytes_pkg.length);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok，这样就完成了一个简单的例子。当然，如果你觉得这个录音和播放的音质等等都不符合你的需求，那就可以自己去调一下参数：sampleRateInHz, channelConfig, audioFormat, bufferSizeInBytes</p>
<h3 id="外放杂音解释"><a href="#外放杂音解释" class="headerlink" title="外放杂音解释"></a>外放杂音解释</h3><p>噪音产生的原因是因为声音录进去了, 然后播放, 再次录音叠加进去了。边录边放形成了回馈，所以会产生叫啸。<br>目前我还没想到有什么好的解放方法，只能使用耳机来验证这个例子，当然，使用耳机的话，就不会造成声音回馈了。<br>如果有哪位大神知道这个怎么解，还请不吝赐教。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[侃侃设计模式-装饰者模式]]></title>
      <url>http://yoursite.com/2018/07/29/%E4%BE%83%E4%BE%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>我们接到一个新的需求需要去改变原先类的时候，我们经常会立马就去原先的类中去修改。当然，只是来了一个需求，我们去修改原类可能并不是很难，但是要是又来了几个呢？可能你连想去翻开原类去看的动力都没有。</p>
<p>我们以一件衣服为例，原来的衣服是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Clothes &#123;</div><div class="line">    public void Clothes()&#123;</div><div class="line">        haveSleeves();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void haveSleeves()&#123;</div><div class="line">        System.out.println(&quot;has two sleeves.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这件衣服带着两个袖子。<br>但是客户现在来需求了，想要把这两个袖子都做成长袖，那么我们去这个衣服类中改呗：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void haveSleeves()&#123;</div><div class="line">    System.out.println(&quot;has two sleeves.&quot;);</div><div class="line">    System.out.println(&quot;two sleeves are long sleeves.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK,完成。</p>
<p>但是，但是，需求又来了，现在客户需要添加上两个袋子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Clothes &#123;</div><div class="line">    public void Clothes()&#123;</div><div class="line">        haveSleeves();</div><div class="line">        haveSack();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void haveSleeves()&#123;</div><div class="line">        System.out.println(&quot;has two sleeves.&quot;);</div><div class="line">        System.out.println(&quot;two sleeves are long sleeves.&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void haveSack()&#123;</div><div class="line">        System.out.println(&quot;has two sacks.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到了这里，其实你也已经看出来了，这个类，对于维护和拓展来说，简直就是灾难性的。</p>
<blockquote>
<p>有一个设计原则叫做：开闭原则–对修改封闭，对拓展开发。</p>
</blockquote>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>对于上面的例子，我们也知道，这个肯定是不符合开闭原则的，因为我们一直在这个类里面进行修改。</p>
<p>那么，我们为什么要尽量少去修改原来的代码呢？<br>这是因为原先的代码是经过多次检验的，Bug也比较少，而如果直接去修改原先的代码，则很大几率会改出其他的问题，特别是对于一个极大的类来说。<br>所以，对于一个良好设计来说，应当是易于被拓展的，而不是想着去修改它。</p>
<p>那么，我们来看看上面的例子应该怎么来设计。<br>首先，当客户要我们做一个长袖的衣服时，我们便不能在原来的类里面进行修改了。这时，我们可能很容易就想到继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class LongSleevesClothes extends Clothes&#123;</div><div class="line">    @Override</div><div class="line">    public void haveSleeves()&#123;</div><div class="line">        super.haveSleeves();</div><div class="line">        System.out.println(&quot;two sleeves are long sleeves.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，我们就创建了一个新的类来表现出长袖，而且也不需要去修改原来的类。<br>那么客户的第二个需求，要加上两个袋子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SackClothes extends LongSleevesClothes &#123;</div><div class="line">    public void SackClothes()&#123;</div><div class="line">        super();</div><div class="line">        </div><div class="line">        haveSack();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void haveSack()&#123;</div><div class="line">        System.out.println(&quot;has two sacks.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么客户很无理取闹，他又想要一个不是长袖，但要有袋子的，那么我们又得去继承Clothes类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class SackWithoutSleevesClothes extends Clothes &#123;</div><div class="line">    public void SackWithoutSleevesClothes()&#123;</div><div class="line">        super();</div><div class="line">        </div><div class="line">        haveSack();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void haveSack()&#123;</div><div class="line">        System.out.println(&quot;has two sacks.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看看这几个需求所需要的类图：<br><img src="/img/decorator/extendsUML.png" alt="继承的UML"></p>
<p>我们可以看到，当需要进行创建新的事物的时候，我们都需要去创建一个新的继承类。<br>如果需求更多呢，是不是会造成类爆炸，你看到一大堆这样的类，自己都头晕了，更别说想去使用它了呢。<br><img src="/img/decorator/extendsUML2.png" alt="继承的UML2"><br>这样一来，我们的类与类之间的耦合度将变得无比高，拓展性也相当不好。<br>那么，我们该如何来作出改变呢？</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p>动态地将责任附加到对象上，若要拓展功能，装饰者提供了比继承更加有弹性的替代方案。</p>
</blockquote>
<p>那么装饰者模式有什么特点呢：</p>
<ul>
<li>装饰者和被装饰者类型一致，也就是拥有同样的超类</li>
<li>你可以用一个或多个装饰者来包装同一个对象</li>
<li>既然两者是同一个超类，所以在任何需要原始对象的地方，都可以使用包装类来代替。</li>
<li>装饰者可以在所委托的被装饰者的行为之前或之后，加上自己的行为，已达到某种目的。</li>
<li>对象可以在任何时候被装饰，所以你可以在运行时动态地，不限量地对对象进行包装。</li>
</ul>
<p>例如上面的例子，我们先把Clothes类修改一下，方便我们更好的理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Clothes &#123;</div><div class="line">    public void description()&#123;</div><div class="line">        System.out.println(&quot;has two sleeves.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以先看看第一个需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class LongSleeves extends Clothes&#123;</div><div class="line">    private Clothes mClothes;</div><div class="line">    public LongSleeves(Clothes clothes)&#123;</div><div class="line">        this.mClothes = clothes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void description()&#123;</div><div class="line">        mClothes.description();</div><div class="line">        System.out.println(&quot;two sleeves are long sleeves.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里你会发现，我们将长袖继承自Clothes类，而在类里面又定义了一个Clothes对象，然后在其行为方法里去调用Clothes对象本身就有的行为。那么这样做的目的是什么呢？<br>不急，我们先来看看客户又提出的两个需求 – 我现在要做一个长袖，然后在袖子上绣花的衣服。而且，我还要一个不是长袖，但上面绣花的衣服。<br>那么，如果按照之前继承的做法，我们就需要再来创建两个类：LongSleevesWithFlower和FlowerClothes了。<br>当然，我们也说过了这样会造成类爆炸，我们试着用装饰者来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Flower extends Clothes&#123;</div><div class="line">    private Clothes mClothes;</div><div class="line">    public Flower(Clothes clothes)&#123;</div><div class="line">        this.mClothes = clothes;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void description()&#123;</div><div class="line">        mClothes.description();</div><div class="line">        System.out.println(&quot;has flowers.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来到这里，你可能已经知道该怎么做了。是的，我们在制作衣服的时候，几个需求很明显地就可以完成了<br>长袖衣服：LongSleeves longSleeves = new LongSleeves(new Clothes());<br>长袖加绣花衣服：Flower flowerWithLongSleeves = new Flower(longSleeves);或者LongSleeves flowerWithLongSleeves = new LongSleeves(flower);<br>绣花衣服：Flower flower = new Flower(new Clothes());</p>
<p>这些都是我们在运行时动态地实例化的，我们可以更加灵活地得到我们想要的效果。<br>那么看了这么久，装饰者模式是怎么来实现解耦的呢？<br>例如上面的例子，如果按照继承的做法，我们在长袖加绣花的衣服的制作上，我们是需要先知道长袖是怎么做的，然后再去思考怎么绣花。而装饰者模式，它在绣花中就只需要知道绣花的步骤，而不用去考虑其他的行为，当我们要使用的时候，我们就把它们动态地组合在一起就可以了。</p>
<p>其实，在我们日常的代码编写中，也会遇到装饰者模式，你想到了吗？<br>没错，就是IO流的使用。相当经典的装饰者模式。例如以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filepath)));</div><div class="line"></div><div class="line">BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));</div></pre></td></tr></table></figure></p>
<p>通过不断地对流进行包装，可以实现更加强大或更多或更符合你要求的功能。这也就是IO流的一个很大的特色。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[侃侃设计模式--观察者模式]]></title>
      <url>http://yoursite.com/2018/07/25/%E4%BE%83%E4%BE%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>你肯定用过监听器，没错，监听器就是很典型的使用了观察者模式。如果你很仔细地去观察一个监听器，你就会发现，这个监听器就是又两部分组成：监听者+发送者（被监听者）。<br>我们先来看一个使用了监听器的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class People implements PlushingHouse.PlushingLinstener&#123;</div><div class="line">    private PlushingHouse mPlushingHouse;</div><div class="line"></div><div class="line">    public People()&#123;</div><div class="line">        mPlushingHouse = new PlushingHouse();</div><div class="line">        mPlushingHouse.setListener(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update(String newPaper)&#123;</div><div class="line">        System.out.println(newPaper);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class PlushingHouse&#123;</div><div class="line">    private PlushingListener mListener;</div><div class="line"></div><div class="line">    public void producePaper()&#123;</div><div class="line">        final String newPaper = produceNewPaper();</div><div class="line">        if(mListener != null)&#123;</div><div class="line">            mListener.update(newPaper);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private String produceNewPaper()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setListener(PlushingListener listener)&#123;</div><div class="line">        this.mListener = listener;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public interface PlushingListener&#123;</div><div class="line">        void update(String newPaper);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里举了个订报的例子。上面是一个人订了一家出版社的报纸，当出版社（PlushingHouse）出新的报纸（producePaper）的时候，就会去通知（mListener.update）所有订阅它的人。而订阅的那个人，就会收到报纸（System.out.println）。<br>对于上面的代码，只要在People中注册了监听器，就能及时收到PlushingHouse的消息。</p>
<p>现在我们来把监听器和观察者对应起来<br>Subject（主题） – PlushingHouse出版社<br>Observer（观察者） – People人</p>
<blockquote>
<p>观察者模式定义了对象之间的一对多的依赖。这样当一个对象的状态发生变化时，其他依赖于它的对象都会收到通知并对通知做处理。</p>
</blockquote>
<p>我们先来看看观察者的类图：<br><img src="/img/observer/uml.png" alt="观察者模式UML图"><br>主题至少要有两个功能：注册和通知，最好再加上一个：取消注册<br>registerObserver()、unregisterObserver()、notificateObserver()</p>
<p>在主题对象中，拥有一些观察者对象所没拥有的数据或状态，而观察者希望去使用到这些数据，或当这些数据发生变化的时候能够做出反应，那就很需要观察者模式了。<br>观察者模式只需要关注接口。<br>也就是主题对象只需知道某个观察者实现了该接口，那么当自身状态发生变化的时候，主题会通知所有实现了该接口的观察者对象，而不需要知道观察者具体是多么类。</p>
<blockquote>
<p>观察者能够随时注册或取消注册，是因为主题并不依赖于具体的观察者类，这就是观察者模式的解耦。</p>
</blockquote>
<p>如此，当我们有新的观察者需要设计的时候，并不影响到主题，而当我们的主题需要进行修改的时候，也不会影响到观察者。只要观察者实现的接口没有变化，而主题依然在联系这个接口，我们都可以随意地去修改具体的观察者和主题类。</p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>我们现在来看看一个完整的观察者模式的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Subject&#123;</div><div class="line">    void registerObserver(Observer o);</div><div class="line">    void unregisterObserver(Observer o);</div><div class="line">    void notificateObserver();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是主题的接口类，我们定义了主题的3个功能性方法：注册、注销、通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Observer&#123;</div><div class="line">    void update(Object o);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是观察者接口，定义了观察者在接到通知后所要处理的方法。<br>这里的参数类型为Object，则在主题的通知时可以传入各种类型的参数。</p>
<p>接下来我们还是举订阅报纸的例子来写这个观察者模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class PlushingHouse implements Subject&#123;</div><div class="line">    private List&lt;Observer&gt; mObservers = new ArrayList&lt;&gt;();</div><div class="line">    private String mNewPager = &quot;&quot;;</div><div class="line">    </div><div class="line">    public void registerObserver(Observer o)&#123;</div><div class="line">        if(!mObservers.contains(o))&#123;</div><div class="line">            mObservers.add(o);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void unregisterObserver(Observer o)&#123;</div><div class="line">        if(mObservers.contains(o))&#123;</div><div class="line">            mObservers.remove(o);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void notificateObservers()&#123;</div><div class="line">        for(Observer o: mObservers)&#123;</div><div class="line">            o.update(mNewPager);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void produceNewPager(String newPager)&#123;</div><div class="line">        mNewPager = newPager;</div><div class="line">        notificateObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，当有人要订阅报纸的时候，我们会将这个人添加到一个List中（如果那个人已经订阅过了，就不重复加入了）。而如果有人要取消订阅了，那就从List中将这个人去除。当生产出新的报纸的时候，就会通知所有订阅了报纸的人。</p>
<p>那么人们想要订阅该怎么办呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class People implements Observer&#123;</div><div class="line"></div><div class="line">    public void update(Object o)&#123;</div><div class="line">        read((String)o);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void read(String newPager)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要这个人实现了Observer接口，那么他就能够订阅这家报社的报纸了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PlushingHouse ph = new PlushingHouse();</div><div class="line">People p = new People();</div><div class="line"></div><div class="line">ph.registerObserver(p);</div><div class="line">ph.produceNewPager(&quot;i produce newpager.&quot;);</div></pre></td></tr></table></figure>
<p>看到这里，你可能会有疑虑，为什么上面的逻辑看起来是报社去注册人，而不是人主动去订阅报社呢？<br>对的，上面的代码可行，但在某些情况下并不友好。<br>例如当某个人想要去订阅这家报社的报纸，那么他得让报社去注册他，而不能自己主动去注册。<br>那么我们要怎么让观察者能主动去注册呢？也就是说，让观察者能有一个register方法，可以在使用观察者对象的时候被调用，例如people.registerNewPager();<br>那么，我们在People观察者类中来设计这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class People implements Observer&#123;</div><div class="line">    private Subject mSubject;</div><div class="line">    </div><div class="line">    public void registerNewPager(Subject subject)&#123;</div><div class="line">        mSubject = subject;</div><div class="line">        mSubject.registerObserver(this);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void unregisterNewPager()&#123;</div><div class="line">        if(mSubject != null)&#123;</div><div class="line">            mSubject.unregisterObserver(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void update(Object o)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，我们就可以让People来主动注册报社了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PlushingHouse ph = new PlushingHouse();</div><div class="line">People p = new People();</div><div class="line"></div><div class="line">p.registerNewPager(ph);</div><div class="line"></div><div class="line">ph.produceNewPager(&quot;i produce newpager.&quot;);</div></pre></td></tr></table></figure></p>
<p>你可能会说，将对主题的调用放到观察者中，这样不是让主题和观察者类相互依赖了吗？<br>对，但也不对，我们可以看到，我们在具体的主题类中会去调用观察者的update()方法，而在具体的观察者类中也会去调用主题的注册和注销方法。但是我们一直在调用的都是接口中的方法，也就是说具体的主题类和具体的观察者类并没有互相依赖，所以当我们去修改具体的主题类或修改具体的观察者是不会互相影响的。这就是解耦带来的好处。</p>
<p>那么，在观察者模式中，解耦又是怎么一回事？<br>我们来看看这个主题类。在这个类中，它其实并不知道谁会注册它，会订阅它，只是使用一个方法来将订阅它的人存起来。而当它有变化的时候，会去通知所有的观察者，在这个过程中，它同样不需要知道那个观察者是谁。它只需要知道，你是有实现了Observer接口的。（就像你订阅报纸，报社并不需要知道你是谁，只要你交了钱就可以）<br>对于观察者类，分析其实也是一样的。</p>
<p>你可能又发现了一个问题了，这种情况下，观察者只能被动地等待主题来“推送”内容。而当观察者想要主动去“拉取”主题的数据呢，那该怎么办？没错，你可以在主题里面添加getter()方法。<br>这是个比较简单的做法，但是，这个问题早就被解决了，在哪里呢？就是Java内置的观察者模式代码。</p>
<h2 id="Java内置的观察者模式"><a href="#Java内置的观察者模式" class="headerlink" title="Java内置的观察者模式"></a>Java内置的观察者模式</h2><p>java.util包中包含了最基本的Observer接口和Observable类（注意这里的Observable是一个类）。<br>单看名字，我们也能猜出来，这里的Observer相当于我们自己设计的观察者模式中的观察者，而Observable就是我们的主题Subject。<br>那么它们的区别是怎样的呢？我们来捋一捋源码。<br>首先是Observer接口的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Observer &#123;</div><div class="line">    /**</div><div class="line">     * This method is called whenever the observed object is changed. An</div><div class="line">     * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object&apos;s</div><div class="line">     * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object&apos;s</div><div class="line">     * observers notified of the change.</div><div class="line">     *</div><div class="line">     * @param   o     the observable object.</div><div class="line">     * @param   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</div><div class="line">     *                 method.</div><div class="line">     */</div><div class="line">    void update(Observable o, Object arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它和我们自定义的Observer接口很像，都是只定义了一个方法，该方法的功能就是在被主题通知后可进行数据的更新操作。其中第一个参数为我们要进行观察的对象，而第二个参数就是变化的那个数据。</p>
<p>接下来我们来看看Observable的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Observable &#123;</div><div class="line">    private boolean changed = false;</div><div class="line">    private Vector&lt;Observer&gt; obs;</div><div class="line"></div><div class="line">    public Observable()&#123;</div><div class="line">        obs = new Vector&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized void addObserver(Observer o)&#123;</div><div class="line">        if(o == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        if(!obs.contains(o))&#123;</div><div class="line">            obs.addElement(o);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized void deleteObserver(Observer o)&#123;</div><div class="line">        obs.removeElement(o);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void notifyObservers()&#123;</div><div class="line">        notifyObservers(null);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void notifyObservers(Object arg)&#123;</div><div class="line">        Object[] arrLocal;</div><div class="line">        </div><div class="line">        synchronized(this)&#123;</div><div class="line">            if(!hasChanged())</div><div class="line">                return;</div><div class="line">                </div><div class="line">            arrLocal = obs.toArray();</div><div class="line">            clearChanged();</div><div class="line">            </div><div class="line">            for(int i = arrLocal.length-1; i &gt;= 0;i --)&#123;</div><div class="line">                ((Observer)arrLocal[i]).update(this, arg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected synchronized void setChanged()&#123;</div><div class="line">        changed = true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected synchronized void clearChanged()&#123;</div><div class="line">        changed = false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized boolean hasChanged()&#123;</div><div class="line">        return changed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized int countObservers()&#123;</div><div class="line">        obs.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用了Vector来作为存储观察者的容器，是因为这个Observable类是线程安全的。<br>其它的我们可以对应起来的几个方法：<br>注册方法：addObserver(Observer o)<br>注销方法：deleteObserver(Observer o)<br>通知方法：notifyObservers()/notifyObservers(Object arg)</p>
<p>这里需要注意的是，我们的Observable是一个类，而不是接口，所以我们在使用它的时候，需要使用的是继承。而这个类中的一个更加重要的细节是，我们在通知之前，要先setChanged()来改变标记，如果没有在notify之前先setChanged，是不会进行通知的。<br>那么，为什么要这么麻烦呢？<br>其实这样做有一个好处，就是让通知更加弹性。例如我们在监听一个进度，而这个进度每前进0.01%都会对数据进行更新，但是我们的观察者并不需要这么精确的数据，所以通过setChanged()方法，可以在进度前进1%的时候才去通知观察者。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[长连接&短连接]]></title>
      <url>http://yoursite.com/2018/07/25/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="HTTP协议与TCP-IP协议的关系"><a href="#HTTP协议与TCP-IP协议的关系" class="headerlink" title="HTTP协议与TCP/IP协议的关系"></a>HTTP协议与TCP/IP协议的关系</h2><p>HTTP协议是应用层的协议，而TCP协议是传输层的协议，IP协议是网络层的协议。<br>IP协议主要解决网络路由以及寻址等问题，而TCP协议主要解决如何在IP层之上如何更加可靠地进行数据包的传递，即在接收端收到发送端发出的所有包，并且顺序与发出顺序一致。<br>所以说TCP是可靠的，面向连接的协议。</p>
<h2 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a>HTTP协议是无状态的</h2><p>无状态是指HTTP对事务的处理没有记忆能力，服务端并不知道客户端的状态（也就是说，你现在打开一个网页，和你之前打开同一个服务器的网页之间，并没有任何的关系）。<br><strong>HTTP是无状态的面向连接的协议。</strong>（无状态并不是说明HTTP协议无法保存TCP连接，也不能代表HTTP使用的是UDP连接–无连接）</p>
<h2 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h2><ul>
<li>HTTP/1.0默认使用短连接</li>
<li>HTTP/1/1默认使用长连接</li>
</ul>
<p>短连接：例如浏览器每一次和服务器进行一次HTTP操作，就会建立一次连接，当任务结束的时候，该连接就会断开。<br>长连接：保持连接特性。每当一个网页打开，客户端和服务端用于HTTP数据传输的TCP连接将不会被关闭，如果客户端再次访问这个服务端，将会继续使用该TCP连接。</p>
<p>使用长连接的HTTP协议，会在响应头加上这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connection:keep-alive</div></pre></td></tr></table></figure></p>
<p>Keep-Alive不会永远保持连接，它会有一个失效时间，可以在服务器上进行设置。<br>而实现长连接的客户端和服务端都要能够支持长连接。</p>
<p>HTTP的长连接和短连接的本质，其实就是TCP的长连接和短连接。</p>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>当网络使用TCP的方式来进行网络连接的时候，在读写之前需要server和client之间建立起一个连接，当读写操作完成后，再去释放这个连接。</p>
<h3 id="TCP的连接需要三次握手，而释放需要四次挥手。"><a href="#TCP的连接需要三次握手，而释放需要四次挥手。" class="headerlink" title="TCP的连接需要三次握手，而释放需要四次挥手。"></a>TCP的连接需要三次握手，而释放需要四次挥手。</h3><p><img src="/img/http/woshou.jpg" alt="拥有波浪形的进度"><br><img src="/img/http/huishou.jpg" alt="拥有波浪形的进度"><br>从上面的图可以看出，每一次连接都是很损耗资源和时间的。</p>
<h3 id="TCP的短连接"><a href="#TCP的短连接" class="headerlink" title="TCP的短连接"></a>TCP的短连接</h3><p>我们来模拟一下TCP的短连接。首先是Client向Server发送连接请求，Server接收到请求后建立连接，此时Client向Server发送消息，Server回应Client，这就是一个读写操作完成了，此时两端都可以发起close请求，而一般是Client发起，因为一般Server不会回应完Client后立马关闭连接。<br>这就是短连接，每次连接只能进行一次读写操作。</p>
<h3 id="TCP的长连接"><a href="#TCP的长连接" class="headerlink" title="TCP的长连接"></a>TCP的长连接</h3><p>同样来模拟长连接。首先一样的Client会向Server发起连接请求，Server接收到请求后建立连接。不一样的是，此时Client和Server进行一次读写操作后，两端都不会去主动发起close请求，即不会主动断开连接，这样后续的读写操作都会去使用到这个连接。</p>
<h2 id="长连接和短连接的优缺点"><a href="#长连接和短连接的优缺点" class="headerlink" title="长连接和短连接的优缺点"></a>长连接和短连接的优缺点</h2><p>长连接因为不用对此进行握手挥手等操作，所以可以省下很多的资源和时间。<br>但是，由于它的存活时间较长，如果遇到恶意破坏的连接时（在短时间内多个客户端发起连接请求，且这些连接都只是占用资源而已），那么这个服务器崩溃的概率就会增大。<br>这时的服务器应该采取一些措施来防止这样的情况发生，例如关闭一些长时间没有进行读写操作的连接，限制每一个客户端发起的连接数等。</p>
<p>短连接的优点显而易见，那就是易于管理，它所存在的连接都是有用的连接，不需要额外的控制手段。<br>但是其缺点也是很显然，当用户在频繁地发起请求的时候，将会在TCP的建立和关闭上浪费相当多的资源和时间。</p>
<h2 id="对长连接和短连接的选择"><a href="#对长连接和短连接的选择" class="headerlink" title="对长连接和短连接的选择"></a>对长连接和短连接的选择</h2><p>长连接一般用于在操作频繁，点对点的通讯，而且连接数不能太多。<br>例如数据库的连接就可以使用长连接。</p>
<p>而像Web上的网页之类的操作就使用短连接。它适用于连接频繁的操作。</p>
<p>此文章参考自“<a href="https://mp.weixin.qq.com/s/hxAE3vuOoGq_d8YfjJntQg" target="_blank" rel="external">浅谈HTTP长连接和短连接</a>”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[侃侃设计模式--策略模式]]></title>
      <url>http://yoursite.com/2018/07/19/%E4%BE%83%E4%BE%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java的三大特性，我们可能立马就想到 – 继承。<br>没错，继承，是我们日常代码中，最常用的，也是它带给了我们诸多的方便。继承所带来的好处，双手都数不下来。例如复用、传递性、容易扩展、易于维护等等，都不用我再多说了。</p>
<p>那么我们先来做一个相当简单而经典的事情 – Animal类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public abstract class Animal&#123;</div><div class="line">    public void eat()&#123;</div><div class="line">        System.out.println(&quot;kao kao kao...&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void speak()&#123;</div><div class="line">        System.out.println(&quot;wan wan wan...&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public abstract void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的这个动物类中，我们实现了两个行为，就是吃和叫，我们姑且认为所有的动物都会吃，都会叫。而每个动物长得都不一样，所以我们使用抽象方法来让子类自己去定义。<br>是的，一切都在掌握之中，我们来生产一只鸭子和一只狗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Duck extends Animal&#123;</div><div class="line">    public void display()&#123;</div><div class="line">        System.out.println(&quot;扁嘴&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Dog extends Animal&#123;</div><div class="line">    public void display()&#123;</div><div class="line">        System.out.println(&quot;黑毛摇尾&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Ok，我们认为万事大吉，只差生产线的工人放流水线上走个流程了。</p>
<p>第二天，产品出来了，我们发现，完了。为什么我们的鸭子的叫声是“wan wan wan…”。<br>“某某人，来我办公室。”</p>
<p>幸好，这次是试产而已，还能改，赔点小钱，还不至于被炒了鱿鱼。<br>那么我们要怎么修改呢？<br>有两个办法：</p>
<ul>
<li>重写方法</li>
<li>利用多态</li>
</ul>
<p>这两个方法都可以，那么我们该如何选择呢？<br>首先，重写方法是在定义的时候就将行为给固定住的，例如我们上面的鸭子例子中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void speak()&#123;</div><div class="line">    System.out.println(&quot;a a a...&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们直接复写这个speak()方法，就可以修改鸭子的叫声了。但是它有一个缺点，就是当你不想让它发出“a a a…”的声音，而是发出“ya ya ya…”时，你又得去修改这个Duck类，这就破坏了类的封装性。<br>那么，我们使用多态不是更好，直接修改父类Animal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void speak(String sound)&#123;</div><div class="line">    System.out.println(sound);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，我们在生产Duck或Dog的时候，只要去调用这个方法即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duck duck = new Duck();</div><div class="line">duck.speak(&quot;ka ka ka...&quot;);</div></pre></td></tr></table></figure></p>
<p>但是，问题又来了，如果我们已经设计好了很多动物了，而且这些动物我们都已经固定好它们的叫声了。那我们修改了它们的父类中的方法，就得一个一个去修改之类中的方法。我的天，这是在给自己添加工作量吗？<br>当然，这就是得你自己去权衡了，用哪种方法其实都是有利有弊，主要看你的实际情况，例如，在修改次数少行为比较稳定时选择复写更佳，而当某个行为的定制型比较强，或者需要调用者去决定时，使用多态更为合适。</p>
<h2 id="功能性添加"><a href="#功能性添加" class="headerlink" title="功能性添加"></a>功能性添加</h2><p>“不错，知错能改，善莫大焉。上次会议总结一下，这鸭子和狗子卖得还不错，客户还要做天鹅和鸟，要会飞的。你今晚赶紧做出来。”</p>
<p>天鹅和鸟，都会飞，那我就在父类里面加个fly()方法呗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class Animal&#123;</div><div class="line">    ...</div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;I can fly.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再定义一下天鹅和鸟的类：Swan、Bird<br>ok，收工，那里需要晚上加班搞呀。</p>
<p>回家路上，“等一下，鸭子和狗子不会飞呀，哎呀，赶紧回去改改。”</p>
<p>是的，鸭子和狗子不会飞。<br>那怎么办，很容易呀，上面都说了，直接重写Duck和Dog类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void fly()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行，给个空实现，那么就不会飞了。</p>
<p>第二天，领导又来话了，“早上客户又来电话了，要再生产走地鸡和猴子，注意哈，它们是不会飞的。”<br>额。。。那不是又得去复写几个空方法，好麻烦啊。</p>
<p>所以说，上面的做法是不对的，而且是比较荒谬的。为什么这么说呢，原因就在于你以为把fly()作为一个共有的方法放到父类中去，却只为了服务一部分的子类。那么继承的用法就是荒谬的，我们<strong>不能为了复用的目的来使用继承</strong>。</p>
<p>那么，我们应该怎么来做呢？</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>这也是比较容易想到的方法，就是使用接口来代表某一种行为，一个接口代表一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Flyable&#123;</div><div class="line">    void fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我们的天鹅：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Swan extends Animal implements Flyable&#123;</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;我的大翅膀可以飞.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而鸟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Bird extends Animal implements Flyable&#123;</div><div class="line">    public void display()&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;我的小翅膀也可以飞.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Ok，来到这里，我们这个接口类还是相当完美的。<br>但是，万恶的客户需求又来了，他们觉得天鹅“我的大翅膀可以飞.”不行，要改成“我只能低空飞行”，好，那就改一下Swan类呗。第二天，不行，“我只能低空飞行”也不行，要改为“高空我也可以”，好，我再改。第三天，算了算了，还是改回原来“我的大翅膀可以飞.”那样吧。<br>我的**<br>是的，客户需求能逼疯你，不用怀疑。</p>
<p>面对多变的客户，我们当然要想出对策来应付他了。<br>可能你会说，那就使用多态呀，多简单。<br>是的，我们就是要来使用多态。但是，这个多态的超类，我们需要来设计。<br>例如飞行的行为，既然我们不知道以后客户还要怎么来修改这个fly行为，那我们就将它抽象，等客户要生产的时候再来选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Flyable&#123;</div><div class="line">    void fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们不再让我们的实体类Swan来实现这个接口了，而是让Swan来使用这个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Swan extends Animal&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    public void toFly(Flyable flyBehavior)&#123;</div><div class="line">        flyBehavior.fly();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，我们在定义Swan的时候，并没有去真正实现飞行的逻辑，而是将逻辑委托给Flyable这个接口去实现。<br>那么我们在调用的时候，就要先去实现这个接口了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Flyable flyBehavior = new Flyable()&#123;</div><div class="line">    @Override</div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;我的大翅膀可以飞.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">mSwan.toFly(flyBehavior);</div></pre></td></tr></table></figure></p>
<p>聪明的你肯定看出这段代码的问题所在，对的，这样跟没改有什么区别，客户来需求了，你不还是得来改把上面的代码擦掉再写一遍。<br>但是，我们这么写接口肯定是有好处的，客户要我们修改，好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class BigWingsFlyBehavior implements Flyable&#123;</div><div class="line">    @Override</div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;我的大翅膀可以飞.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LowFlyBehavior implements Flyable&#123;</div><div class="line">    @Override</div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;我只能低空飞行.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HighFlyBehavior implements Flyable&#123;</div><div class="line">    @Override</div><div class="line">    public void fly()&#123;</div><div class="line">        System.out.println(&quot;高空我也可以.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，客户要我们修改，那就改呗：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Swan swan = new Swan();</div><div class="line">swan.toFly(new BigWingsFlyBehavior());</div><div class="line">//swan.toFly(new LowFlyBehavior());</div><div class="line">//swan.toFly(new HighFlyBehavior());</div></pre></td></tr></table></figure></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>对的，最后的我们终于使用了策略模式来完美解决了这个烦人的问题。</p>
<blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换（实现同个接口）。而此模式让算法的变化独立于使用算法的用户。</p>
</blockquote>
<p>也就是说，当我们知道需要某个行为，却不知道最后该行为是怎样的时候，我们应该将该行为抽取成一个接口，而在设计行为逻辑的时候，为每一种行为创建一个实现接口的类，这样，最后不管要使用什么样的行为，我们都只需要去实例化该行为类即可。<br>而且，最后尽管我们调用了该行为类，却不需要去了解这个行为的逻辑到底是怎么实现的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp源码解析-OkHttpClient]]></title>
      <url>http://yoursite.com/2018/07/19/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-OkHttpClient/</url>
      <content type="html"><![CDATA[<hr>
<p>现在OkHttp的源码已经贴到只剩下最后一部分了，那就是OkHttpClient。</p>
<h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>可能我们会觉得OkHttp的核心，应该就是OkHttpClient了吧。因为好像我们在进行网络连接的时候，是使用OkHttpClient来联系Rquest和Response的。那么，是不是呢，我们可以去看一下OkHttpClient的源码。<br>（代码我就不贴了，原因你们看下面的分析就好了）<br>OkHttpClient也是构造者模式来设计的，我们在看其Builder内部类的时候，发现它的设置方法，其实也是比较简单的赋值动作而已，基本上没有什么对参数进行二次加工。<br>其中可以值得注意的就是newCall()方法，而这个方法会去创建一个RealCall对象。对了，这就是我们在使用的时候，一般要写到的方法。这里我们可以看出，其实OkHttpClient就是一个设置参数的地方，而请求，获取响应等工作，会委托给RealCall对象去处理。<br>（这里RealCall的内容，可以看看我们前面侃的那篇“<a href="https://zouxiaobang.github.io/2018/07/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Call/" target="_blank" rel="external">OkHttp源码解析–Call</a>”）</p>
<p>那么这篇总不能就写这么点就结束了吧，当然，我们还需要对整个OkHttp进行总结，不然看了这么多代码，也是云里雾里的，看完连个流程都不知道。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说网络请求的原理流程基本都一样，就是发送请求，和接收响应。但网络请求在执行中的处理事务还是比较难的，来源于网络层错综复杂的情况。例如我们需要考虑到的功能性和性能，功能上我们需要Socket连接，需要各种文件的传输（流、byte数组等），需要安全（TLS安全–握手协议）等等；性能上我们需要缓存（复用、可用时间），需要一个池结构来管理众多的请求连接。<br>我们想想都觉得复杂，一个个问题堆积在一起，可能我们要做一个完全兼顾的框架出来，也是很难进行维护和管理的。而OkHttp，正好做到了这一点，这就是为什么我们这么推崇他的原因。</p>
<blockquote>
<p>OkHttp通过分层的思想，将功能设计为多个拦截器，而将多个拦截器通过链式的形式串联在一次，从而一层一层地解决每一个问题。而这个模式也符合了单一职责原则。</p>
</blockquote>
<p>而在拓展性上，OkHttp同样支持我们去做自己的拦截器，来对请求做进一步的处理或拦截。<br>（例如我常用的，在本App上直接拦截请求返回一个测试数据）</p>
<p>我们对几个重要的类进行解读：<br>首先是Rquest和Response类，这两个类中其实并没有什么进行网络行为的逻辑，我们更多的是把它们看做是一个数据类，用于存储请求和响应中的数据。<br>而OkHttpClient更像一个参数类，主要用于设置一些参数，例如要不要缓存等。它也没有进行网络行为，而是将这些行为委托给Call对象去处理。<br>所以说，Call对象属于行为类，但值得注意的是，Call类中，也只是对请求进行封装，对响应进传递（使用Callback来传递异步请求返回的Response，而同步的就直接返回Response对象）。当然，它是提供进行网络请求的逻辑的（AsyncCall类，继承自NamedRunnable），但在RealCall的enqueue()方法和execute()方法中，并没有直接去调用它，而是在enqueue()方法和execute()方法中去调用Dispatcher的异步或同步方法。<br>那么问题来了，为什么不直接调用呢，而要多此一步呢？<br>我们去看看Dispatcher的代码就知道了，例如异步处理，Dispatcher中会将所有的Call对象保存起来，然后将它们放到线程池中去执行。这就是性能和管理方面上的优点了。</p>
<h2 id="一个相当粗略的流程图"><a href="#一个相当粗略的流程图" class="headerlink" title="一个相当粗略的流程图"></a>一个相当粗略的流程图</h2><p><img src="/img/okhttp/OkHttp.jpg" alt="OkHttp流程图"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp源码解析--Response]]></title>
      <url>http://yoursite.com/2018/07/16/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Response/</url>
      <content type="html"><![CDATA[<hr>
<p>接下来我们来解释Response类，这是OkHttp网络架构中的响应类，是我们在发送请求后得到回馈的载体。</p>
<p>首先，我们来看看Response中的内容</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><strong>属性变量：</strong></p>
<ul>
<li>int code：响应码，对应网络的每一种状态，都会对应这一个响应码，我们可以通过响应码去查询响应出现的问题等。</li>
<li>String message：对响应状态的描述，例如响应成功了，message会返回ok</li>
<li>ResponseBody body：响应体，我们响应的内容会包含在响应体中返回回来给我们。</li>
</ul>
<p>以上是我们在写例子的时候最常使用到的属性，而还有一些属性：</p>
<ul>
<li>Request</li>
<li>Protocol</li>
<li>Header<br>这几个我们在需要的时候可以去获取它们，当然在平常的使用中我们还是很少去用它们的。<br>由于Response也是使用Builder模式，所以我们获取以上属性的时候当然是使用Response对象咯：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = mResponse.request();</div><div class="line">int code = mResponse.code();</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个就不多说了，这是构造者模式的特点。</p>
<p><strong>方法：</strong><br>我们来看一下常用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isSuccessful() &#123;</div><div class="line">    return code &gt;= 200 &amp;&amp; code &lt; 300;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断网络请求是否已经成功响应。我们都知道，网络设定返回码为200~300之间，是成功的标记，所以这里直接使用请求码来判断。这个方法相当重要也相当常见，我们在要发送请求后想对响应进行处理的时候，都要先对这个Response对象是否响应成功进行判断，不然可能会引起各种类似空的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public @Nullable ResponseBody body() &#123;</div><div class="line">    return body;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法我们也常用，我们这里把它放出来是为了强调它相当常用，而它的逻辑，就不说了。</p>
<p>Response类相对来说比较简单，因为它没有像Request一样会去对很多东西做处理，而是比较纯粹地对数据进行设置和读取。</p>
<p>接下来我们来看看跟Response关系密切的ResponseBody类</p>
<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="ResponseBody"></a>ResponseBody</h2><p>ResponseBody承载着网络给我们响应的内容，例如返回的是一段JSON数据，或是一个网页html等等。</p>
<p>ResponseBody是一个抽象类，所以我们也是没法去实例化它，但它给我们提供了create()方法来创建这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static ResponseBody create(final @Nullable MediaType contentType,</div><div class="line">      final long contentLength, final BufferedSource content) &#123;</div><div class="line">    if (content == null) throw new NullPointerException(&quot;source == null&quot;);</div><div class="line">    return new ResponseBody() &#123;</div><div class="line">      @Override public @Nullable MediaType contentType() &#123;</div><div class="line">        return contentType;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public long contentLength() &#123;</div><div class="line">        return contentLength;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public BufferedSource source() &#123;</div><div class="line">        return content;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们会创建一个匿名的ResponseBody对象并返回，在这个对象中，我们要注意的是它的source()方法，它返回的是一个BufferedSource对象，而这个对象，其实就是网络在响应的时候将内容转换为BufferedSource类型的。（例如String转化为BufferedSource）</p>
<p>为什么要注意这个方法呢，因为我们在经常使用到的response.body().string()方法中会使用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final String string() throws IOException &#123;</div><div class="line">    BufferedSource source = source();</div><div class="line">    try &#123;</div><div class="line">      Charset charset = Util.bomAwareCharset(source, charset());</div><div class="line">      return source.readString(charset);</div><div class="line">    &#125; finally &#123;</div><div class="line">      Util.closeQuietly(source);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里又会将source转化为String类型返回回去。而我们看到的，一般都是这个String类型。<br>不要觉得很绕，为什么要把String转化为BufferedSource，最后又变回来呢。我们想想这些情况，如果响应是一个图片呢，是一个用String没法描述的呢，当然它会提供这个方法给你。我们都知道，在网络传输中，使用的是流形式，而不管怎样的流，肯定都能转化为byte[]类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final byte[] bytes() throws IOException &#123;</div><div class="line">    long contentLength = contentLength();</div><div class="line">    if (contentLength &gt; Integer.MAX_VALUE) &#123;</div><div class="line">      throw new IOException(&quot;Cannot buffer entire body for content length: &quot; + contentLength);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BufferedSource source = source();</div><div class="line">    byte[] bytes;</div><div class="line">    try &#123;</div><div class="line">      bytes = source.readByteArray();</div><div class="line">    &#125; finally &#123;</div><div class="line">      Util.closeQuietly(source);</div><div class="line">    &#125;</div><div class="line">    if (contentLength != -1 &amp;&amp; contentLength != bytes.length) &#123;</div><div class="line">      throw new IOException(&quot;Content-Length (&quot;</div><div class="line">          + contentLength</div><div class="line">          + &quot;) and stream length (&quot;</div><div class="line">          + bytes.length</div><div class="line">          + &quot;) disagree&quot;);</div><div class="line">    &#125;</div><div class="line">    return bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后我们想要怎么转化成其他的类型，就都可以转化了。</p>
<p>当然，除了byte数组，还有流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final InputStream byteStream() &#123;</div><div class="line">    return source().inputStream();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp源码解析--Call]]></title>
      <url>http://yoursite.com/2018/07/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Call/</url>
      <content type="html"><![CDATA[<hr>
<p>接下来，我们来学习Call。<br>你可能会很困惑Call的作用。而Call也是OkHttp中的一个亮点，或者说是重中之重。</p>
<p>你或许会遇到这些问题，你发送了一个请求，但在某个时刻，你不想发送这个请求了，你先停止掉。<br>你想使用异步的方法来请求网络，而不是每次都要去创建一个新的线程和Handler来处理问题。<br>你想知道目前这个请求是否已经执行了，获取已经取消了。</p>
<h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>是的，Call正是为了解决这些问题。Call提供了一系列的方法来给你方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Call extends Cloneable &#123;</div><div class="line">    Request request();</div><div class="line">    Response execute() throws IOException;</div><div class="line">    void enqueue(Callback responseCallback);</div><div class="line">    void cancel();</div><div class="line">    boolean isExecuted();</div><div class="line">    boolean isCanceled();</div><div class="line">    Call clone();</div><div class="line">    </div><div class="line">    interface Factory &#123;</div><div class="line">        Call newCall(Request request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们应该可以看到的是Call是一个接口，所以肯定有一个实体类实现了它，而它是继承自Cloneable的，说明它是可用于克隆模式，且应该是有着克隆模式的作用的（谁吃饱没事干随便写一个没用的东西呢）。<br>OK，这两个问题我们接下去再继续看，先说说其中的 方法：</p>
<ul>
<li>request()：获取Call所代表的请求Request</li>
<li>execute()：同步执行请求</li>
<li>enqueue()：异步执行请求</li>
<li>cancel()：取消请求</li>
<li>isExecuted()：请求是否已经执行</li>
<li>isCanceled()：请求是否已经取消</li>
<li>clone()：获得Call对象的克隆对象</li>
</ul>
<p>那么它们又是怎么来实现的呢，逻辑代码是什么？</p>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>RealCall是Call的实现类，是OkHttp真正用于实现Call中各种功能的类。</p>
<h3 id="RealCall的构造方法"><a href="#RealCall的构造方法" class="headerlink" title="RealCall的构造方法"></a>RealCall的构造方法</h3><p>我们先看RealCall的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的构造方法使用的是private来修饰的，那么你可能会觉得，难道RealCall对象也需要是单一的吗？不应该一个请求对应一个Call对象吗？那一个项目是不是不能有多个请求了？<br>那只能说你想多了，我们接下去看就知道了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</div><div class="line">    RealCall call = new RealCall(client, originalRequest, forWebSocket);</div><div class="line">    call.eventListener = client.eventListenerFactory().create(call);</div><div class="line">    return call;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到了没，这个方法才是创建RealCall对象的真正实现方法。在这个方法中，每次调用都会去创建一个新的RealCall对象，所以并不是使用了单例模式。那么你思考的问题就不存在了。</p>
<p>那么我们会想，这个RealCall，好像我们在使用的时候并没有去创建它，而是通过HttpClient的newCall()方法来返回的。<br>是的，在RealCall类中，这个newRealCall()方法也是包修饰符，而恰好，HttpClient和RealCall在同一个包中，而我们在使用它的时候，用户的类和RealCall可不在同一个包中，所以，newRealCall()并不是设计来给你用的。<br>那么HttpClient怎么来返回一个RealCall对象，我们留到HttpClient的时候再说，我们先来看看上面说的那几个方法的逻辑是什么样的。</p>
<h3 id="RealCall中的方法"><a href="#RealCall中的方法" class="headerlink" title="RealCall中的方法"></a>RealCall中的方法</h3><p><strong>request()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public Request request() &#123;</div><div class="line">    return originalRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法返回的是一个Request对象，这个对象在构造方法的时候传入（也就是我们在使用的时候mClient.newCall(request)中的request对象）。</p>
<p><strong>execute()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override public Response execute() throws IOException &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    eventListener.callStart(this);</div><div class="line">    try &#123;</div><div class="line">      client.dispatcher().executed(this);</div><div class="line">      Response result = getResponseWithInterceptorChain();</div><div class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</div><div class="line">      return result;</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">      eventListener.callFailed(this, e);</div><div class="line">      throw e;</div><div class="line">    &#125; finally &#123;</div><div class="line">      client.dispatcher().finished(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，会去判断请求是否已经执行了，如果是会抛出状态异常。接下去会去调用HttpClient的分发器去执行这个Call对象，然后在这个Call走完所有的拦截器（拦截器形成一个链式结构）后，返回的结果作为响应返回回去。<br>我们来看看怎么在拦截器中获取响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</div><div class="line">    // Build a full stack of interceptors.</div><div class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</div><div class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</div><div class="line">    interceptors.add(new ConnectInterceptor(client));</div><div class="line">    if (!forWebSocket) &#123;</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</div><div class="line">        originalRequest, this, eventListener, client.connectTimeoutMillis(),</div><div class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line"></div><div class="line">    return chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这个方法里会把一堆拦截器加入到一个链（Chain）中，然后去调用chain.proceed()去一个个处理拦截器。（以下只介绍拦截器的作用，对代码感兴趣的同学可以去看看源代码）<br>我们先来看看这些拦截器的作用，首先是加入client.interceptors()，当然，这个方法就是获取所有我们自定义的拦截器了。<br>接下去是RetryAndFollowUpInterceptor，这个拦截器的作用是网络的重定向和出错重连。我们可以去看看它的intercept()方法，在该方法中会看到，在catch错误的时候使用continue来不断循环进行重连。而且如果支持重定向的话，会将响应对象response和路由对象route重新构造出一个Request请求，接着重新进行请求。<br>第三个是BridgeInterceptor，这里拦截器的作用就是修修补补，为Request的头补充一下ContentTyep啊，Host等等这些属性，而对于Response则对响应体进行解压（如果Content是压缩的话），并且移除掉响应头中的某些属性并返回回去。<br>第四个是OkHttp的一个亮点，是缓存拦截器，这里的逻辑也相对简单，就是判断请求在缓存中是否已经有响应存在，而且该响应还没有过去的话，那就直接返回响应，而如果没有或过期的话，就请求网络，并缓存起来。当然，如果你想使用缓存，是需要在HttpClient中设置的。<br>第五个是ConnectInterceptor，里面通过StreamAllocation来分配请求，也就是通过StreamAllocation的连接对象RealConnection来写入请求，并返回响应。<br>第六个是真正的网络请求的拦截器，CallServerInterceptor，它会将请求头和请求体都发送给服务器，然后调用httpCodec.finishRequest()来结束请求，最后从服务器中获取响应并返回。</p>
<p><strong>enqueue()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(Callback responseCallback) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    captureCallStackTrace();</div><div class="line">    eventListener.callStart(this);</div><div class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里呢，最主要的还是会去调用dispatcher的enqueue方法，我们可以进去看看这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">synchronized void enqueue(AsyncCall call) &#123;</div><div class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125; else &#123;</div><div class="line">      readyAsyncCalls.add(call);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将Call添加到正在执行的异步Call集合中，然后开始执行，这样，在执行的过程中，会将响应返回到Call中去。而这个Call，其实是一个Callback，也就是我们在执行异步任务的时候传入的一个Callback参数，用于获取响应内容。</p>
<p><strong>cancel()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public void cancel() &#123;</div><div class="line">    retryAndFollowUpInterceptor.cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们取消一个请求时，其实是在RetryAndFollowUpInterceptor拦截器中去取消。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void cancel() &#123;</div><div class="line">    canceled = true;</div><div class="line">    StreamAllocation streamAllocation = this.streamAllocation;</div><div class="line">    if (streamAllocation != null) streamAllocation.cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里又看到StreamAllocation这个对象了，没错，它就是我们在做真正的网络请求的时候需要的流分配对象，我们在该对象分配的时候取消掉分配。</p>
<p>Ok，我们对Call和RealCall的理解其实到了这里就可以了，下一篇我们会来看看响应Response是如何来实现的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp源码解析 -- RequestBody请求体]]></title>
      <url>http://yoursite.com/2018/07/14/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-RequestBody%E8%AF%B7%E6%B1%82%E4%BD%93/</url>
      <content type="html"><![CDATA[<hr>
<p>在上一节中我们聊到，在Request请求类使用POST方式发送请求时，会带一个RequestBody的参数，我们称之为请求体。<br>在OkHttp的请求方式中，除了POST外，PUT、DELETE、PATCH这些方式都需要传入请求体。那么我们就来了解一下请求RequestBody。</p>
<h2 id="RequestBody请求体"><a href="#RequestBody请求体" class="headerlink" title="RequestBody请求体"></a>RequestBody请求体</h2><p>请求体是为我们的请求添加上参数来进行传输的。所以我们应该知道，在RequestBody中，最为重要也最有用的方法，肯定就是传入参数的方法了。</p>
<p>首先我们来看看这个RequestBody类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract class RequestBody &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个抽象类，所以我们可以先看看里面的抽象方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract @Nullable MediaType contentType();</div><div class="line">public abstract void writeTo(BufferedSink sink)</div><div class="line">                            throws IOException;</div></pre></td></tr></table></figure></p>
<p>第一个方法，我们看名字就知道了，这是设置内容的类型。在网络请求中，我们要上传的参数的类型，是收到严格要求的，例如你想上传一个png图片，那么你要告诉网络，你要上传的参数的类型是png，具体的Content-Type就是为：image/png。<br>那么你可能会问，那么多的类型，我怎么记得住？<br>问得好，我也记不住，但百度总记得住吧。没办法的，这种写法就是这么麻烦，这里我推荐一个网站，<a href="http://tool.oschina.net/commons" target="_blank" rel="external">os中国的工具网站</a>，但忘记Content-Type是什么的时候可以去找找。</p>
<p>我们先来看一下平常我们最常用的POST使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private MediaType contentType </div><div class="line">    = MediaType.parse(&quot;text/x-markdown;charset=utf-8&quot;);</div><div class="line"></div><div class="line">RequestBody body</div><div class="line">    = RequestBody.create(contentType, &quot;string&quot;);</div><div class="line">Request request = new Request.Builder()</div><div class="line">                .url(&quot;...&quot;)</div><div class="line">                .post(body)</div><div class="line">                .build();</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>我们会惊奇的发现，RequestBody不是说是抽象类吗，为什么我们能够实例化它？</p>
<p>那么，我们到底有没有实例化它呢？我们来看一下create()方法的代码。</p>
<h3 id="创建RequestBody-–-create"><a href="#创建RequestBody-–-create" class="headerlink" title="创建RequestBody – create()"></a>创建RequestBody – create()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static RequestBody create(@Nullable MediaType contentType, String content) &#123;</div><div class="line">    Charset charset = Util.UTF_8;</div><div class="line">    if (contentType != null) &#123;</div><div class="line">      charset = contentType.charset();</div><div class="line">      if (charset == null) &#123;</div><div class="line">        charset = Util.UTF_8;</div><div class="line">        contentType</div><div class="line">            = MediaType.parse(contentType +</div><div class="line">                        &quot;; charset=utf-8&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    byte[] bytes = content.getBytes(charset);</div><div class="line">    return create(contentType, bytes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>create()方法有很多重载方法，用于传入不同的参数。我们先来看看最简单的参数String所在的方法。<br>第一个参数是MediaType类型，这是用于设定参数类型的类，就是我们在使用的时候，会按照它的规则去设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private MediaType contentType </div><div class="line">    = MediaType.parse(&quot;text/x-markdown;charset=utf-8&quot;);</div></pre></td></tr></table></figure></p>
<p>这里说明传入类型是markdown文件类型，使用的编码是utf-8.<br>我们返回create()这个方法，它会去判断我们的MediaType是否有设置编码形式，如果没有，会默认给我们设置为utf-8，然后再调用create()的重载方法来完成RequestBody的构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,</div><div class="line">      final int offset, final int byteCount) &#123;</div><div class="line">    if (content == null) throw new NullPointerException(&quot;content == null&quot;);</div><div class="line">    Util.checkOffsetAndCount(content.length, offset, byteCount);</div><div class="line">    return new RequestBody() &#123;</div><div class="line">      @Override public @Nullable MediaType contentType() &#123;</div><div class="line">        return contentType;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public long contentLength() &#123;</div><div class="line">        return byteCount;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">        sink.write(content, offset, byteCount);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几个参数要说一个：</p>
<ol>
<li>byte[] content：这个就是我们要上传的内容，将其转换为byte[]对象</li>
<li>int offset：标记你上传内容是从哪里开始的</li>
<li>int byteCount：你要上传多少内容<br>在writeTo()方法中，将byte[]直接写入到ButteredSink，也就是将byte数组写入到流中（我们应该都知道，网络的传输是靠流来当载体的）。这里的ButteredSink是Okio的一个类，我们不做解释啦，只要知道它是一个便捷到不行的，由squareup重构的IO流就可以了。</li>
</ol>
<p>这里直接在return中new一个对象出来，这里我们就明白了，在return中，它是返回了匿名类，而这个匿名类是RequestBody类型的。<br>所以，并不是直接实例化出来一个RequestBody，这时我们的疑惑也就解除了。</p>
<p>刚刚说了create()有很多重载方法，当然，如果你传入的是一个byte[]数组，那么更简单了，连String转换为byte[]的过程都省了。那要是传入的是File对象呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static RequestBody create(final @Nullable MediaType contentType, final File file) &#123;</div><div class="line">    if (file == null) throw new NullPointerException(&quot;content == null&quot;);</div><div class="line"></div><div class="line">    return new RequestBody() &#123;</div><div class="line">      @Override public @Nullable MediaType contentType() &#123;</div><div class="line">        return contentType;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public long contentLength() &#123;</div><div class="line">        return file.length();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">        Source source = null;</div><div class="line">        try &#123;</div><div class="line">          source = Okio.source(file);</div><div class="line">          sink.writeAll(source);</div><div class="line">        &#125; finally &#123;</div><div class="line">          Util.closeQuietly(source);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它会使用squareup的另一个OK系列Okio来操作，将File进行转换，成为一个ButteredSink流能接受的Source对象，这里面的转换我们就不再多做解释了，有兴趣的同学可以看看Okio框架的源码。</p>
<p>那RequestBody是不是就完了呢，当然没有，如果只是这样的话，那么我们就要怀疑，这里将RequestBody设置为抽象类有没有必要了。</p>
<h2 id="FormBody表形式的请求体"><a href="#FormBody表形式的请求体" class="headerlink" title="FormBody表形式的请求体"></a>FormBody表形式的请求体</h2><p>我们想一下，在使用POST发送请求的时候，是不是最常发送String这些呢？当然不是，我们都听说过，在登陆注册等功能上，我们发送的一般都是表。<br>是的，能用表来发送的，当然要用表了，因为表是最直观的，我们要在编代码的时候要考虑代码的性能，而在用户的角度，当然也要让用户舒服一点。<br>表的形式就是key-value的形式存在的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name=xb.zou&quot;</div><div class="line">    &quot;sex=boy&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是很像JSON，是的，我也觉得，虽然不尽相同。但我们可以很直观地看出name和sex是什么。</p>
<p>OK，我们来看FormBody的代码，我们可以看到其中又有一个Builder，这我就不再多说了。设置方法。对，都是设置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private final List&lt;String&gt; names = new ArrayList&lt;&gt;();</div><div class="line">private final List&lt;String&gt; values = new ArrayList&lt;&gt;();</div><div class="line">    </div><div class="line">public Builder add(String name, String value) &#123;</div><div class="line">      if (name == null) throw new NullPointerException(&quot;name == null&quot;);</div><div class="line">      if (value == null) throw new NullPointerException(&quot;value == null&quot;);</div><div class="line"></div><div class="line">      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));</div><div class="line">      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));</div><div class="line">      return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Builder addEncoded(String name, String value) &#123;</div><div class="line">      if (name == null) throw new NullPointerException(&quot;name == null&quot;);</div><div class="line">      if (value == null) throw new NullPointerException(&quot;value == null&quot;);</div><div class="line"></div><div class="line">      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));</div><div class="line">      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));</div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有两个方法来设置参数，一个是add，一个是addEncode，从名字上来说，就是一个是没有进行编码的，一个是有的。<br>你可能看到一堆true啊false的有点晕，那我先介绍一下这些boolean值是干嘛的：<br>（从canonicalize方法的第三个参数开始）<br>第3个–alreadyEncode：是否已经准备好要编码<br>第4个–strict：如果编码时这个%不是一个有效的前缀，那是否需要去编入一个有效的%<br>第5个–plusIsSpace：如果+这个符号没有编码，那么是否要使用%2B来编码<br>第6个–asciiOnly：是否要编码所有的非ASCII的码点，true为要。<br>这里我们只要关注第3个（alreadyEncode）就够了，如果设置为true，在HttpUrl类中，会将你传入的数据根据charset编码格式转换，例如你要将一个中文使用utf-8来编码，就变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">汉良 --&gt; &amp;#x6C49;&amp;#x826F;</div></pre></td></tr></table></figure></p>
<p>这就是没编码和编码的差别。</p>
<p>当然，有编码，就有解码。<br>我们来看看获取方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public String encodedName(int index) &#123;</div><div class="line">    return encodedNames.get(index);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public String name(int index) &#123;</div><div class="line">    return percentDecode(encodedName(index), true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在获取参数的时候一般会使用name()和value()方法，很少去用encodedName()或encodedValue()方法。<br>从上面的方法逻辑看，如果你设置参数的时候对参数进行编码了，那么你用encodedX()方法获取到的是一个你也看不到的参数（如&amp; #x6C49; &amp; #x826F;这种格式）。何必呢，所以是用X()更为直观。<br>而percentDecode()是HttpUrl中的方法，用于对参数进行解码。当然，你可能会觉得这么这个方法前面没有对象可以引用，这是因为这个方法是一个静态方法，可以使用import来导入：import static okhttp3.HttpUrl.percentDecode;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp源码解析 -- Request]]></title>
      <url>http://yoursite.com/2018/07/13/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Request/</url>
      <content type="html"><![CDATA[<hr>
<p>今天，我来侃这个已经被很多大牛讲解到看你问起就会翻白眼的框架 – OkHttp。<br>作为一个菜鸟，我完完整整地看了一遍OkHttp的源码，在一边感叹一边佩服一边认识到自己后面的路还漫漫。</p>
<p>好啦，废话不多说了。首先，我这篇博文是从头特别详细地来表述我对OkHttp的理解，如有不当之处，欢迎留言。谢谢。</p>
<p>我是网络专业出身的，那么对于一个Http应该有哪些部分组成，Http协议等，我就不多说了，这个百度就可以。<br>我们先从Http的请求开始，慢慢深入。</p>
<h2 id="Request请求类"><a href="#Request请求类" class="headerlink" title="Request请求类"></a><strong>Request请求类</strong></h2><p>Request使用了Android式的建造者模式–Request.Builder来构建请求对象Request。<br>我们先看看一般的请求对象是如何创建的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">            .url(<span class="string">"..."</span>)</div><div class="line">            .build();</div></pre></td></tr></table></figure></p>
<p>根据Builder的逻辑，我们先来看看Builder的外部类Request中的变量和方法。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>首先来看看变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> HttpUrl url;</div><div class="line"><span class="keyword">final</span> String method;</div><div class="line"><span class="keyword">final</span> Header headers;</div><div class="line"><span class="keyword">final</span> RequestBody body;</div><div class="line"><span class="keyword">final</span> Object tag;</div></pre></td></tr></table></figure></p>
<p>以上就是Request中必须要的4个属性和1个tag标记。<br>（以上变量的类型下面会继续见解：HttpUrl、Header、RequestBody）</p>
<p>我们可以看到这些其实都是常量，常量是需要先初始化的，但常量还能另外一种初始化，就是在构造器中为它们赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Request(Builder builder)&#123;</div><div class="line">    <span class="keyword">this</span>.url = builder.url;</div><div class="line">    <span class="keyword">this</span>.method = builder.method;</div><div class="line">    <span class="keyword">this</span>.headers = builder.headers;</div><div class="line">    <span class="keyword">this</span>.body = builder.body;</div><div class="line">    <span class="keyword">this</span>.tag = builder.tag != <span class="keyword">null</span> ? builder.tag:<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看出，这里使用Builder来作为参数，说明了Request中的属性是由其内部类Builder来赋予的。<br>而tag如果在Builder中没有进行赋值的话，那就指向自身，也就是说，这个tag是用于标记请求对象的，那么tag的作用就是用于在多个请求对象时识别某一个特定的Request。</p>
<p>接下来就是一系列的获取方法：<br>url()、method()、headers()、body()、tag()<br>我们可能会有所疑惑，为什么Builder中有这一模一样的方法，这里还会有呢？<br>但是我们看清楚了，Request中的方法，是获取方法，而Builder中的方法，是赋值方法，是带参数的。<br>在获取方法中，其逻辑是比较简单的，例如url():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> HttpUrl <span class="title">url</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，获取方法中也有几个方法是要注意的，先说说tag()的重载方法，而我们一般较多使用到的也是它的重载方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> &lt;T&gt; <span class="function">T <span class="title">tag</span><span class="params">(Class&lt;? extends T&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> type.cast(tags.get(type));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法通过类对象，我们可以找到设置的那个标记tag。</p>
<p>接下来看看重要的header(String)和headers()的重载方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public @Nullable String header(String name) &#123;</div><div class="line">    return headers.get(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法返回的是某个header值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public List&lt;String&gt; headers(String name) &#123;</div><div class="line">    return headers.values(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而这个方法返回的是一个key对应的某一系列值。</p>
<p>而Request还给我们提供了一个用于判断url是否是加密协议的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isHttps() &#123;</div><div class="line">  return url.isHttps();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的HttpUrl类我们等下再继续看。</p>
<p>接下来我们来看看Request的内部类Builder</p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>首先，理所当然的，Builder中肯定要包含Request中必备的所有属性变量。<br>我们都知道，建造者模式的Builder就是用于传入参数，并使用这些参数来构造一个对象Request。<br>那么两种方法是必须有的：</p>
<ul>
<li>赋值方法Setter</li>
<li>建造方法build</li>
</ul>
<p>我们先一个一个来剖析赋值方法</p>
<h4 id="url"><a href="#url" class="headerlink" title="url()"></a>url()</h4><p>既然OkHttp自己写了一个HttpUrl类，那么最后肯定是要使用这个类作为参数的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public Builder url(HttpUrl url) &#123;</div><div class="line">      if (url == null) throw new NullPointerException(&quot;url == null&quot;);</div><div class="line">      this.url = url;</div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类其实也是比较简单，就是判断url是否为空不为空就赋值。<br>而我们其实在使用的时候，先去实例化一个HttpUrl是比较麻烦，而且我们一般关注的也只是Url中的网址，即使用一个字符串是最为直观的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public Builder url(String url) &#123;</div><div class="line">      if (url == null) throw new NullPointerException(&quot;url == null&quot;);</div><div class="line"></div><div class="line">      // Silently replace web socket URLs with HTTP URLs.</div><div class="line">      if (url.regionMatches(true, 0, &quot;ws:&quot;, 0, 3)) &#123;</div><div class="line">        url = &quot;http:&quot; + url.substring(3);</div><div class="line">      &#125; else if (url.regionMatches(true, 0, &quot;wss:&quot;, 0, 4)) &#123;</div><div class="line">        url = &quot;https:&quot; + url.substring(4);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return url(HttpUrl.get(url));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里会去判断这个字符串是加密网址还是普通网址，加密网址会使用https来进行重新赋值给url这个字符串，并使用HttpUrl的get()方法来返回一个HttpUrl对象。<br>而有时我们并不是自己手动去敲一个Url，而是从其他地方获取到的一个URL对象（系统定义）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Builder url(URL url) &#123;</div><div class="line">      if (url == null) throw new NullPointerException(&quot;url == null&quot;);</div><div class="line">      return url(HttpUrl.get(url.toString()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么更加容易，因为URL类有着直接转化为String类型的方法toString()，而再见String类型的url转化为HttpUrl对象。<br>这两个重载方法也为我们的调用提供了相当大的便携性。</p>
<h4 id="header"><a href="#header" class="headerlink" title="header()"></a>header()</h4><p>这里的对请求头的赋值处理有两个方法，这里对这两个方法的使用就需要十分小心了。我们先来看看这两个方法的代码，再聊聊他们的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public Builder header(String name, String value) &#123;</div><div class="line">      headers.set(name, value);</div><div class="line">      return this;</div><div class="line">&#125;</div><div class="line">public Builder addHeader(String name, String value) &#123;</div><div class="line">      headers.add(name, value);</div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显可以看到的是一个调用了set，一个调用了add。<br>而这个headers对象也就是Headers对象，我们稍后解析这个类。<br>在这里，我们只要知道，set和add，没错，他们的区别就如你所想的那样，set是将整个请求头都更换掉，而add是在原有的请求头中再添加新的属性。</p>
<h4 id="method"><a href="#method" class="headerlink" title="method()"></a>method()</h4><p>接下来就一系列的请求方法了，如GET/POST/DELETE等等。<br>先来看看这个最简单的get()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Builder get() &#123;</div><div class="line">      return method(&quot;GET&quot;, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK,它就是调用了method()方法，我们再来看看这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public Builder method(String method, @Nullable RequestBody body) &#123;</div><div class="line">      if (method == null) throw new NullPointerException(&quot;method == null&quot;);</div><div class="line">      if (method.length() == 0) throw new IllegalArgumentException(&quot;method.length() == 0&quot;);</div><div class="line">      if (body != null &amp;&amp; !HttpMethod.permitsRequestBody(method)) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;method &quot; + method + &quot; must not have a request body.&quot;);</div><div class="line">      &#125;</div><div class="line">      if (body == null &amp;&amp; HttpMethod.requiresRequestBody(method)) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;method &quot; + method + &quot; must have a request body.&quot;);</div><div class="line">      &#125;</div><div class="line">      this.method = method;</div><div class="line">      this.body = body;</div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，前面就是一堆判断，注意在判断传入的method是否为空，这个方法是否能够携带请求体等等，最后就是惯例 – 为请求方法和请求体进行赋值。</p>
<p>看了这个method()方法之后，我们也能想象到，post、delete等方法是如何来操作的吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Builder post(RequestBody body) &#123;</div><div class="line">      return method(&quot;POST&quot;, body);</div><div class="line">&#125;</div><div class="line">public Builder delete(@Nullable RequestBody body) &#123;</div><div class="line">      return method(&quot;DELETE&quot;, body);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>十分简单，那么put、patch等方法也如此，我就不贴出来了。</p>
<h4 id="builder"><a href="#builder" class="headerlink" title="builder()"></a>builder()</h4><p>属性都设置完了，最后就构造了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public Request build() &#123;</div><div class="line">      if (url == null) throw new IllegalStateException(&quot;url == null&quot;);</div><div class="line">      return new Request(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里直接new一个Request对象，将自己作为参数，OK,我们返回最上面的Request的构造方法。<br>是吧，就是将我们在Builder中传入的属性，作为Reuqest的构造方法的参数，就这么实例化出了Request对象。</p>
<p>到了这里，我们就讲完了Request的整个构建过程。<br>那么上面说的，其中还有一些类我们需要分析的，那就来吧。</p>
<h2 id="参数类分析"><a href="#参数类分析" class="headerlink" title="参数类分析"></a>参数类分析</h2><h3 id="HttpUrl"><a href="#HttpUrl" class="headerlink" title="HttpUrl"></a>HttpUrl</h3><p>这个类相当庞大，当然，网络并没有那么简单，对于一个url的解析当然需要很长很长的代码了，这里我分析几个会经常使用到的方法即可：</p>
<h4 id="isHttps"><a href="#isHttps" class="headerlink" title="isHttps()"></a>isHttps()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isHttps() &#123;</div><div class="line">    return scheme.equals(&quot;https&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个URL会拆分为protocol（协议）、hostname（主机名）、port（端口号）、path（路径）以及一系列的参数。<br>scheme在网络中我们可以理解为协议。这里我们通过比较这个协议是否为https，来判断这个网址是否是加密的。</p>
<h4 id="get-String"><a href="#get-String" class="headerlink" title="get(String)"></a>get(String)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static HttpUrl get(String url) &#123;</div><div class="line">    return new Builder().parse(null, url).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看出，HttpUrl同样是使用了构造者模式，那么我们来看看Builder中的parse方法(部分代码)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">Builder parse(@Nullable HttpUrl base, String input) &#123;</div><div class="line">      ...</div><div class="line">      // Scheme.</div><div class="line">      if (schemeDelimiterOffset != -1) &#123;</div><div class="line">        if (input.regionMatches(true, pos, &quot;https:&quot;, 0, 6)) &#123;</div><div class="line">          this.scheme = &quot;https&quot;;</div><div class="line">          pos += &quot;https:&quot;.length();</div><div class="line">        &#125; else if (input.regionMatches(true, pos, &quot;http:&quot;, 0, 5)) &#123;</div><div class="line">          this.scheme = &quot;http&quot;;</div><div class="line">          pos += &quot;http:&quot;.length();</div><div class="line">        &#125;</div><div class="line">      &#125; else if (base != null) &#123;</div><div class="line">        this.scheme = base.scheme;</div><div class="line">      &#125;</div><div class="line">      ...</div><div class="line">          switch (c) &#123;</div><div class="line">            case &apos;@&apos;:</div><div class="line">              // User info precedes.</div><div class="line">              if (!hasPassword) &#123;</div><div class="line">                int passwordColonOffset = delimiterOffset(</div><div class="line">                    input, pos, componentDelimiterOffset, &apos;:&apos;);</div><div class="line">                String canonicalUsername = canonicalize(</div><div class="line">                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,</div><div class="line">                    null);</div><div class="line">                this.encodedUsername = hasUsername</div><div class="line">                    ? this.encodedUsername + &quot;%40&quot; + canonicalUsername</div><div class="line">                    : canonicalUsername;</div><div class="line">                if (passwordColonOffset != componentDelimiterOffset) &#123;</div><div class="line">                  hasPassword = true;</div><div class="line">                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,</div><div class="line">                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,</div><div class="line">                      null);</div><div class="line">                &#125;</div><div class="line">                hasUsername = true;</div><div class="line">              &#125; else &#123;</div><div class="line">                this.encodedPassword = this.encodedPassword + &quot;%40&quot; + canonicalize(input, pos,</div><div class="line">                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,</div><div class="line">                    null);</div><div class="line">              &#125;</div><div class="line">              pos = componentDelimiterOffset + 1;</div><div class="line">              break;</div><div class="line"></div><div class="line">            case -1:</div><div class="line">            case &apos;/&apos;:</div><div class="line">            case &apos;\\&apos;:</div><div class="line">            case &apos;?&apos;:</div><div class="line">            case &apos;#&apos;:</div><div class="line">              // Host info precedes.</div><div class="line">              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);</div><div class="line">              if (portColonOffset + 1 &lt; componentDelimiterOffset) &#123;</div><div class="line">                host = canonicalizeHost(input, pos, portColonOffset);</div><div class="line">                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);</div><div class="line">                if (port == -1) &#123;</div><div class="line">                  throw new IllegalArgumentException(&quot;Invalid URL port: \&quot;&quot;</div><div class="line">                      + input.substring(portColonOffset + 1, componentDelimiterOffset) + &apos;&quot;&apos;);</div><div class="line">                &#125;</div><div class="line">              &#125; else &#123;</div><div class="line">                host = canonicalizeHost(input, pos, portColonOffset);</div><div class="line">                port = defaultPort(scheme);</div><div class="line">              &#125;</div><div class="line">              if (host == null) &#123;</div><div class="line">                throw new IllegalArgumentException(</div><div class="line">                    INVALID_HOST + &quot;: \&quot;&quot; + input.substring(pos, portColonOffset) + &apos;&quot;&apos;);</div><div class="line">              &#125;</div><div class="line">              pos = componentDelimiterOffset;</div><div class="line">              break authority;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; </div><div class="line">      ...</div><div class="line">      // Resolve the relative path.</div><div class="line">      int pathDelimiterOffset = delimiterOffset(input, pos, limit, &quot;?#&quot;);</div><div class="line">      resolvePath(input, pos, pathDelimiterOffset);</div><div class="line">      pos = pathDelimiterOffset;</div><div class="line"></div><div class="line">      // Query.</div><div class="line">      if (pos &lt; limit &amp;&amp; input.charAt(pos) == &apos;?&apos;) &#123;</div><div class="line">        int queryDelimiterOffset = delimiterOffset(input, pos, limit, &apos;#&apos;);</div><div class="line">        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(</div><div class="line">            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));</div><div class="line">        pos = queryDelimiterOffset;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Fragment.</div><div class="line">      if (pos &lt; limit &amp;&amp; input.charAt(pos) == &apos;#&apos;) &#123;</div><div class="line">        this.encodedFragment = canonicalize(</div><div class="line">            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实就是根据我们传入的String字符串，分解识别并赋值给URL的各个属性（如scheme、host、port等等）。</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public String toString() &#123;</div><div class="line">    return url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个挺简单的，就是返回一个url，而这个url的值是在Builder中的toString()方法，Builder中的toString()方法就将上面所说的URL的组成部分按照URL的规则组装成一个字符串。</p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Headers相对来说比较简单，其实就是在存储一些数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final String[] namesAndValues;</div></pre></td></tr></table></figure></p>
<p>我们可能会困惑，为什么这是一个String数组，而不是一个List或Set等的容器呢。<br>这是为了性能考虑的，别忘了，数组的一个优点，就是读取相当快。</p>
<p>那么，它是存取规则又是什么呢，怎么做到既存入key，又存入value呢。这我们就需要来看它的存入逻辑了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Builder set(String name, String value) &#123;</div><div class="line">      checkNameAndValue(name, value);</div><div class="line">      removeAll(name);</div><div class="line">      addLenient(name, value);</div><div class="line">      return this;</div><div class="line">&#125;</div><div class="line">public Builder add(String name, String value) &#123;</div><div class="line">      checkNameAndValue(name, value);</div><div class="line">      return addLenient(name, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到，set()方法会先删除所有name对应的所有信息（name和value）。<br>这里看一下addLenient()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Builder addLenient(String name, String value) &#123;</div><div class="line">      namesAndValues.add(name);</div><div class="line">      namesAndValues.add(value.trim());</div><div class="line">      return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说，每存入一个键值对，要用两个位置来存储。<br>所以，在读取的时候，直接使用name去比较，知道找到了和name一样的key，就会去获取这个元素的下一个元素，即name对应的value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static String get(String[] namesAndValues, String name) &#123;</div><div class="line">    for (int i = namesAndValues.length - 2; i &gt;= 0; i -= 2) &#123;</div><div class="line">      if (name.equalsIgnoreCase(namesAndValues[i])) &#123;</div><div class="line">        return namesAndValues[i + 1];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们注意到，在对比name的时候，使用的是equalsIgnoreCase()方法，也就是忽略大小写的。<br>所以，这个Header在传入的时候，我们要注意，这里是不区分大小写的。</p>
<h3 id="ReqeustBody"><a href="#ReqeustBody" class="headerlink" title="ReqeustBody"></a>ReqeustBody</h3><p>这个RequestBody是一个抽象类，涉及的内容也比较多，且比较重要，我们就留着下一篇再继续分析，毕竟这个篇幅已经很长，而我也需要睡觉了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知识点 -- Handler]]></title>
      <url>http://yoursite.com/2018/07/12/%E7%9F%A5%E8%AF%86%E7%82%B9-Handler/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="什么是Handler"><a href="#什么是Handler" class="headerlink" title="什么是Handler"></a>什么是Handler</h2><blockquote>
<p>Handler是Android消息传递机制的上层接口。</p>
</blockquote>
<p>Handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。</p>
<h2 id="Handler的功能"><a href="#Handler的功能" class="headerlink" title="Handler的功能"></a>Handler的功能</h2><ul>
<li>可以让Message或Runnable在某个时间段执行</li>
<li>可以将耗时操作放在子线程中，而将UI的更新放在主线程中，通过Handler来传递信息</li>
</ul>
<p>Handler的发送方法：</p>
<ol>
<li>post(Runnable)</li>
<li>sendMessage(Message)<br>post方法最后还是会调用sendMessage方法。</li>
</ol>
<h2 id="Handler的机制"><a href="#Handler的机制" class="headerlink" title="Handler的机制"></a>Handler的机制</h2><blockquote>
<p>Looper – MessageQueue – Message – Handler</p>
</blockquote>
<ul>
<li>Looper中有一个MessageQueue，用来保存消息Message</li>
<li>在当前线程中使用Looper.myLooper()来获取属于当前线程的Looper对象</li>
<li>Handler构造传入该Looper对象</li>
<li>则Handler中的MessageQueue和Looper的MessageQueue相关联</li>
<li>Handler发送消息，会存入到Looper中的MessageQueue</li>
<li>Looper.loop()开始消息轮询，从MessageQueue中获取Message</li>
<li>Message会调用其target（也就是Handler）的方法，最终调用Handler的handleMessage()方法</li>
</ul>
<h2 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h2><h3 id="myLooper-是怎么和线程挂钩"><a href="#myLooper-是怎么和线程挂钩" class="headerlink" title="myLooper()是怎么和线程挂钩"></a>myLooper()是怎么和线程挂钩</h3><p>Looper.myLooper();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myLooper() --&gt; </div><div class="line"><span class="keyword">return</span> sThreadLocal.get();</div></pre></td></tr></table></figure></p>
<p>这里的sThreadLocal能够控制其get()/set()方法都是发生在当前线程中。<br>在Looper创建时，会将该Looper放入到sThreadLocal中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sThreadLocal.set(<span class="keyword">new</span> Looper(...));</div></pre></td></tr></table></figure></p>
<p>Handler通过使用sThreadLocal来存放Looper，正是因为其能保证，<strong>一个线程只拥有一个Looper</strong>。</p>
<h3 id="Handler中的MessageQueue和Looper中的MessageQueue怎么关联的"><a href="#Handler中的MessageQueue和Looper中的MessageQueue怎么关联的" class="headerlink" title="Handler中的MessageQueue和Looper中的MessageQueue怎么关联的"></a>Handler中的MessageQueue和Looper中的MessageQueue怎么关联的</h3><p>Handler中有一个MessageQueue对象 – mQueue<br>在Handler的构造方法中，会将Looper的MessageQueue赋值过来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mQueue = mLooper.mQueue;</div></pre></td></tr></table></figure></p>
<p>在Handler发送消息的时候会将消息入队：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enqueueMessage(... msg) -&gt; mQueue.enqueueMessage(...)</div></pre></td></tr></table></figure></p>
<h3 id="消息轮询"><a href="#消息轮询" class="headerlink" title="消息轮询"></a>消息轮询</h3><p>消息轮询是指调用了Looper.loop()方法。<br>主线程中是Activity类中已经打开了Looper消息轮询，而在子线程中执行，则需要自己手动打开。<br>在loop()方法中，会执行：</p>
<ul>
<li>for(;;) – 无限循环，来不停地获取消息</li>
<li>从队列中获取消息：Message message = queue.next();</li>
<li>向Handler发送处理通知：message.target.dispatchMessage(message);<br>而Message中携带的target就是一个Handler，而Handler的dispatchMessage方法最后会调用到handleMessage方法。</li>
</ul>
<p><img src="/img/handler/Handler.png" alt="Handler流程图"></p>
<h3 id="Handler消息轮询的文字表述"><a href="#Handler消息轮询的文字表述" class="headerlink" title="Handler消息轮询的文字表述"></a>Handler消息轮询的文字表述</h3><ul>
<li>线程创建时会创建一个专属的Looper对象</li>
<li>创建Handler对象，以该线程中的Looper作为参数</li>
<li>当Handler发送消息的时候，会将消息存入到Looper中的消息队列</li>
<li>开启消息轮询Looper.loop()</li>
<li>消息轮询会从消息队列中不断获取消息，并调用消息自带的target的dispatchMessage方法分发消息</li>
<li>分发方法最后会调用到Handler的handleMessage方法，我们就可以在Handler所在的线程中处理消息</li>
</ul>
<h3 id="Handler部分源码分析"><a href="#Handler部分源码分析" class="headerlink" title="Handler部分源码分析"></a>Handler部分源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callbackm, <span class="keyword">boolean</span> async)</span></span>&#123;</div><div class="line">    mLooper = looper;</div><div class="line">    mCallback = callback;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mAsynchonous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Handler构造的时候会将其MessageQueue和Looper中的MessageQueue相关联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">    <span class="comment">//使用post发送消息，最终还是调用了sendMessageDelayed()方法</span></div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的post方法发送消息，最终还是会调用到sendMessage方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span>(mAysnchronous)&#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先将Message的target设置为本Handler，<br>再调用队列的enqueueMessage方法将消息入队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(msg.callback != <span class="keyword">null</span>)&#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(mCallback != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(mCallback.handleMessage(msg))&#123;</div><div class="line">                <span class="keyword">return</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在消息轮询的时候会通过Message的target去分发，而在这个分发方法中，会去调用一个空实现的方法handleMessage()。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EventBus3.0 源码解析]]></title>
      <url>http://yoursite.com/2018/07/06/EventBus3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>作为greenrobot的一个重头项目，了解EventBus还是很有必要的。<br>带着菜鸟迫切想进步的激情，看了一遍EventBus的代码，相比于其他大型的框架代码，明显这个EventBus还是比较适合初学者的我来阅读的。<br>github（<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">greenrobot/EventBus3.0</a>）上对EventBus的使用说明相当清晰明了。</p>
<p>先来看看官方对EventBus的介绍：</p>
<blockquote>
<p>simplifies the communication between components decouples event<br>senders and receivers performs well with Activities, Fragments, and background threads avoids complex and error-prone dependencies and life cycle issues</p>
</blockquote>
<p>大致意思就是：<br>简化了组件之间的通信，很好地解决了依赖关系和生命周期复杂易错的问题。</p>
<p>下面是EventBus的基本流程图：<br><img src="/img/eventbus/EventBus.png" alt="eventbus流程图"></p>
<p>这里，我就开始来输出我今天对EventBus源码的理解了。</p>
<hr>
<h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a><strong>事件注册</strong></h2><p><strong>首先是在某个类中对EventBus进行注册</strong></p>
<pre><code>EventBus.getDefault().register(this);
</code></pre><p>EventBus通过调用register方法来进行注册，传入的参数是一个Object。所以可以在任何一个类中去注册EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//传入参数作为订阅者</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span></span>&#123;</div><div class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line"></div><div class="line">    <span class="comment">//判断该类（订阅者）是不是匿名内部类</span></div><div class="line">    <span class="keyword">boolean</span> forceReflection = subscriberClass.isAnnoymousClass();</div><div class="line">    <span class="comment">//获取订阅者中的订阅方法 -- 通过注解的方法来订阅</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = </div><div class="line">                subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(SubscriberMethod subscirberMethod: subscriberMethods)&#123;</div><div class="line">        <span class="comment">//将订阅者和订阅方法对应保存</span></div><div class="line">        subscribe(subscriber, subscriberMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先获取订阅者的类对象，通过判断该类是否是匿名内部类，将该判断和类对象作为参数，通过SubscriberMethodFinder的findSubscriberMethods方法来获取所有的订阅方法（事件处理的方法），最后将订阅者和订阅方法对应起来并注册到EventBus中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass, <span class="keyword">boolean</span> forceReflection)</span></span>&#123;</div><div class="line">    <span class="comment">//获取类名，以类名为key</span></div><div class="line">    String key = subscriberClass.getName();</div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(METHOD_CACHE)&#123;</div><div class="line">        <span class="comment">//从缓存中去获取</span></div><div class="line">        subscriberMethods = METHOD_CACHE.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(subscriberMethods != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//如果缓存中有，则直接返回缓存中的订阅方法</span></div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(INDEX != <span class="keyword">null</span> &amp;&amp; !forceReflection)&#123;</div><div class="line">        <span class="comment">//如果INDEX不为空，且不是匿名内部类</span></div><div class="line">        subscriberMethods = findSubscriberMethodsWithIndex(subscriberClass);</div><div class="line">        <span class="keyword">if</span>(subscriberMethods.isEmpty())&#123;</div><div class="line">            <span class="comment">//使用其他方法再查找一次</span></div><div class="line">            subscriberMethods = findSubscriberMethodWithReflection(subscriberClass);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriberMethods = findSubscriberMethodWithReflection(subscriberClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(subscriberMethods.isEmpty())&#123;</div><div class="line">        <span class="comment">//如果没有订阅方法，则抛出异常</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"..."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//存入缓存并返回</span></div><div class="line">        <span class="keyword">synchronized</span>(METHOD_CACHE)&#123;</div><div class="line">            METHOD_CACHE.put(key, subscriberMethods);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该方法中，首先会使用类名作为key在缓存中获取订阅方法。<br>如果有，则直接返回；如果没有，就根据是否为匿名内部类来使用findSubscriberMethodsWithIndex()或findSubscriberMethodsWithReflection()方法来获取订阅方法 。<br>如果还是没有获取到，则抛出异常。如果获取到了，就将方法存入到缓存中并返回。</p>
<p>在上面的判断中，有一个对象为INDEX，我们看看这个是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubscriberIndex INDEX;</div><div class="line"></div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">    SubscriberIndex newIndex = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"de.greenrobot.event.GeneratedSubscriberIndex"</span>);</div><div class="line">        newIndex = (SubscriberIndex) clazz.newInstance();</div><div class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e)&#123;</div><div class="line">        Log.d(...);</div><div class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        Log.w(...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INDEX = newIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于在EventBus3中并没有de.greenrobot.event.GeneratedSubscriberIndex这个类，所以INDEX为空。<br>那么，上面findSubscriberMethods方法中的判断会直接调用findSubscriberMethodWithReflection()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethodWithReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>&#123;</div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    Class&lt;?&gt; clazz = subscriberClass;</div><div class="line">    HashMap&lt;String&gt; eventTypesFound = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    String methodKeyBuilder = <span class="keyword">new</span> StringBuider();</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(clazz != <span class="keyword">null</span>)&#123;</div><div class="line">        String name = clazz.getName();</div><div class="line">        <span class="keyword">if</span>(name.startWith(<span class="string">"java."</span>) || name.startWith(<span class="string">"javax."</span>) || name.startWith(<span class="string">"android."</span>))&#123;</div><div class="line">            <span class="comment">//如果是以java、javax、android开头的类，都pass掉</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//通过反射来获取该类中的所有方法（注意是所有方法，后面再进行筛选）</span></div><div class="line">        Method[] methods = clazz.getDeclaredMethods();</div><div class="line">        <span class="comment">//对所有方法进行遍历</span></div><div class="line">        <span class="keyword">for</span>(Method method: methods)&#123;</div><div class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">            <span class="comment">//方法必须为public</span></div><div class="line">            <span class="keyword">if</span>((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>)&#123;</div><div class="line">                <span class="comment">//获取所有的参数的类型</span></div><div class="line">                Class&lt;?&gt;[] parameterTypes = method.getparamterTypes();</div><div class="line">                <span class="comment">//方法必须只有一个参数</span></div><div class="line">                <span class="keyword">if</span>(paramterTypes.length == <span class="number">1</span>)&#123;</div><div class="line">                    <span class="comment">//获取该方法中由@Subscribe注解</span></div><div class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                    <span class="comment">//这里判断该方法是否由@Subscribe注解</span></div><div class="line">                    <span class="keyword">if</span>(subscribeAnnotation != <span class="keyword">null</span>)&#123;</div><div class="line">                        <span class="comment">//获取方法名</span></div><div class="line">                        String methodName = method.getName();</div><div class="line">                        <span class="comment">//获取参数的类型</span></div><div class="line">                        Class&lt;?&gt; eventType = paramterTypes[<span class="number">0</span>];</div><div class="line">                        methodKeyBuilder.setLength(<span class="number">0</span>);</div><div class="line">                        methodKeyBuilder.append(methodName);</div><div class="line">                        methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</div><div class="line">                        </div><div class="line">                        String methodKey = methodKeyBuilder.toString();</div><div class="line">                        <span class="keyword">if</span>(eventTypesFound.add(methodKey))&#123;</div><div class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                            <span class="comment">//这里将订阅方法添加到List中</span></div><div class="line">                            subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                                        subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(strictMethodVerification)&#123;</div><div class="line">                    <span class="comment">//由@Subscribe注解，但参数不止一个的，直接抛出异常</span></div><div class="line">                    <span class="keyword">if</span>(method.isAnnotationPresent(Subscribe.class))&#123;</div><div class="line">                        <span class="keyword">throw</span> ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(strictMethodVerification)&#123;</div><div class="line">                <span class="comment">//由@Subscribe注解，但不是public修饰的，直接抛出异常</span></div><div class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(Subscribe.class))&#123;</div><div class="line">                    <span class="keyword">throw</span> ....</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果在当前类没有找到@Subscribe注解的方法，会去遍历该类的父类。</span></div><div class="line">        clazz = clazz.getSuperclass();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> subscriberMethods;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，功能是从该SubscriberClass类及其父类中查找所有@Subscribe注解的方法，判断标准为public修饰且参数只能有一个。</p>
<p>获取完所有的订阅方法后，开始进行注册。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span></span>&#123;</div><div class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">    <span class="comment">//获取订阅的类型所对应的Subscription</span></div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">    </div><div class="line">    <span class="comment">//判断是否已经注册过，如果subscriptions为空，则是未注册过的</span></div><div class="line">    <span class="keyword">if</span>(subscriptions == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//将subscriptions存入到缓存中，即代表注册</span></div><div class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">        subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(subscriptions.contains(newSubscription))&#123;</div><div class="line">            <span class="comment">//如果已经注册过了的，直接抛出异常说明已经有注册过</span></div><div class="line">            <span class="keyword">throw</span> ..</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(subscription)&#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= size;i ++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority)&#123;</div><div class="line">                <span class="comment">//如果轮询到subscriptions的最后一位了，那么就将该subscription存放到最后</span></div><div class="line">                <span class="comment">//如果该订阅方法的优先级比subscriptions中的某个方法的优先级高，则存放在该位置上。</span></div><div class="line">                subscriptions.add(i, newSubscription);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//将事件类型添加到typesBySubscriber中</span></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span>(subscribedEvents == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//没有缓存</span></div><div class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">    &#125;</div><div class="line">    subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">    <span class="comment">//判断是否有粘性事件，如果有，则立即处理</span></div><div class="line">    <span class="keyword">if</span>(subscriberMethod.sticky)&#123;</div><div class="line">        <span class="keyword">if</span>(eventInheritance)&#123;</div><div class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvnets.entrySet();</div><div class="line">            <span class="keyword">for</span>(Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry: entries)&#123;</div><div class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                <span class="keyword">if</span>(eventType.isAssignableFrom(candidateEventType))&#123;</div><div class="line">                    Object stickyEvent = entry.getValue();</div><div class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            Object stickEvent = stickyEvents.get(eventType);</div><div class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里如果为粘性事件，会直接调用 postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</p>
<p>在subscribe方法中，主要在于几个容器的存储：<br><strong>subscriptions</strong>：订阅对象的集合<br><strong>subscribedEvents</strong>：订阅的事件的集合<br><strong>subscriptionsByEventType</strong>：以事件为key，以订阅对象为value的Map<br><strong>typesBySubscriber</strong>：以订阅对象为key，以事件为value的Map</p>
<h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a><strong>发送事件</strong></h2><p>发送的动作由post方法来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span></span>&#123;</div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    <span class="comment">//将要发送的事件添加到事件队列中去</span></div><div class="line">    eventQueue.add(event);</div><div class="line">   </div><div class="line">    <span class="keyword">if</span>(!postingState.isPosting)&#123;</div><div class="line">         <span class="comment">//表示目前没有正在发送</span></div><div class="line">                <span class="comment">//是否在主线程中post</span></div><div class="line">                postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">                postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span>(postingState.canceled)&#123;</div><div class="line">                    <span class="keyword">throw</span> ...</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">while</span>(!eventQueue.isEmpty())&#123;</div><div class="line">                        <span class="comment">//循环处理eventQueue中的每一个事件</span></div><div class="line">                        postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span>&#123;</div><div class="line">                    <span class="comment">//发送完成后，重置标志信息</span></div><div class="line">                    postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">                    postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的posting的状态值会从currentPostingThreadState中获取，这个currentPostingThreadState是一个ThreadLocal类型，也就是说，它是线程无关的变量，在其里面存储着PostingThreadState。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState</div><div class="line">                     = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span></span>&#123;</div><div class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">boolean</span> isPosting;</div><div class="line">    <span class="keyword">boolean</span> isMainThread;</div><div class="line">    Subscription subscription;</div><div class="line">    Object event;</div><div class="line">    <span class="keyword">boolean</span> canceled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个PostingThreadState类包含了一个事件队列以及一些标志信息，而事件队列eventQueue中存放了所有的post事件对象。</p>
<p>当遍历事件队列时，会将里面的每一个事件进行post<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error</span>&#123;</div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(eventInheritance)&#123;</div><div class="line">        <span class="comment">//如果事件允许继承，则会调用lookupAllEventTypes来查找所有的父类和借口类</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">0</span>;h &lt; countTypes;h ++)&#123;</div><div class="line">            Calss&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!subscriptionFound)&#123;</div><div class="line">        <span class="keyword">if</span>(sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class </div><div class="line">                                &amp;&amp; eventClass != SubscriberExceptionEvent.class)&#123;</div><div class="line">            <span class="comment">//如果post的事件没有被注册，则直接post一个NoSubscriberEvent对象</span></div><div class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看看如果允许继承，怎么查找父类和接口类中的事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; lookupAllEvnetTypes(Class&lt;?&gt; eventClass)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(eventTypesCache)&#123;</div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</div><div class="line">        <span class="keyword">if</span>(eventTypes == <span class="keyword">null</span>)&#123;</div><div class="line">            eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            Class&lt;?&gt; clazz = eventClass;</div><div class="line">            <span class="keyword">while</span>(clazz != <span class="keyword">null</span>)&#123;</div><div class="line">                eventTypes.add(clazz);</div><div class="line">                addInterface(eventTypes, clazz.getInterfaces());</div><div class="line">                clazz = clazz.getSuperclass();</div><div class="line">            &#125;</div><div class="line">            eventTypesCache.put(eventClass, evnetTypes);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> eventTypes;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里会先从缓存中去获取，如果没有的话，再去创建一个List容器，将这个类中的eventClass添加到list中，再去interface和superclass中去查找和存储。</p>
<p>继续看事件的发送过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingThreadState</span></span></div><div class="line">                                                        , Class&lt;?&gt; eventClass)&#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        <span class="comment">//获取所有的事件</span></div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty())&#123;</div><div class="line">        <span class="keyword">for</span>(Subscription subscription: subscriptions)&#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="comment">//对每一个事件进行post</span></div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(aborted)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    reutrn <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span></span>&#123;</div><div class="line">    <span class="keyword">switch</span>(subscription.subscriberMethod.threadMode)&#123;</div><div class="line">        <span class="comment">//对事件指定的threadMode属性</span></div><div class="line">        <span class="comment">//指定事件执行的线程为PostThread或没有指定时</span></div><div class="line">        <span class="keyword">case</span> PostThread:</div><div class="line">             <span class="comment">//在post的线程中执行事件</span></div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MainThread:</div><div class="line">            <span class="comment">//如果当前post的线程是主线程，则直接在当前线程（主线程）中执行事件</span></div><div class="line">            <span class="comment">//如果当前post的线程不是主线程，则将事件添加到主线程的消息队列中</span></div><div class="line">            <span class="keyword">if</span>(isMainThread)&#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BackgroundThread:</div><div class="line">            <span class="comment">//如果当前post的线程为主线程，则调用backgroundPoster，将事件添加到该消息队列中</span></div><div class="line">            <span class="comment">//如果当前post的线程不是主线程，则直接在该线程中执行</span></div><div class="line">            <span class="keyword">if</span>(isMainThread)&#123;</div><div class="line">                backgroundPoster.enqueue(subscription ,event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> Async:</div><div class="line">            asyncPoster.enqueue(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是根据register的时候对各个订阅方法的执行线程，分别在对应的线程中去执行。<br>其中：<br>mainThreadPoster: HandlerPoster extends Handler<br>backgroundPoster: BackgoundPoster extends Runnable<br>asyncPoster: AsyncPoster extends Runnable</p>
<p>这里主要看HandlerPoster<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span></span>&#123;</div><div class="line">    <span class="comment">//将事件封装成PendingPost对象</span></div><div class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);\</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">        <span class="comment">//将事件添加到消息队列中</span></div><div class="line">        queue.enqueue(pendingPost);</div><div class="line">        <span class="keyword">if</span>(!handlerActive)&#123;</div><div class="line">            handlerActive = <span class="keyword">true</span>;</div><div class="line">            <span class="comment">//这里会向Handler发送消息，让Handler的Looper开始轮询</span></div><div class="line">            <span class="keyword">if</span>(!sendMessage(obtainMessage()))&#123;</div><div class="line">                <span class="keyword">throw</span> ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时调用sendMessage方法，则Handler的handleMessage会被调用到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="comment">//从消息队列中取出由事件封装成的PendingPost对象</span></div><div class="line">            PendingPost pendingPost = queue.poll();</div><div class="line">            <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                    <span class="comment">//如果上一次获取不到，则重新获取一遍</span></div><div class="line">                    pendingPost = queue.poll();</div><div class="line">                    <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>)&#123;</div><div class="line">                        handlerActive = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span> ;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里将获取到的事件作为参数，调用EventBus中的invokeSubscriber方法</span></div><div class="line">            eventBus.invokeSubscriber(pendingPost);</div><div class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">            <span class="keyword">if</span>(timeInMethod &gt;= maxMillisInsideHandleMessage)&#123;</div><div class="line">                <span class="keyword">if</span>(!sendMessage(obtainMessage()))&#123;</div><div class="line">                    <span class="keyword">throw</span> ...</div><div class="line">                &#125;</div><div class="line">                rescheduled = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        handlerActive = rescheduled;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该方法中，还是会调用EventBus中的invokeSubscriber方法来处理事件。</p>
<p>而在BackgroundPost和AsyncPost中的run()方法中，最后也是会调用EventBus中的invokeSubscriber方法来处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span></span>&#123;</div><div class="line">    <span class="comment">//获取事件</span></div><div class="line">    Object event = pendingPost.event;</div><div class="line">    Subscription =  pendingPost.subscription;</div><div class="line">    PendingPost.releasePendingPost(pendingPost);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(subscription.active)&#123;</div><div class="line">        invokeSubscriber(subscription, event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">//通过反射的方式来执行事件的处理方法</span></div><div class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">    &#125; <span class="keyword">catch</span>(...)&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a><strong>取消注册</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span></span>&#123;</div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(subscribedTypes != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(Class&lt;?&gt; eventType: subscribedTypes)&#123;</div><div class="line">            unubscribeByEventType(subscriber, eventType);</div><div class="line">        &#125;</div><div class="line">        typesBySubscriber.remove(subscriber);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Log.w(...);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取消注册，也就是将在register时注册到EventBus中的事件处理函数移除掉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><img src="/img/eventbus/EventBus_Code.png" alt="eventbus流程图"></p>
<p><strong><em>EventBus的机制：</em></strong></p>
<ul>
<li>在注册的时候，通过反射的形式将所有使用@Subscribe注解的方法保存起来。</li>
<li>在事件发送的时候，会根据发送事件的类型去查找各个以该事件类型作为参数的注解方法，然后通过约定线程，在对应的线程中使用反射技术来执行该方法。</li>
<li>在取消注册的时候，将该订阅者和其注册的方法移除掉。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知识点 -- Service]]></title>
      <url>http://yoursite.com/2018/07/04/%E7%9F%A5%E8%AF%86%E7%82%B9-Service/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="什么是Service"><a href="#什么是Service" class="headerlink" title="什么是Service"></a>什么是Service</h2><blockquote>
<p>是一种可以在后台长时间运行，没有用户交互界面的引用组件。</p>
</blockquote>
<p>由于Service和BroadcastReceiver都是在主线程中运行，所以不能执行一些耗时操作。如果要执行耗时操作，则要新启一个子线程。</p>
<h2 id="Service和Thread的区别"><a href="#Service和Thread的区别" class="headerlink" title="Service和Thread的区别"></a>Service和Thread的区别</h2><ul>
<li><strong>定义</strong></li>
</ul>
<p>Thread是相对独立的，是程序执行的最小单位。<br>Service是依附在其所在的主线程上，是由程序进程托管的。</p>
<ul>
<li><strong>功能：</strong></li>
</ul>
<p>Thread可用于做一些耗时的操作。<br>Service不能执行耗时操作。</p>
<h3 id="为什么要在Service中去创建子线程去执行耗时操作，而不直接在Activity中创建？"><a href="#为什么要在Service中去创建子线程去执行耗时操作，而不直接在Activity中创建？" class="headerlink" title="为什么要在Service中去创建子线程去执行耗时操作，而不直接在Activity中创建？"></a>为什么要在Service中去创建子线程去执行耗时操作，而不直接在Activity中创建？</h3><p>Activity的生命周期所限制，在Activity销毁之后，很难再去对子线程进行管理。<br>而Service可以长时间存活在后台中，即使其Activity销毁了，也能在后台继续执行，所以它能更好地管理子线程。</p>
<h3 id="Thread和Service是使用场景区别"><a href="#Thread和Service是使用场景区别" class="headerlink" title="Thread和Service是使用场景区别"></a>Thread和Service是使用场景区别</h3><p>如果是读取数据库数据，连接网络等耗时操作，则应该要开启一个新线程来执行。<br>而Service一般使用在与用户交互无关的逻辑操作，例如在后台播放音乐，时间的更新等。</p>
<h2 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h2><h3 id="1、startService"><a href="#1、startService" class="headerlink" title="1、startService"></a>1、startService</h3><blockquote>
<p>通过该方式启动的Service，并不依赖于Activity的生命周期。<br>当开启它的Activity销毁后，该Service依然能存活在后台中。</p>
</blockquote>
<p><strong>Service的回调方法onStartCommand()，返回一个int类型的sticky值。</strong><br>源码：</p>
<pre><code>return mStartCommpatibility ? START_STICKY_COMMPATIBILITY : START_STICKY;
</code></pre><p>如果返回的是START_STICKY，那如果该Service因内存不够被杀死后，当系统内存又充足了，会重新启动该Service，并且调用其onStartCommand()方法，但该方法中的参数Intent为空。</p>
<h3 id="2、bindService"><a href="#2、bindService" class="headerlink" title="2、bindService"></a>2、bindService</h3><blockquote>
<p>绑定Activity，这样可以在Activity和Service之间通过Binder来进行通信。（不管是否在同一个进程）</p>
</blockquote>
<p>Service中要实现一个Binder继承类，其中返回该Service的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span></span>&#123;</div><div class="line">    <span class="function">MyService <span class="title">getService</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> MyService.<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时Activity就可以调用Service中的方法。</p>
<p>在Activity中，要去实现一个ServiceConnection对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ServiceConnection conn = <span class="keyword">new</span> ServiceConnection()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>&#123;</div><div class="line">        MyService.MyBinder binder = (MyService.MyBinder) service;</div><div class="line">        mService = service.getService();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="详细的Service介绍及使用"><a href="#详细的Service介绍及使用" class="headerlink" title="详细的Service介绍及使用"></a>详细的Service介绍及使用</h2><p>请前往“<a href="https://zouxiaobang.github.io/2016/09/21/Service%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="external">Service的理解</a>”。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知识点 -- Fragment]]></title>
      <url>http://yoursite.com/2018/07/04/%E7%9F%A5%E8%AF%86%E7%82%B9-Fragment/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="与Activity相比："><a href="#与Activity相比：" class="headerlink" title="与Activity相比："></a>与Activity相比：</h2><ul>
<li>更加节省内存</li>
<li>UI跳转效果更好</li>
</ul>
<h2 id="为什么被称为第5大组件？"><a href="#为什么被称为第5大组件？" class="headerlink" title="为什么被称为第5大组件？"></a>为什么被称为第5大组件？</h2><ul>
<li><p>拥有自己的生命周期</p>
</li>
<li><p>可以灵活地加载到Activity中</p>
</li>
</ul>
<blockquote>
<p>但它并不是独立的，是依附在对应的Activity中</p>
</blockquote>
<h2 id="加载（加载到Activity中）"><a href="#加载（加载到Activity中）" class="headerlink" title="加载（加载到Activity中）"></a>加载（加载到Activity中）</h2><ul>
<li>静态：标签加载 &lt;… android:name=”…Fragment”…/&gt;</li>
<li><p>动态：使用FragmentManager和FragmentTransaction来加载</p>
<p><strong>动态加载：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FragmentManager fm = getFragmentManager();</div><div class="line">FragmentTransaction ft = fm.getTransaction();</div><div class="line">RightFragment rf = new RightFragment();</div><div class="line">ft.add(R.id.right_fragment, rf, &quot;rightFragment&quot;);</div><div class="line">ft.addToBackStack(&quot;rightFragment&quot;);</div><div class="line">ft.commit();</div></pre></td></tr></table></figure>
<h2 id="ViewPager-Fragment"><a href="#ViewPager-Fragment" class="headerlink" title="ViewPager + Fragment"></a>ViewPager + Fragment</h2><blockquote>
<p>FragmentPagerAdapter：适用于页面较少<br>FragmentStatePagerAdapter：适用于页面较多，节省内存</p>
</blockquote>
<p><strong>对比两者的destroyItem()方法：</strong></p>
<ul>
<li><p>mCurrentTransaction.detach((Fragment)object)：<br>并没有对内存进行回收，只是将Activity和Fragment进行解绑</p>
</li>
<li><p>mCurrentTransaction.remove(fragment)：<br>对内存资源进行回收，直接删除对应的Fragment。这也导致了每次回到该页面时都要重新加载该Fragment。</p>
</li>
</ul>
<blockquote>
<p>FragmentStatePagerAdapter每次都会删去Fragment，且释放其内存，所以在多个页面切换的时候，能够更好地节省资源。但其每次回到该页面时都要重建，如果页面少的话，更建议使用FragmentPagerAdapter。</p>
</blockquote>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src="/img/Fragment/life3.png" alt="Fragment的生命周期"></p>
<h2 id="Fragment与Activity相关联的生命周期"><a href="#Fragment与Activity相关联的生命周期" class="headerlink" title="Fragment与Activity相关联的生命周期"></a>Fragment与Activity相关联的生命周期</h2><p><img src="/img/Fragment/life4.png" alt="Fragment与Activity的对比"></p>
<h2 id="Fragment的通信"><a href="#Fragment的通信" class="headerlink" title="Fragment的通信"></a>Fragment的通信</h2><ol>
<li>Activity调用Fragment中的方法：接口调用</li>
<li>Fragment调用Activity中的方法：getActivity()获取Activity</li>
<li>Fragment调用其他Fragment中的方法：getActivity().findFragmentById()</li>
</ol>
<h2 id="FragmentTransaction：replace、add"><a href="#FragmentTransaction：replace、add" class="headerlink" title="FragmentTransaction：replace、add"></a>FragmentTransaction：replace、add</h2><p> <strong>在切换Fragment时</strong><br>add：并没有刷新界面的内容<br>replace：会进行刷新</p>
<p>add：在切换时只是将Fragment界面隐藏<br>replace：每次都会进行销毁重建</p>
<h2 id="详细的Fragment介绍"><a href="#详细的Fragment介绍" class="headerlink" title="详细的Fragment介绍"></a>详细的Fragment介绍</h2><p>请前往“<a href="https://zouxiaobang.github.io/2016/09/19/Fragment%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Fragment解析</a>”</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知识点 -- Activity]]></title>
      <url>http://yoursite.com/2018/07/03/%E7%9F%A5%E8%AF%86%E7%82%B9-Activity/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="什么是Activity？"><a href="#什么是Activity？" class="headerlink" title="什么是Activity？"></a>什么是Activity？</h2><p>用户通过界面与系统进行交互。<br>例如按钮、输入框等控件。<br>而Activity正是用于对这些控件的控制。</p>
<h2 id="4种状态"><a href="#4种状态" class="headerlink" title="4种状态"></a>4种状态</h2><ul>
<li><p>running：界面可见且可与用户进行交互，处于Activity的栈顶</p>
</li>
<li><p>pause：失去焦点，界面被一个不完全或透明的界面所覆盖，此时已经不可交互</p>
</li>
<li><p>stop：界面不可见，被另外一个界面例如Activity完全覆盖</p>
</li>
<li><p>killed：内存被回收，例如内存信息、成员变量等都不存在</p>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><strong>Activity的启动：</strong><br>onCreate -&gt; onStart -&gt; onResume<br>onStart：界面可见，但还不能进行交互<br>onResume：界面可见，且处于前台，可进行交互</p>
<p><strong>点Home返回主界面：</strong><br>onPause -&gt; onStop<br>onPause：界面可见，且不能进行交互<br>onStop：界面已经不可见，处于后台</p>
<p><strong>再次回到Activity：</strong><br>onRestart -&gt; onStart -&gt; onResume<br>onRestart：由不可见转化为可见的过程</p>
<p><strong>退出Activity：</strong><br>onPause -&gt; onStop -&gt; onDestroy<br>onDestroy：当前Activity正在被销毁，进行一些资源的回收和释放的工作</p>
<h2 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h2><blockquote>
<p>前台进程 -&gt; 可见进程 -&gt; 服务进程 -&gt; 后台进程 -&gt; 空进程</p>
</blockquote>
<p><strong>前台进程</strong>：与用户正在交互或被前台Activity绑定的Service<br><strong>可见进程</strong>：可见但不是前台进程，不可与用户进行交互，例如调用了onPause但还没调用onStop的Activity<br><strong>服务进程</strong>：在后台启动的一个服务Service<br><strong>后台进程</strong>：例如一个前台进程，按了Home键之后进入后台进行等待（不同于服务进程）<br><strong>空进程</strong>：没有活跃的组件，一般是为了缓存而存在</p>
<h2 id="Android任务栈"><a href="#Android任务栈" class="headerlink" title="Android任务栈"></a>Android任务栈</h2><p>是一个Activity的集合，用于管理Activity。<br>退出应用时，会清除栈中所有的Activity —- 为了数据安全。</p>
<ul>
<li>一个应用可以拥有多个栈</li>
<li>一个Activity可以独享一个栈</li>
</ul>
<h2 id="启动模式-–-luanchMode-–-为复用而生"><a href="#启动模式-–-luanchMode-–-为复用而生" class="headerlink" title="启动模式 – luanchMode – 为复用而生"></a>启动模式 – luanchMode – 为复用而生</h2><ul>
<li>standard：默认的模式，每创建一个Activity，都会将其存入到栈中，且每次都会执行一个完整的生命周期</li>
<li>singleTop：栈顶复用，如果栈顶Activity为要启动的Activity，则不再创建一个新的Activity</li>
<li>singleTask：栈内复用，如果栈中有要启动的Activity，则直接使用该Activity，且把处于其上面的所有Activity清理出栈</li>
<li>singleInstance：一个Activity单独占用一个栈</li>
</ul>
<h2 id="跳转协议-–-scheme"><a href="#跳转协议-–-scheme" class="headerlink" title="跳转协议 – scheme"></a>跳转协议 – scheme</h2><ol>
<li>跳转到App的任何界面</li>
<li>通过通知栏跳转</li>
<li>通话H5页面进行跳转</li>
</ol>
<p>（例子：拨号盘上的暗码）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017总结和2018计划]]></title>
      <url>http://yoursite.com/2018/07/01/2017%E6%80%BB%E7%BB%93%E5%92%8C2018%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h2 id="2017年记事"><a href="#2017年记事" class="headerlink" title="2017年记事"></a>2017年记事</h2><p>一年，过去了，很快，又觉得已经过了很久。<br>从2017年伊始，我已经没有回学校上课了，除了那挂着的英语课和一门好不容易报上名的网络通识课，我的大学算是磕磕碰碰中结束了。<br>我从2月10号开始实习，这个日子我记得是如此清楚，毕竟是第一天上班，我还是很早地，忘了起床，邋邋遢遢就来到公司。第一天确实过得很快，因为我根本就没干嘛活，一天都在装电脑。说到这个装电脑，我是惭愧的，首先我确实是计算机学院的学生，其次我也确实有学过Linux课程。但我依然不知道显卡插在哪里，要怎么装两个硬盘，还为如何安装Linux系统犯了傻。<br>知耻后勇，我便买回一本《鸟哥的Linux私房菜》，刚开始确实看了好几章，可惜后面一忙，就没有继续看下去了，这将是我2018后半年年的一个小计划。</p>
<p>现在开始从头捋一捋。<br>从2月份到7月15号，我都是一名实习生，当初一起来实习的有3个人，我看着他们每天都在看书，学习(这是公司的培养方式)，我是很羡慕的，因为我每天都感觉挺忙的，都在一堆源码里查找，修改。当然，这是说好听的，其实就是很多重复性的动作，我怕我做久了就麻木了，在公司没有时间学习，那我就每天晚上回去看书，虽然时间很少，但我很享受，这段属于我自己的时间。每天花2个小时去看书，看博客，可惜的是那时我还没有一个很完善的学习机制，只是一直在看，没有记录，也没有过多的思考，感觉是浪费了，空有一个很努力的外表，其实没有收获到什么，至少到现在，我只记得我看过什么，却忘了看的内容了。<br>后来开始要修网络通识课，就每天晚上回去挂着，打会游戏，告诉自己要放松，不能被工作绑定。直到通识课结束了，就像突然一个习惯性的事件没了，有点不知所措，我才开始反思，打游戏，是在放松自己，还是自我堕落。<br>此时5个月的实习期已经结束了，公司安排要去惠州进行一个月的培训，我无法去评价这个月，也就不加评价了。最大的好处，也就是认识了几个好朋友吧。我更想称为朋友，而不是同事。<br>培训归来，我并开始进入又一段时间的浑噩生活，刚好赶上一个比较空闲的时间段，每天上班看一会书，我也不知道有没有看下去，然后就是玩会手游。直到，部长拉着去个小房间，提醒了一下游戏这种东西，在不恰当的时候去玩，总不是件好事情。说我是恍然大悟，其实也没有，只是我回家路上想了又想，对，我才23岁，我的人生还在最有活力的时候，我怎么活得像个龟。<br>于是我开始给自己制定一个模糊的计划，为什么是模糊的，因为我在后面的一段时间里，不断地去改变它，直到适合我。<br>这一小段时间里，我很认真也很高效地在学习，例如架构知识，例如多线程模式。对的，你发现了，我说的是一小段时间。并不是我没有意志力，而是后面发生的一件事，影响了我一段很长的时间。<br>入冬了，每天清晨起来不易，但我还是从未迟到，我是个守时的人，当然不是那种踏点，我会给自己预留时间。这段时间我的激情又回来了，我开始看我以前买的书，一本本慢慢啃，也手写了很多代码，也在慢慢修改自己的学习方式，虽然到现在，我也还没找到最适合我的，但总会有点进步的。</p>
<h3 id="2017专业书籍"><a href="#2017专业书籍" class="headerlink" title="2017专业书籍"></a>2017专业书籍</h3><ul>
<li>[x] Java编程思想</li>
<li>[x] Java语言程序设计 – 进阶版</li>
<li>[x] HeadFirst设计模式</li>
<li>[x] Android源码设计模式</li>
<li>[x] 图解Java多线程设计模式</li>
<li>[x] Kotlin极简教程</li>
<li>[ ] 鸟哥的Linux私房菜</li>
</ul>
<hr>
<h2 id="2018年记事"><a href="#2018年记事" class="headerlink" title="2018年记事"></a>2018年记事</h2><p>新年过完，我又开始了懒散的生活，除了看看博客，看看书，其实工作也从年前的忙碌慢慢闲下来。<br>5月2号，我又换了工作，去了一家小公司。公司人不多，所以活特别多，每天回到家都特别累。在第一个月里，又开始了我浑浑噩噩的学习生活。学习，没动力，生活，一团糟。早上挣扎着起床，晚上回来洗澡完就逼着自己赶紧睡觉。<br>是该休息一下了，冷静下来去思考一下，而不是唯唯诺诺，战战兢兢，患得患失地继续下去了。</p>
<h2 id="2018年计划"><a href="#2018年计划" class="headerlink" title="2018年计划"></a>2018年计划</h2><p>放了3天假，前两天睡到太阳落山，然后就来到了2018年7月1号。<br>起床后摸着头想想，是应该给自己做个计划的。我一直都是个很好的执行者，基本计划的事都会做到，当然我基本没给自己什么计划，所以才能演变到现在这样。但不可否认的是我还有点优点 – 耐心，自控，而刚好这两个优点是我现在急需要到且我认为我能加以利用的。<br>先给个大概的目标吧。</p>
<p><strong><em>成为一个中级工程师，前往高级工程师的路上。</em></strong></p>
<h3 id="细致计划"><a href="#细致计划" class="headerlink" title="细致计划"></a>细致计划</h3><p>（可能有补充）</p>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">目标</th>
<th style="text-align:center">是否完成</th>
</tr>
</thead>
<tbody>
<tr>
<td>《鸟哥的Linux私房菜》</td>
<td style="text-align:right">看完这本基础版，熟练掌握Linux系统，多使用命令</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>编写一个商城类App</td>
<td style="text-align:right">重点学习架构知识，以及如何更好地使用github上的优质项目</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>每周至少看两篇博文</td>
<td style="text-align:right">了解其他人如何学习，学习博文内容，了解Android版本的更新情况</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>每周至少去一次书店看书</td>
<td style="text-align:right">在埋头专业知识之余，不应该放弃修养</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>重新看《Android开发艺术探索》</td>
<td style="text-align:right">能否无压力理解所有内容，这本书是中级工程师的一个判断点</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>重新学习源码设计模式</td>
<td style="text-align:right">熟悉Android某些模块源码，整理看源码的技巧和注意事项，前往高级工程师的路上，记得要啃透它</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>购买《Android内核剖析》</td>
<td style="text-align:right">这本书是高级工程师必看的书，先计划住</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>强化架构思想</td>
<td style="text-align:right">总结多种架构方式，形成自己的架构思想，例子是最重要的</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="初版写于2018-1-1"><a href="#初版写于2018-1-1" class="headerlink" title="初版写于2018.1.1"></a>初版写于2018.1.1</h4><h4 id="二次修改写于2018-7-1"><a href="#二次修改写于2018-7-1" class="headerlink" title="二次修改写于2018.7.1"></a>二次修改写于2018.7.1</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[荒上鸿]]></title>
      <url>http://yoursite.com/2018/05/01/%C2%96%E8%8D%92%E4%B8%8A%E9%B8%BF/</url>
      <content type="html"><![CDATA[<hr>
<p>平静，或许沉浸在这个本该纷乱的世界太久，一声马啸，便乱了山河的规划，战火如雨落满整个版图。任谁，也无法用逃避来躲过头顶上的灾难。<br>烟火四起的荒原上本就不应该出现任何一种生命，然而孤独的鹰，却偏偏在打乱本该正常的平衡，为萧索的血色，添上几分慌忙。</p>
<p>一声马嘶，引着随后的千万铁骑，马蹄声似乎要震裂这个混沌天地。他们带着生命来，到底要带走生命。可是这片荒原，从来只接受滚烫的血液与冰冷的灵魂。<br>黑胡子长嘶，千人的军队竟在一瞬间止住了极速前行的步伐。本来的震耳惊雷，眨眼间消失无踪。<br>军队的前方是一个柔弱女子，在寒风冷冽中早已瑟瑟发抖，不属于该年纪的惨白头发如盘丝缠绕，空洞的两眼似是看不见前方。但，又好似看透了人世，再不愿用自己的双眼去仔细端详。<br>阵前将军铁甲遮面，面对一个女子，却无半点轻敌之意，更无怜悯之心。一双鹰般眼睛任铁甲再厚也挡不住它的锐利而深沉。<br>“为何，挡住我等？”<br>恐怖的安静已经持续了一个时辰，终于，一句疑问，让所有的人都吐了口气。<br>“将军此去，恐怕再无归路。”淡漠的语言从女子口中说出，莺莺之声更是令人心生怜意。<br>怎奈，将军本是无情人，又怎会领会怜字，“当我去者，杀！”<br>何等威武。<br>剑已拔，弓已张。昏黑的天色也无法掩盖将军血腥的双眼。千骑齐出，如山塌雪崩，然移动之际，也未见谁快慢半履。令六国胆寒的秦国火骑兵，不管面对的敌人是弱是强，都只有一个眼神，坚决。<br>“为何，要如此。”<br>为何？又有谁会去回答这一句刚一出口便飘逝在空中的问语。<br>女子颤抖的手摘下束发的长丝巾，任由它在寒风中飞扬。<br>曾经为你恨生白发，今日为你血流成河。<br>为何，平凡的爱要去阻挡国恨家仇？<br>为何，既然恨，还是不忍你走向绝路？</p>
<p>丝巾在风中伸、收、折、展。柔弱处如彩蝶戏花，娇怒时如索命无常。此时的魔鬼阴爪，一颦一笑间一人命。也唯有那漫天的白发，如同水银在月色下一泻千里，冰冷的笑容定格在空中依旧沁人心脾。</p>
<p>都说了这平原从来只收人命，偏偏有人不信。<br>也行血腥的不止是将军，还有这无奈的烟火。<br>冰冷的汗水已经渗出冰冷的面具，冰冷的冬风冻结了他冰冷的心。他，恐怕也只能用冰冷来形容了。</p>
<p>剑已出鞘，又何须多言。<br>只有一匹发疯了的马，发疯地奔出这片又无半点生机的荒原。<br>夜晚，又归于平静。</p>
<p>两个月，两个月的时间足以用来编织无尽的谎言。<br>秦军最强骑军的无故灭亡，至少需要一个理由来解释，或者是掩盖。而刚刚好，朝堂之上，最不缺乏的，就是落井下石。<br>两个月，几乎所有人都开始相信，将军白起，利欲熏心，坑杀所部千人，投降楚国。<br>谎言千遍，便成真理。</p>
<p>当一个遍体鳞伤又高傲不凡的人出现在街头，昔日的无限荣光已变成肮脏不堪，刚刚的英雄已成为被人唾弃的叛徒。人性的多变才渐渐伸出头角，为以往的错误低头寻找合适的借口。只是过去的总归是过去，现在找不到的，是昔日的热血。<br>世间多情，而又无情，明明多他一个精彩，偏偏少了他也无所谓。昨日还在煮酒共烹豪言天下，今夕杯冷茶凉，剩下枯树落叶还笑谈，烟雨冷淡，问君是否心寒。</p>
<p>执笔，忘了落下，满心的忠诚肝胆，却书写不出一段惊天动地的回肠。</p>
<p>秦楚之战，早该发生，拖延了这么久，有多少生命得以在暴风雨前喘上一口气。谁能想明白，是什么理由，可以拥有主宰人生的权利。<br>秦军惨败，无故白起也遭祸其中。<br>秦王三日降旨，白起仕楚二月，致秦伐楚不胜，念其前功，当赐剑。</p>
<p>兴许有人会悲痛，但喜悦的人更多。秦王屠戮四方，何时尝到如此失败的滋味。人一旦做错了事，第一反应总是去找借口，平民如此，君王亦是。<br>每个人都逃不了当棋子的命运。君要臣死，臣不得不死，臣便是棋子。天地以万物为刍狗，君，也不过是上天控制万物的棋子罢了。</p>
<p>“你真该走。”<br>女子从帘中走出，落寞的眼神随着白起的决定更加忧愁。<br>“为何？”<br>一句为何，却等不到下文。</p>
<p>若能一席蓑衣，垂钓河间，一生荣耀，为何舍不得？<br>只可惜，当穿上这身战甲，便已定下这胯下战马只能前进的方向。<br>若剑不能驰骋沙场，主宰在乱世之间，那么用它来完结这不属于自己的灵魂可否？<br>也许，见不到慌乱，心自安宁。</p>
<p>秦王再赐剑。<br>剑既然不再上战场杀敌，也不能让它生锈。</p>
<p>白起的身体缓缓落下，冰冷的眼睛现在才开始慢慢融化，直到看到了眼前这个人，不属于他的微笑，悄悄爬上唇边。<br>“早知如此，当初为何？”<br>原来世间的所有，都可以来问个为何，只是她再也得不到答案，也不需要答案，因为答案，一点也不重要。<br>但剑吻上颈间，所有的不甘也该归于平凡，是人又能如何，有时还不如一只畜生快活，来得糊涂，去也糊涂。</p>
<p>“我固当死，长平之战，赵卒降者数十万，我诈而尽坑之，是足死矣。”<br>是，在闭上眼睛的那一刹那，我也找到了一个理由，充当可以让我安详离开的借口。</p>
<p>一颗眼泪终于从她瘦弱的脸庞上滴下，看出她的疲倦，却看不到她的心伤。活着，你不看我一眼，死了，为何又闭上眼睛。<br>眼泪滴落到地，溅起了古远的记忆。<br>那时你方年少，我还芳龄，你我隔着浣衣的小溪相望。<br>那时你素衣长裙，我手执残卷，谈笑间时光西流。<br>到了何时的片段，明月何处，为何只照亮你独自离去的背影。<br>眼中的一滴泪水，唤起了翩翩惊鸿，为何却留不住弹指一挥间的奈何。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux(2) -- Linux系统开机过程问题排解及关机方法]]></title>
      <url>http://yoursite.com/2016/11/05/Linux-2-Linux%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E8%A7%A3%E5%8F%8A%E5%85%B3%E6%9C%BA%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="1-正确的关机方法"><a href="#1-正确的关机方法" class="headerlink" title="1 正确的关机方法"></a>1 正确的关机方法</h2><p>Linux的关机不像Windows那般随意，可以直接按电源键几秒就关掉算了。<br>Linux如果不正常关机，有可能造成文件系统的损毁 – 因为在关机时如果不是按照正常的服务关闭流程的话，有些数据可能来不及写入到文件中，从而这些服务文件可能会出现问题。</p>
<p>几个关机的命令：<br><strong>（只有root账号才能进行例如shutdown、reboot等命令）</strong></p>
<ul>
<li>sync: 同步数据到磁盘</li>
<li>shutdown: 常用的关机命令 </li>
<li>reboot/halt/poweroff: 重启、关机命令</li>
</ul>
<h3 id="1-1-数据同步到磁盘：sync"><a href="#1-1-数据同步到磁盘：sync" class="headerlink" title="1.1 数据同步到磁盘：sync"></a>1.1 数据同步到磁盘：sync</h3><p>计算机在运行的时候，所有的数据都要被读取到内存中，才能被CPU处理。处理完后又会被存回磁盘中。在内存和磁盘中，磁盘的读写速度显然是比较慢的，如果一直都在磁盘上进行读写操作，那么计算机的性能肯定是没有那么优秀的。<br>Linux为了解决这个问题，在默认的情况下，某些已经加载到内存中的数据就不会被写回磁盘中，通过暂存在内存中的方式，让你在重新操作该数据的时候，能直接从内存中取出，在速度上就能提升不少。<br>但是，问题也就出在这里，如果因为不正常关机而未在关机之前把内存中的数据写回磁盘中，就有可能造成数据的丢失。<br>所以，在关机之前多执行几次sync命令肯定没错的。</p>
<h3 id="1-2-常用关机命令：shutdown"><a href="#1-2-常用关机命令：shutdown" class="headerlink" title="1.2 常用关机命令：shutdown"></a>1.2 常用关机命令：shutdown</h3><p>shutdown这个命令会通知系统中的所有进程，并通知关闭系统中的run level内的一些服务。<br>shutdown可完成的工作：</p>
<ul>
<li>可以自由选择关机模式：关机、重启或进入单用户操作模式</li>
<li>可以设置关机时间</li>
<li>可以自定义关机的通知信息</li>
<li>可以仅仅发出警告信息</li>
<li>可以选择是否使用fsck检查文件系统</li>
</ul>
<p>shutdown的option参数参考：<br>root@www ~: shutdown [OPTION]… TIME [MESSAGE]<br>-r     系统服务停止之后重启。<br>-h     将系统服务停掉之后关机。<br>-H     将系统服务停掉之后关机。（使用halt命令关机）<br>-P     将系统服务停掉之后关机。（使用power off命令关机）<br>-c     取消正在进行的关机操作。这个选项没有option参数。<br>-k     只传递警告信息给所有用户，并不执行关机操作。</p>
<p>例子：<br>root@www ~:shutdown -h now<br>    现在就关机<br>root@www ~:shutdown -h 20:25<br>    在20:25这个时间点关机<br>root@www ~:shutdown -h +10<br>    10分钟后关机<br>root@www ~:shutdown -r now<br>    立即重启<br>root@www ~:shutdown -r +30 “the system will reboot after 30 min”<br>    系统在30分钟后重启并提供警告信息<br>root@www ~:shutdown -k now “the is the message with shutdown”<br>    发出警告信息，但并不关机</p>
<p>（注意：时间参数比较加入，不然shutdown命令会自动跳到run-level 1的模式下（单用户维护的登录情况））</p>
<h3 id="1-3-重启、关机：reboot、halt、poweroff"><a href="#1-3-重启、关机：reboot、halt、poweroff" class="headerlink" title="1.3 重启、关机：reboot、halt、poweroff"></a>1.3 重启、关机：reboot、halt、poweroff</h3><p>shutdown实际上是调用init 0, init 0会清理一些服务，然后再调用halt或者poweroff。<br>halt和poweroff的主要区别，在没有没有acpi的系统上，halt只是关闭了系统，而没有关闭电源，必须手动关闭电源，而poweroff会发送一个关闭电源的信号给acpi。<br>而在现在的系统中，这些命令基本就都一样了。<br>更建议使用init 0来关机。</p>
<h3 id="1-4-切换执行等级：init"><a href="#1-4-切换执行等级：init" class="headerlink" title="1.4 切换执行等级：init"></a>1.4 切换执行等级：init</h3><p>init改变的就是run-level，主要有7中等级模式<br>| Run Level      | 描述   |<br>| ——–   | —–:  |<br>|  0     | 关机 |<br>|  1     | 单用户模式 |<br>|  2     | 多用户模式，但无网络连接 |<br>|  3     | 多用户模式，纯命令行模式 |<br>|  4     | 用户自定义 |<br>|  5     | 多用户模式，图形界面模式 |<br>|  6     | 重启 |<br>如何来切换模式呢？<br>可以使用init这个命令，例如，关机可以使用init 0来替代。</p>
<h2 id="2-开机过程的问题排解"><a href="#2-开机过程的问题排解" class="headerlink" title="2 开机过程的问题排解"></a>2 开机过程的问题排解</h2><h3 id="2-1-文件系统出现错误"><a href="#2-1-文件系统出现错误" class="headerlink" title="2.1 文件系统出现错误"></a>2.1 文件系统出现错误</h3><p>文件系统损坏的原因一般有以下两个：</p>
<ul>
<li>因为断电或不正常关机所导致的文件系统发生错误。</li>
<li>硬盘使用率过高，或使用时的环境不良</li>
</ul>
<p>解决文件系统出现的错误一般要根据出错的扇区来排查。</p>
<h4 id="2-1-1-如果根目录没有损坏"><a href="#2-1-1-如果根目录没有损坏" class="headerlink" title="2.1.1 如果根目录没有损坏"></a>2.1.1 如果根目录没有损坏</h4><p>假如坏的分区是/dev/sda7，那么操作步骤如下：</p>
<ul>
<li>在开机时，屏幕显示“press root password or ctrl+D”，此时输入root密码，进行单用户模式维护工作。</li>
<li>输入“fsck /dev/sda7”，此时开始检测sda7分区的错误，并在屏幕上显示正在修复硬盘的信息，如果发现错误，就会显示“clear [Y/N]?”，直接输入Y。</li>
<li>修复完成后，直接重启。<h4 id="2-1-2-如果根目录坏了"><a href="#2-1-2-如果根目录坏了" class="headerlink" title="2.1.2 如果根目录坏了"></a>2.1.2 如果根目录坏了</h4>只能将该硬盘拔出，接到另一台Linux系统的计算机上，并且不要挂载该硬盘。然后以root身份进入并执行“fsck /dev/sdb1”。<br>为什么是/dev/sdb1？<br>因为这个损坏的硬盘接入到其他计算机中，就充当了第二个硬盘，所以编号是sdb，而其根目录是在第一个分区中的，所以为sdb1。<h4 id="2-1-3-如果硬盘坏了"><a href="#2-1-3-如果硬盘坏了" class="headerlink" title="2.1.3 如果硬盘坏了"></a>2.1.3 如果硬盘坏了</h4>那就只能换硬盘了。</li>
</ul>
<h3 id="2-2-修改root密码"><a href="#2-2-修改root密码" class="headerlink" title="2.2 修改root密码"></a>2.2 修改root密码</h3><p>如果忘记了root的密码，其实不用重载系统，只需要使用单用户模式进入更改密码即可。具体步骤:<br>系统重启，读秒的时候按下任意键，按e进入grub编辑模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root (hd0, <span class="number">0</span>)</div><div class="line">kernel /vmlinuz-<span class="number">2.6</span>.18-<span class="number">128</span>.e15 ro root=LABEL=/ rhgb quiet</div><div class="line">initrd /initrd-<span class="number">2.6</span>.18-<span class="number">128</span>.e15.img</div></pre></td></tr></table></figure></p>
<p>在kernel那一行后面按下e，添加“single”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kernel /vmlinuz-<span class="number">2.6</span>.18-<span class="number">128</span>.e15 ro root=LABEL=/ rhgb quiet single</div></pre></td></tr></table></figure></p>
<p>按下【Enter】键，再按下b就可以开机进入单用户模式。此时只需要输入“passed”来修改密码即可：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@www ~]# passwd</div></pre></td></tr></table></figure></p>
<p>按enter后系统提示要输入两次密码，即可修改成功。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux（1）-- 磁盘分区]]></title>
      <url>http://yoursite.com/2016/11/03/Linux-1-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<hr>
<p><strong>在linux系统，所有的设备都是文件。</strong></p>
<hr>
<h2 id="磁盘的种类"><a href="#磁盘的种类" class="headerlink" title="磁盘的种类"></a>磁盘的种类</h2><p>现在磁盘接口的种类主要有IDE接口和SATA接口，其中SATA接口比较主流，而IDE接口依然还会存在于较多的老主机上。</p>
<h3 id="1-IDE接口"><a href="#1-IDE接口" class="headerlink" title="1 IDE接口"></a>1 IDE接口</h3><p>通常主机上有两个IDE接口，而每个IDE接口都可以连接两个IDE设备，所以一台主机总共可以连接4个IDE设备。</p>
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align:right">主设备Master</th>
<th style="text-align:center">从设备Slave</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE1</td>
<td style="text-align:right">/dev/hda</td>
<td style="text-align:center">/dev/hdb</td>
</tr>
<tr>
<td>IDE2</td>
<td style="text-align:right">/dev/hdc</td>
<td style="text-align:center">/dev/hdd</td>
</tr>
</tbody>
</table>
<h3 id="2-SATA接口"><a href="#2-SATA接口" class="headerlink" title="2 SATA接口"></a>2 SATA接口</h3><p>SATA接口对设备的文件名和IDE接口的命名方式不同，并不是顺序命名，而是根据Linux内核检测的磁盘的顺序。<br>也就是说，如果我们将两个SATA设备插入SATA1和SATA5接口，一个USB插入SATA2接口，那么：</p>
<ul>
<li>SATA1上设备的名称：/dev/sda</li>
<li>SATA5上设备的名称：/dev/sdb</li>
<li>SATA2上设备的名称：/dev/sdc</li>
</ul>
<h3 id="3-磁盘分区表"><a href="#3-磁盘分区表" class="headerlink" title="3 磁盘分区表"></a>3 磁盘分区表</h3><p><strong>磁盘的第一个扇面主要记录了两个重要的信息：主引导分区(MBR)和分区表。</strong><br>主引导分区：安装引导加载程序的地方<br>分区表：记录整个磁盘分区的信息</p>
<p>这里我们先讲磁盘分区表。<br>磁盘分区表由64bytes来表示，也就是8个字，可以分为4组，用来记录4个区段的开始和结束的柱面号码。<br><img src="/img/linux_1/p1.png" alt="磁盘分区表的作用示意图"><br>例如我们把该磁盘的大小假设为只有400个柱面，如上图所示。<br>黑色块表示磁盘分区表，只有64bytes，里面记录着后面4个分区的柱面号码。<br>这4个分区名字如下：<br>/dev/hda1<br>/dev/hda2<br>/dev/hda3<br>/dev/hda4</p>
<p><strong>重点：</strong></p>
<ul>
<li>分区就是根据磁盘分区表中的记录来设置的</li>
<li>磁盘默认只能写入4个分区的信息</li>
<li>这4个分区信息称为主分区(Primary)和扩展分区(Extended)</li>
<li>分区的最小单位为柱面</li>
</ul>
<h3 id="4-扩展分区与逻辑分区"><a href="#4-扩展分区与逻辑分区" class="headerlink" title="4 扩展分区与逻辑分区"></a>4 扩展分区与逻辑分区</h3><p>由上面的知识我们知道，第一个扇区的磁盘分区表只能记录4个分区信息，所以我们只能分出4个分区出来。<br>但有时我们希望能分出更多的分区，该怎么办？<br>这时就要用到扩展分区，使用额外的扇区来记录分区信息，从而将扩展分区切出多个逻辑分区。<br><img src="/img/linux_1/p2.png" alt="扩展分区和逻辑分区示意图"><br>如上图所示，第一个扇区的分区记录表只分出两个分区：主分区和扩展分区。<br>而扩展分区的额外扇区里又拥有一个分区记录表，这个记录表不只64bytes那么大了，其中记录了5个分区的信息，这些分区称为逻辑分区，是由扩展分区切出来的。<br>所以上图的各个分区的设备名称如下：</p>
<ul>
<li>/dev/hda1</li>
<li>/dev/hda2</li>
<li>/dev/hda5</li>
<li>/dev/hda6</li>
<li>/dev/hda7</li>
<li>/dev/hda8</li>
<li>/dev/hda9</li>
</ul>
<p>可以看出，其中没有hda3、hda4，那是因为hda3、hda4默认留给Primary或Extended分区使用，如果没有分出那么多的Primary或Extended分区，这留空等待有的时候可以使用。也就是说，逻辑分区的名称都是从5开始的。(以上内容适用于SATA类型磁盘)</p>
<p><strong>重点：</strong></p>
<ul>
<li>主分区和扩展分区总共只能有4个</li>
<li>扩展分区只能有一个，主分区可以有多个(最多3个)</li>
<li>逻辑分区是由扩展分区切割出来的</li>
<li>主分区和逻辑分区都可以格式化，而扩展分区不能格式化</li>
<li>IDE磁盘最多可以切出59个逻辑分区(5 - 63)，而SATA磁盘最大只能切出11个逻辑分区(5 - 15)</li>
</ul>
<h3 id="5-磁盘分区模式"><a href="#5-磁盘分区模式" class="headerlink" title="5 磁盘分区模式"></a>5 磁盘分区模式</h3><p>磁盘分区最常见的有两种模式：</p>
<ul>
<li>P-P-P-E</li>
<li>P-E</li>
</ul>
<p>这两种模式的环境如图：<br><img src="/img/linux_1/PPPE.gif" alt="PPPE"><br><img src="/img/linux_1/PE.gif" alt="PE"></p>
<h3 id="6-主引导分区-开机流程"><a href="#6-主引导分区-开机流程" class="headerlink" title="6 主引导分区(开机流程)"></a>6 主引导分区(开机流程)</h3><p>先说两个知识点：<br>BIOS：是一个写入到主板上的一个韧体，也就是写入到硬件上的一个软件程序，在开机的时候计算机系统会主动执行它。<br>COMS：记录各项硬件参数且嵌入到主板上面的存储器。</p>
<p>开机流程：</p>
<ol>
<li>BIOS：开机主动执行的韧体，会去认识第一个可开机的设备(MBR)</li>
<li>MBR：第一个可开机设备的第一个扇区内记录的主引导分区，里面包含引导加载程序</li>
<li>引导加载程序(Boot loader)：一个可读取内核文件来执行的软件</li>
<li>内核文件：开始操作系统的功能</li>
</ol>
<p>MBR只有446bytes这么大，所以其中的引导加载程序非常小，也近乎完美。<br>Boot loader的主要任务如下：</p>
<ul>
<li>提供菜单：用户可以选择不同的开机选项</li>
<li>载入内核文件：直接指向可开机的程序区段</li>
<li><p>转交给其他Boot loader：交给其他分区的引导加载程序去执行</p>
<p>了解上面的3个任务后再来理解。<br><img src="/img/linux_1/p3.gif" alt="引导程序的工作示意图"><br>举个例子，如上面的图所示，MBR的引导加载程序启动后，会提供两个菜单项给我们选择，分别为M1,M2，其中M1指向Windows系统，而M2指向Linux系统。<br>如果我们选择M1，则直接加载Windows的内核文件，就可以进行开机。而如果选择的是M2，引导加载程序会转交给第二个分区的引导加载程序(第二个分区是Linux系统)，第二个引导加载程序启动后，里面只有一个开机菜单项，就是Linux系统，因此使用Linux的内核文件来开机。</p>
</li>
</ul>
<h3 id="7-挂载"><a href="#7-挂载" class="headerlink" title="7 挂载"></a>7 挂载</h3><p>Linux的所有数据都是以文件的形式存在，所以Liux系统以目录树结构的形式来规范这些文件。<br><strong>根目录(“/“)</strong>：所有的文件都和根目录相关。<br>例如：<br>/dev<br>/etc<br>/home/dmtsai</p>
<p>我们都知道，数据实际是放置到磁盘中的，但我们需要以更可观的形式来看到这些数据，也就需要处理一个问题：目录树的架构与磁盘内的数据如何关联起来。<br>这就引入了一个概念 – <strong>挂载</strong></p>
<p><strong>挂载就是利用一个目录为进入点，将磁盘分区放置到该目录下面。<br>此时进入该目录，就是在读取该磁盘中的数据。</strong><br>整个放置过程我们称为挂载，而这个目录，我们称为挂载点。<br><img src="/img/linux_1/p4.png" alt="目录树与磁盘分区之间的关系"><br>如上图所示，分区1挂载到根目录“/”下面，而分区2挂载到”/home”目录下，那么如果我们要把数据存放到/home目录下时，如上图，创建一个test文件，则该数据会写入到分区2中去。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对象的创建与销毁注意事项（二）]]></title>
      <url>http://yoursite.com/2016/10/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr>
<p>上一篇主要讲了一些创建对象的方法，那么这一节，主要讲的就是在创建对象的时候需要注意的事情，以及如何销毁对象。</p>
<hr>
<h2 id="1-避免创建不必要的对象"><a href="#1-避免创建不必要的对象" class="headerlink" title="1 避免创建不必要的对象"></a>1 避免创建不必要的对象</h2><p>但我们已经创建了一个对象，又想创建该对象的时候，我们就要问，这两个对象的功能是一样的吗，如果一样，我们为什么要去重新创建它呢？</p>
<blockquote>
<p>Effective Java：最好能重用对象而不是在每次需要的时候就创建一个相同功能的对象。</p>
</blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>判断该时间是否在某个时间段之间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTool</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Date time;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBetween</span><span class="params">()</span></span>&#123;</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        </div><div class="line">        cal.set(<span class="number">1999</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        Date start = cal.getTime();</div><div class="line">        cal.set(<span class="number">2017</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        Date end = cal.getTime();</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> time.compareTo(start) &gt;= <span class="number">0</span> &amp;&amp; </div><div class="line">                time.compareTo(end) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，当我们每次调用isBetween()方法的时候，都会去创建两个新的Date对象和一个新的Calendar对象。如果我们调用成千上万次，那么这些对象就要被创建成千上万次，这是相当没效率的做法。<br>根据“相同功能重用”的原则，我们应该将这个方法里不变的对象抽取出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTool</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Date time;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.set(<span class="number">1999</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        start = cal.getTime();</div><div class="line">        cal.set(<span class="number">2017</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        end = cal.getTime();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBetween</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> time.compareTo(start) &gt;= <span class="number">0</span> &amp;&amp; </div><div class="line">                time.compareTo(end) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里将不变的两个Date对象start和end声明为final，并在static块中初始化，这样，不管我们调用多少次isBetween()方法，这些Date对象都只会执行一次。<br>那么你可能会有疑问，如果我们调用这个类的其他方法呢，这两个Date对象一样会去实例化，这是不是就降低效率了？<br>没错的，只要调用了这个类，就会去实例化这两个Date对象，但是，我们只能去取舍，在多次被调用或可能会被多次调用的情况下，我们都要去优化对象的创建。</p>
<hr>
<h2 id="2-消除过期的对象引用"><a href="#2-消除过期的对象引用" class="headerlink" title="2 消除过期的对象引用"></a>2 消除过期的对象引用</h2><p>Java提供了垃圾回收机制，但这并不意味这我们就不需自己来管理内存和对象。</p>
<h4 id="问题Demo"><a href="#问题Demo" class="headerlink" title="问题Demo"></a>问题Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> (T)(elements[--size]);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是一个自定义栈的出栈方法pop()，我们会将所有的元素存放在elements中，而size代表的是栈中元素的数量。<br>在这里我们应该可以看出上面这段代码的问题，我们的所有元素是放在elements数组中的，而栈中的元素其实只是elements的一个子集。<br>因为当我们执行pop操作的时候，我们只是将size自减，返回elements中的某一个元素，只要我们管理的size不会出错，这个程序就不会出错。但，其实，当我们执行pop的时候，elements中的元素并没有变化，也就是说，当我们pop的时候，从elements中取出来的元素并没有被垃圾回收，而我们也不会再使用这些对象。<br>这就是我们经常听到的，“过期引用”。<br>这种内存泄漏是很隐蔽的，很难被发现，所以当我们在编写这类由类自己管理多对象存储的时候，需要相当小心。<br>而当我们发现这类的问题的时候，解决并不难。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        T t = (T)(elements[--size]);</div><div class="line">        elements[size] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="３-终结方法-–-避免使用"><a href="#３-终结方法-–-避免使用" class="headerlink" title="３ 终结方法 – 避免使用"></a>３ 终结方法 – 避免使用</h2><p>在Java中，当一个对象变为不可达的时候，垃圾回收器会回收这个对象相关的存储空间。<br>但Java还是提供了终结方法，然而却没有保证该方法能被及时地执行，甚至是不保证能够被执行。<br>所以我们在对资源或是锁机制等的处理，都不应该去依赖终结方法来更新重要的持久性状态。</p>
<p>那么我们该怎么来释放我们的资源或终止某些操作呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//do something ...</span></div><div class="line">&#125; <span class="keyword">finally</span>&#123;</div><div class="line">    <span class="comment">//释放资源或释放锁等操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[对象的创建与销毁注意事项（一）]]></title>
      <url>http://yoursite.com/2016/10/15/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="1-使用静态方法来创建对象"><a href="#1-使用静态方法来创建对象" class="headerlink" title="1 使用静态方法来创建对象"></a>1 使用静态方法来创建对象</h2><p>类可以提供一个公有的静态方法来返回一个类的实例。<br>这个静态方法绕过了构造方法来创建对象。<br>在Effective Java中强烈推荐的一种创建对象的方式。</p>
<h4 id="常用静态方法命名："><a href="#常用静态方法命名：" class="headerlink" title="常用静态方法命名："></a>常用静态方法命名：</h4><blockquote>
<ul>
<li>valueOf(): 该方法返回的实例的值与它传入参数的值是相同的。<br>  例如String.valueOf(1):将int类型的值“1”转换为string类型“1”</li>
<li>getInstance(): 是通过其传入的参数来确定其实例。<br>  主要应用在单例设计模式中。通过getInstance(var )来调用该类的构造方法（有参或无参）</li>
<li>newInstance(): 类似于getInstance()方法，但它每次调用时创建的对象都不同，这就是与getInstance()的区别。</li>
<li>getType(): 如果该静态方法和要创建的对象的类并不是同一个类，那么就使用它来替代getInstance()<br>  例如在Demo类中声明了getType()方法，要在getType()创建一个User对象，那么就可以使用getType()<br>  这里需要注意的是，getType()同样是应用于单例设计模式中。</li>
<li>newType(): 类似于getType()，其作用相当于newInstance()之于getInstance()。</li>
</ul>
</blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h3 id="1-1-getInstance"><a href="#1-1-getInstance" class="headerlink" title="1.1 getInstance()"></a>1.1 getInstance()</h3><p>该方法主要在单例设计模式中呈现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExampleClass sInstance;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleClass</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleClass</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.num = number;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sInstance = <span class="keyword">new</span> ExampleClass();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ublic <span class="keyword">static</span> ExampleClass <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sInstance = <span class="keyword">new</span> ExampleClass(number);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-newInstance"><a href="#1-2-newInstance" class="headerlink" title="1.2 newInstance()"></a>1.2 newInstance()</h3><p>这个方法与getInstance()作用差不多，只不过它所创建的对象并不是唯一的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExampleClass sInstance;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleClass</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleClass</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.num = number;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleClass <span class="title">newInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleClass();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ublic <span class="keyword">static</span> ExampleClass <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExampleClass(number);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-getType"><a href="#1-3-getType" class="headerlink" title="1.3 getType()"></a>1.3 getType()</h3><p>这个方法与getInstance()作用差不多，但是它和要创建对象所属的类并不在同一个类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExampleClass sInstance;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleClass</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleClass</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.num = number;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExampleClass sExInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExampleClass <span class="title">getExampleClass</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(sExInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(sExInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sExInstance = <span class="keyword">new</span> ExampleClass();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sExInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExampleClass <span class="title">getExampleClass</span><span class="params">(fianl</span></span></div><div class="line">                    <span class="keyword">int</span> number)&#123;</div><div class="line">        <span class="keyword">if</span>(sExInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(sExInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sExInstance = <span class="keyword">new</span> ExampleClass(number);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sExInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-4-newType"><a href="#1-4-newType" class="headerlink" title="1.4 newType()"></a>1.4 newType()</h3><p>这newType()方法就是在getType()方法的基础上，让其返回的是一个不唯一的对象即可。代码省略。</p>
<blockquote>
<p>这里在参数和方法方面都尽量使用了 <strong>fianl</strong>来修饰，是因为final可以保证该方法或参数不会被随意地更改或重写，同时在编译的时候虚拟机会对final类型的参数和方法进行性能的优化。<br>所以强烈建议，应尽可能地使用final来修饰。</p>
</blockquote>
<hr>
<h2 id="2-构造器有多个参数-–-使用建造者模式"><a href="#2-构造器有多个参数-–-使用建造者模式" class="headerlink" title="2 构造器有多个参数 – 使用建造者模式"></a>2 构造器有多个参数 – 使用建造者模式</h2><p>面对无参或只有少数参数的构造器的时候，我们建议使用静态方法来创建对象。那如果该构造器有多个参数呢，使用原生的构造方法或静态方法来创建对象都是灾难性的。你应该试过每次构建对象的时候都要一个参数一个参数地对比着填入，这样都还经常填错顺序。<br>这种时候，建造者模式的使用，就再合适不过了。</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><blockquote>
<ul>
<li>为什么不能使用多参数构造方法？</li>
<li>为什么不使用setter()的形式来导入参数？</li>
</ul>
</blockquote>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><blockquote>
<ul>
<li>多参构造器是可以使用的，在Android源码中随处可见。<br>但是并不推荐，首先是其可读性较低，读者很难知道该参数代表的是什么类型，其意义是什么。并且在调用者眼里，这就是灾难性的，每次调用要去阅读大量的文档来认识每一个参数的意义和用法。最后在API提供者眼里，也是特别麻烦的，如果要求传入参数的个数不同而创建不同的对象，那么就需要重写多个构造器。所以说，尽管这种方法可用，但我们并不推荐。</li>
<li>先创建一个无参构造方法，然后使用setter形式来传入参数。这种JavaBean的形式在某些功能上相当受欢迎，例如在修改个人信息的功能上，我们可以通过setter方法来修改某一个信息。当这个便利性也为它创造了一个局限性–可修改。<br>对于构造一个对象，我们应该希望能在一个调用过程中完成，而不是分成多个调用过程。例如使用setter来传递参数，那么构建一个完整的对象，就需要多次调用setter方法，在这个过程中，对象是处于一个不一致的状态。如果我们在创建过程中去调用它，那么将会失败，而且这种失败并不想包含错误代码的错误那么简单可以调式的。所以在构建对象上面，我们也不推荐setter形式。</li>
</ul>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<p>当然，解决方案肯定是有的，那就是使用建造者模式 – Builder<br>这个模式刚好完美地结合了构造方法的安全性，和setter方法的可读性。</p>
</blockquote>
<h3 id="2-1-Builder解读"><a href="#2-1-Builder解读" class="headerlink" title="2.1 Builder解读"></a>2.1 Builder解读</h3><p>Builder并不会直接去生成一个的对象，而是让调用者先传入所有必要的参数(吸取setter方法的优点)，每次传入参数都会返回一个Builder对象，所以可以使用链式方式来传参(传统的Builder模式和Android源码中使用的Builder在创建形式上有所不同，在这里使用的是更为可读的Android中的Builder模式)。<br>等待所有的参数都传入完毕后，再根据这个Builder对象来生成我们想要的对象。</p>
<h3 id="2-2-Demo"><a href="#2-2-Demo" class="headerlink" title="2.2 Demo"></a>2.2 Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String password;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sex;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String phone;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(Builder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = builder.name;</div><div class="line">        <span class="keyword">this</span>.password = builder.password;</div><div class="line">        <span class="keyword">this</span>.sex = builder.sex;</div><div class="line">        <span class="keyword">this</span>.age = builder.age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.password = password;</div><div class="line">        <span class="keyword">this</span>.sex = sex;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">password</span><span class="params">(String password)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.password = password;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sex</span><span class="params">(String sex)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.sex = sex;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(String age)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> User(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.phone = phone;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，Builder模式的编写是很烦躁的，因为为了一个Builder对象，我们需要写大量的东西，但是，对于可读性，可扩展性来说，这一切是值得的(当然我很希望有一个能快速编写Builder的工具)。<br>调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">User user = User.Builder()</div><div class="line">            .name(<span class="string">"John"</span>)</div><div class="line">            .password(<span class="string">"123456"</span>)</div><div class="line">            .sex(<span class="number">1</span>)</div><div class="line">            .age(<span class="number">18</span>)</div><div class="line">            .build();</div><div class="line">user.setPhone(<span class="string">"18812345678"</span>);</div></pre></td></tr></table></figure></p>
<p>它的调用是简洁且阅读是轻松的。</p>
<h3 id="2-3-建造者模式的有缺点"><a href="#2-3-建造者模式的有缺点" class="headerlink" title="2.3 建造者模式的有缺点"></a>2.3 建造者模式的有缺点</h3><p><strong>优点</strong></p>
<blockquote>
<ul>
<li>Builder模式可以在build()方法对传入的参数进行检验，而不用在每一个参数传入的时候去检验</li>
<li>Builder比之于构造方法，好在能拥有多个可变参数，而不用去写多个重载方法</li>
<li>在多线程中，Builder比Setter更加安全。</li>
</ul>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<ul>
<li>为了创建对象，必须先构建它的Builder构建器，这会降低一点点性能，当然如果对性能不是要求特别特别严厉的话，这个模式是优雅的</li>
<li>Builder模式在编写的时候比重载构造方法来要多代码，所以这里推荐，只有在参数多于或等于4个的时候，才去使用这个模式，不然，得不偿失。</li>
</ul>
</blockquote>
<hr>
<h2 id="３-单例设计模式之使用枚举类型或静态内部类"><a href="#３-单例设计模式之使用枚举类型或静态内部类" class="headerlink" title="３ 单例设计模式之使用枚举类型或静态内部类"></a>３ 单例设计模式之使用枚举类型或静态内部类</h2><p>Singleton，在Effect Java中的定义为：仅仅被实例化一次的类。<br>也就是说，这个Singleton类的对象，在整个项目中，我们的期望应该是唯一的。这就是我们所说的单例设计模式。<br>单例设计模式对于几乎所有的工程师而言，肯定是相当熟悉的。但是，往往因为它的简单，而被忽略了一些细节。</p>
<h3 id="3-1-Singlton的普通用法和问题"><a href="#3-1-Singlton的普通用法和问题" class="headerlink" title="3.1 Singlton的普通用法和问题"></a>3.1 Singlton的普通用法和问题</h3><p>我们在单线程中编写Singleton类，是相当简单的，而在多线程中编写，我们第一反应就是synchronized。但是，使用锁机制，就真的安全吗？<br>我们来看代码，并跟着流程走一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sInstance = <span class="keyword">new</span> Singleton();[@]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现有两个线程来创建这个Singleton对象，我们取名为ThreadA，ThreadB。<br>出现问题的步骤：</p>
<blockquote>
<p>step 1: ThreadA进入getInstance()方法，顺序执行到[@]处，但该实例化过程只执行了一半；<br>step 2: 此时ThreadB进入并占用了ThreadA，进入getInstance()方法，判断sInstance不为空，直接返回sInstance。<br>这个时候ThreadB所返回的Singleton对象是一个不完整的对象。</p>
</blockquote>
<p>所以说，即使使用了synchronized，也同样有可能不安全，那么应该怎么来写Singleton类呢？<br>Effective java提供了两种方法：静态内部类和枚举。</p>
<h3 id="3-2-静态内部类编写Singleton"><a href="#3-2-静态内部类编写Singleton" class="headerlink" title="3.2 静态内部类编写Singleton"></a>3.2 静态内部类编写Singleton</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Holder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-枚举编写Singleton"><a href="#3-3-枚举编写Singleton" class="headerlink" title="3.3 枚举编写Singleton"></a>3.3 枚举编写Singleton</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> SingletonCreator&#123;</div><div class="line">    INSTANCE;</div><div class="line">    </div><div class="line">    Singleton instance;</div><div class="line">    SingletonCreator()&#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>枚举类中的实例是被保证只被实例化一次的。所以INSTANCE也就只被执行一次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton singleton = SingletonCreator.INSTANCE.getInstance();</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-谨慎使用无构造方法的类"><a href="#4-谨慎使用无构造方法的类" class="headerlink" title="4 谨慎使用无构造方法的类"></a>4 谨慎使用无构造方法的类</h2><p>我们经常会使用到一些只有静态方法和静态域的类，例如我们常用的工具类。这种类其实并不是很优雅，名声也不太好。因为当你调用该类的时候，所有的静态方法和静态域都会被初始化到。<br>但并不是说就不能使用它，毕竟在作为工具类，将一类对象的相关方法组合起来，便于使用，它还是能工作得很好的。</p>
<p>我们来说当我们使用它的时候，需要注意什么。<br>首先，是该类的方法数量，我们应该尽可能地少，这样能在我们调用该类的时候提高它的性能。<br>其次，是它的构造方法，但我们没有写它的构造方法的时候，会默认给我们一个无参的构造方法，所以，为了避免我们在使用它的时候，不小心去实例化它，我们需要将它的构造方法给隐藏起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Tools</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在构造方法中抛出异常，是为了防止该类内部去实例化它。<br>private是为了防止其他类去实例化它。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android添加自定义图标或字体]]></title>
      <url>http://yoursite.com/2016/10/12/Android%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87%E6%88%96%E5%AD%97%E4%BD%93/</url>
      <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>使用自定义字体库，就是使用joanzapata提供的iconify项目，可进入该github：<br><a href="https://github.com/JoanZapata/android-iconify" target="_blank" rel="external">https://github.com/JoanZapata/android-iconify</a><br>可以看到该readme给出了下载的方法：<br>    compile ‘com.joanzapata.iconify:android-iconify-fontawesome:2.2.2’ // (v4.5)<br>    compile ‘com.joanzapata.iconify:android-iconify-entypo:2.2.2’ // (v3,2015)<br>    compile ‘com.joanzapata.iconify:android-iconify-typicons:2.2.2’ // (v2.0.7)<br>    compile ‘com.joanzapata.iconify:android-iconify-material:2.2.2’ // (v2.0.0)<br>    compile ‘com.joanzapata.iconify:android-iconify-material-community:2.2.2’ // (v1.4.57)<br>    compile ‘com.joanzapata.iconify:android-iconify-meteocons:2.2.2’ // (latest)<br>    compile ‘com.joanzapata.iconify:android-iconify-weathericons:2.2.2’ // (v2.0)<br>    compile ‘com.joanzapata.iconify:android-iconify-simplelineicons:2.2.2’ // (v1.0.0)<br>    compile ‘com.joanzapata.iconify:android-iconify-ionicons:2.2.2’ // (v2.0.1)<br>上面这些依赖都是一些有名的图标库，例如前端常用的fontawesome，天气图标weathericons等等。<br>我们只需要添加我们自己需要的库即可，以上一个或多个。</p>
<h3 id="问题：并没有看到上面哪个依赖是我们需要使用的iconify"><a href="#问题：并没有看到上面哪个依赖是我们需要使用的iconify" class="headerlink" title="问题：并没有看到上面哪个依赖是我们需要使用的iconify"></a>问题：并没有看到上面哪个依赖是我们需要使用的iconify</h3><p>这是因以上的这些依赖中，都会默认去依赖到iconify，这个可以进去github的项目中去看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    <span class="function">compile <span class="title">project</span><span class="params">(<span class="string">':android-iconify'</span>)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="1、创建自己的Application类"><a href="#1、创建自己的Application类" class="headerlink" title="1、创建自己的Application类"></a>1、创建自己的Application类</h3><p>自定义继承Application的类<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyApplication: Application()&#123;</div><div class="line">	override fun onCreate()&#123;</div><div class="line">		//该例子使用的是android-iconify-fontawesome:2.2.2这个依赖</div><div class="line">		Iconify.with(FontAwesomeModule())</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Application中调用Iconify的静态方法with()来添加字体库。</p>
<h4 id="问题：为什么要在Application中添加，而不是MainActivity中？"><a href="#问题：为什么要在Application中添加，而不是MainActivity中？" class="headerlink" title="问题：为什么要在Application中添加，而不是MainActivity中？"></a>问题：为什么要在Application中添加，而不是MainActivity中？</h4><p>因为在Application中添加，那么整个项目都可以使用到该字体库。</p>
<h4 id="注意：在AndroidManifest-xml中注册该Application的名字为MyApplication"><a href="#注意：在AndroidManifest-xml中注册该Application的名字为MyApplication" class="headerlink" title="注意：在AndroidManifest.xml中注册该Application的名字为MyApplication"></a>注意：在AndroidManifest.xml中注册该Application的名字为MyApplication</h4><h3 id="2、在xml文件中使用字体库"><a href="#2、在xml文件中使用字体库" class="headerlink" title="2、在xml文件中使用字体库"></a>2、在xml文件中使用字体库</h3><com.joanzapata.iconify.widget.icontextview android:text="{fa-search} spin" android:textsize="18sp" android:textcolor="#ff0000">

<p>“spin”：如果该字体或图标是动态的，那么就动态来显示该图标</p>
<h4 id="注意：这里的fa-search的“-”而不是-“-”"><a href="#注意：这里的fa-search的“-”而不是-“-”" class="headerlink" title="注意：这里的fa-search的“-”而不是 “_”"></a>注意：这里的fa-search的“-”而不是 “_”</h4><h2 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h2><p>如果在一些网站上看到比较好的图标，例如在fontawesome网站或阿里巴巴矢量图标库等，想要在项目中使用，那么，就需要自定义了。</p>
<h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h3><p>到fontawesome网站或阿里巴巴矢量图标库中下载：<br>fa开头    – FontAwesome图标库<br>icon开头 – 阿里巴巴矢量图标库<br>以阿里巴巴矢量图标库为例，下载完之后会有一个文件夹，该文件夹下有一些文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">demo_fontclass.html</div><div class="line">demo_symbol.html</div><div class="line">demo_unicode.html</div><div class="line">demo.css</div><div class="line">iconfont.css</div><div class="line">iconfont.eot</div><div class="line">iconfont.js</div><div class="line">iconfont.svg</div><div class="line">iconfont.ttf</div><div class="line">iconfont.woff</div></pre></td></tr></table></figure></p>
<p>在这里面，最主要的就是demo_unicode.html和iconfont.ttf这两个文件。<br>iconfont.ttf：这是下载下来的字体库，我们需要的就是这个文件<br>demo_unicode.html：用于查看每个图标对应的字符码</p>
<h3 id="2、自定义Icon类和IconFontDescriptor类"><a href="#2、自定义Icon类和IconFontDescriptor类" class="headerlink" title="2、自定义Icon类和IconFontDescriptor类"></a>2、自定义Icon类和IconFontDescriptor类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">enum</span> class <span class="title">MyFontIcons</span><span class="params">(val character: Char)</span>: Icon</span>&#123;</div><div class="line">	icon_back(<span class="string">'\ue624'</span>),</div><div class="line">	icon_close(<span class="string">'\ue625'</span>); </div><div class="line"></div><div class="line">	<span class="function">override fun <span class="title">key</span><span class="params">()</span>: String</span>&#123;</div><div class="line">		<span class="keyword">return</span> name().replace(<span class="string">'_'</span>, <span class="string">"-"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function">override fun <span class="title">character</span><span class="params">()</span>: Char</span>&#123;</div><div class="line">		<span class="keyword">return</span> character</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的\ue624就是从demo_unicode.html文件中查到的，在对应的图标下面有对应的字符码，例如“&amp;#xe624”，我们取去后4位，然后填上\u即可(\u表示unicode编码)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyFontModule: IconFontDescriptor&#123;</div><div class="line">	override fun ttfFileName(): String&#123;</div><div class="line">		//返回该ttf文件的文件名</div><div class="line">		return "iconfont.ttf"</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	override fun characters(): Array&lt;MyFontIcons&gt;&#123;</div><div class="line">		return MyFontIcons.value()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的characters()方法返回的是一个Icon类型的对象，但是要注意的是，在java中，返回值参数可以写为Icon[]，但在Kotlin中不能写为Array<icon>，而是写为Array<myfonticons></myfonticons></icon></p>
<h3 id="3、在Application添加字体库"><a href="#3、在Application添加字体库" class="headerlink" title="3、在Application添加字体库"></a>3、在Application添加字体库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iconify.with(FontAwesomeMudule()).with(MyFontModule())</div></pre></td></tr></table></figure>
<h3 id="4、xml使用"><a href="#4、xml使用" class="headerlink" title="4、xml使用"></a>4、xml使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;com.joanzapata.iconify.widget.IconTextView</div><div class="line">	android:text=<span class="string">"&#123;icon-back&#125;"</span></div><div class="line">	android:textSize=<span class="string">"18sp"</span></div><div class="line">	android:textColor=<span class="string">"#ff0000"</span>/&gt;</div></pre></td></tr></table></figure>
<p>Ok，到这里，字体图标库就合入到Android项目中，并且可以使用了。</p>
</com.joanzapata.iconify.widget.icontextview>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Socket通信]]></title>
      <url>http://yoursite.com/2016/09/27/Socket%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h2 id="Socket与Http"><a href="#Socket与Http" class="headerlink" title="Socket与Http"></a>Socket与Http</h2><p>说到Socket，就想到聊天室。对，Socket一个很大的优点就是聊天室的模式。同样都是网络通信，它与Http还是有很大的差别的：<br>    Http：请求 &lt;–&gt; 响应模式<br>    Socket：连接 –&gt; 直接进行数据交换</p>
<p><img src="/img/socket/socket1.png" alt="Http通信模式"></p>
<p>Http是先将客户端和服务端进行连接，然后由客户端发送请求，在服务端接收到请求之后进行逻辑处理，完毕之后返回响应给客户端。如果客户端没有发送请求，则服务端不会主动发送响应给客户端，即不会主动推送信息。</p>
<p><img src="/img/socket/socket2.png" alt="Socket通信模式"></p>
<p>Socket的客户端是通过ServerSocket与服务端进行连接的，只要连接得上，就可以直接进行通信，而不用等待请求什么的。</p>
<h2 id="Socket的使用"><a href="#Socket的使用" class="headerlink" title="Socket的使用"></a>Socket的使用</h2><p>Socket的使用虽然比较简单，但是其中有很多细节需要注意，一个不小心，就足以让你崩溃(我就是例子，弄了整整一天，换了不知多少种方式，到最后才发现问题，总是那么小)。</p>
<h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><p>先来编写一个服务端，这里服务端是使用Java代码来实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class MyServer&#123;</div><div class="line">	public static List&lt;Socket&gt; sockets = new ArrayList&lt;Socket&gt;();</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Exception&#123;</div><div class="line">		//这是服务端的ServerSocket，端口号为2121</div><div class="line">		ServerSocket ss = new ServerSocket(2121);</div><div class="line"></div><div class="line">		//通过循环来不断获取来自客户端的连接</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">			//在这里线程会阻塞，直到有客户端连接</div><div class="line">			Socket socket = ss.accept();</div><div class="line">			sockets.add(socket);</div><div class="line">			//每当有一个客户端连接，则开启一个线程来为客户端服务</div><div class="line">			new Thread(new ServerThread(socket)).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ServerThread implements Runnable&#123;</div><div class="line">	private Socket socket;</div><div class="line">	private BufferedReader br;</div><div class="line"></div><div class="line">	public ServerThread(Socket socket)&#123;</div><div class="line">		this.socket = socket;</div><div class="line">		br = new BufferedReader(new InputStreamReader(socket.getInputStream()));</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">		String line = null;</div><div class="line">		try&#123;</div><div class="line">			<span class="keyword">while</span>((line = br.readLine()) != null)&#123;</div><div class="line">				System.out.println(<span class="string">"FROM CLIENT: "</span> + line);</div><div class="line"></div><div class="line">				//向客户端发送信息</div><div class="line">				OutputStream os = socket.getOutputStream();</div><div class="line">				os.write(<span class="string">"I'm server\n"</span>.getBytes(<span class="string">"utf-8"</span>));</div><div class="line">			&#125;</div><div class="line">		&#125; catch(Exception e)&#123;</div><div class="line">			MyServer.sockets.remove(socket);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>Socket要作为List的泛型，只能改为SE5，这个Eclipse可以自动更改。</li>
<li>sockets的作用是为了让服务端可以向所有连接的客户端发送信息。</li>
<li>在服务端发送数据给客户端时记得使用\n，否则客户端没法收到信息，因为客户端也是使用BufferedReader来接收信息，这个流的特点在于每次都需要读到换行符才会读取结束。</li>
</ul>
<h4 id="1、如果你想不用添加-n这么麻烦的东西的话，你可以不用使用BufferedReader这个输入流"><a href="#1、如果你想不用添加-n这么麻烦的东西的话，你可以不用使用BufferedReader这个输入流" class="headerlink" title="1、如果你想不用添加\n这么麻烦的东西的话，你可以不用使用BufferedReader这个输入流"></a>1、如果你想不用添加\n这么麻烦的东西的话，你可以不用使用BufferedReader这个输入流</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">InputStream is = socket.getInputStream();</div><div class="line">byte[] bus = new byte[1024];</div><div class="line"><span class="keyword">while</span> (is.read(bus) != -1)&#123;</div><div class="line">	System.out.println(new String(bus, 0, bus.length));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、如果想向所有的客户端都发送信息-例如聊天室聊天-，则在向客户端发送信息处修改代码"><a href="#2、如果想向所有的客户端都发送信息-例如聊天室聊天-，则在向客户端发送信息处修改代码" class="headerlink" title="2、如果想向所有的客户端都发送信息(例如聊天室聊天)，则在向客户端发送信息处修改代码"></a>2、如果想向所有的客户端都发送信息(例如聊天室聊天)，则在向客户端发送信息处修改代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Iterator&lt;Socket&gt; it = MyServer.sockets.iterator(); it.hasNext(); )&#123;</div><div class="line">	Socket s = it.next();</div><div class="line">	OutputStream os = socket.getOutputStream();</div><div class="line">	os.write(<span class="string">"I'm server\n"</span>.getBytes(<span class="string">"utf-8"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><p>客户端使用Socket来连接服务端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class MyClient&#123;</div><div class="line">	private InputStream is;</div><div class="line">	private OutputStream out;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws UnknownHostException, IOException&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">			Socket socket = new Socket(<span class="string">"127.0.0.1"</span>, 2121);</div><div class="line"></div><div class="line">			is = socket.getInputStream();</div><div class="line">			out = socket.getOutputStream();</div><div class="line"></div><div class="line">			//开启一个新线程来不断获取来自服务端的信息</div><div class="line">			new <span class="function"><span class="title">Thread</span></span>()&#123;</div><div class="line">				public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">					try&#123;</div><div class="line">						byte[] bus = new byte[1024];</div><div class="line">						<span class="keyword">while</span>((is.read(bus)) != -1)&#123;</div><div class="line">							System.out.println(<span class="string">"FROM SERVER: "</span> + new String(bus, 0, bus.length));</div><div class="line">						&#125;</div><div class="line">					&#125; catch(Exception e)&#123;</div><div class="line"></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;.start();</div><div class="line"></div><div class="line">			String content = new Scanner(System.in).nextLine();</div><div class="line">			os.write(content.getBytes(<span class="string">"utf-8"</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android端的客户端代码与Java的大同小异，就不贴出来了。主要是思想</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binder理解]]></title>
      <url>http://yoursite.com/2016/09/26/Binder%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="Binder详解"><a href="#Binder详解" class="headerlink" title="Binder详解"></a>Binder详解</h2><p>Binder的目的是为了实现跨进程间通讯–IPC</p>
<h3 id="1、Binder的框架结构"><a href="#1、Binder的框架结构" class="headerlink" title="1、Binder的框架结构"></a>1、Binder的框架结构</h3><p><img src="/img/binder/binder1.jpg" alt="Binder的框架结构图"><br>a、Client通过bindService()方法去绑定一个来自Service中注册的一个Service服务（其中Client和Service来自不同的进程）<br>b、系统收到来自Client的bindService()方法后，就调用了Service的onBind()方法进行绑定，该方法返回的是一个IBinder对象，该对象是在Service中通过Stub桩去实现的一个代理类对象<br>c、并把该对象返回给Client<br>d、Client从ServiceConnection中的onServiceConnected()方法中接收到该代理对象<br>e、在Client中通过该代理对象可以调用这个代理对象的方法</p>
<h3 id="2、Binder在Service和Client中的使用"><a href="#2、Binder在Service和Client中的使用" class="headerlink" title="2、Binder在Service和Client中的使用"></a>2、Binder在Service和Client中的使用</h3><p>即在Service中创建一个Binder对象以给Client调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(<span class="literal">false</span>);</div><div class="line">private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line">private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new</div><div class="line">            										RemoteCallbackList&lt;&gt;();</div><div class="line">Binder mBinder = new BookManager.<span class="function"><span class="title">Stub</span></span>()&#123;</div><div class="line">	@Override</div><div class="line">    public List&lt;Book&gt; getBookList() throws RemoteException &#123;</div><div class="line">        <span class="built_in">return</span> mBookList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void addBook(Book book) throws RemoteException &#123;</div><div class="line">        mBookList.add(book);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</div><div class="line">        mListenerList.register(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException &#123;</div><div class="line">        mListenerList.unregister(listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中重写的方法例如getBookList()等方法，都是为了给Client调用。在Client中，调用这些方法就是跨进程通信。<br>这就引出了Binder的两个特性：<br><strong>完成特定的功能</strong><br><strong>跨进程传输</strong><br>这两个功能的完成，取决于Binder类中的关键方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//伪代码（Stub）</div><div class="line">class Binder implements IBinder&#123;</div><div class="line">    void attachInterface(IInterface plugs, String descriptor);</div><div class="line">    IInterface queryLocalInterface(String descriptor);</div><div class="line">    boolean onTransact(int code, Parcel data, Parcel reply, int <span class="built_in">type</span>);</div><div class="line"></div><div class="line">    final class BinderProxy implements IBinder&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>系统给每一个实现IBinder接口的对象提供跨进程传输的功能。</strong><br><strong>attachInterface()</strong>方法通过传入一个键值对–descriptor:plugs（Map<string, iinterface="">），来将plugs（IInterface服务对象）和descriptor绑定在一起。<br><strong>queryLocalInterface()</strong>方法通过descriptor这个key来获取plugs这个value.<br>看看以下的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//伪代码</div><div class="line">public static abstract class Stub extends Binder implememnts BookManager&#123;</div><div class="line">    private static final String DESCRIPTOR = <span class="string">"BookManager"</span>;</div><div class="line"></div><div class="line">    public <span class="function"><span class="title">Stub</span></span>()&#123;</div><div class="line">        attachInterface(this, DESCRIPTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    public static BookManger asInterface(IBinder obj)&#123;</div><div class="line">        <span class="keyword">if</span>(obj == null)&#123;</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">        <span class="keyword">if</span>((iin != null) &amp;&amp; (iin instanceof BookManager))&#123;</div><div class="line">            reutrn (BookManager)iin;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">return</span> new Stub.Proxy(iin);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string,></p>
<p>其中，当创建Stub类的时候（在Service中创建），会调用attachInterface()方法将该Binder对象进行绑定。<br>在Client中通过bindService()方法绑定Service时，会调用该IBinder对象的asInterface()来获取到BookManager对象。</p>
<h3 id="3、Binder对象在Client中的调用流程"><a href="#3、Binder对象在Client中的调用流程" class="headerlink" title="3、Binder对象在Client中的调用流程"></a>3、Binder对象在Client中的调用流程</h3><p>当Client从Service中获取到一个Binder对象之后转换成BookManager(自己定义的服务)，那么就可以在Client中调用该BookManager的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//伪代码</div><div class="line">mBookManager.addBook(book);</div></pre></td></tr></table></figure></p>
<p>此时这个addBook()方法并不是Client这个进程中执行，而是在Service的进程中执行的。</p>
<p>在Service中的onBind()方法中返回了一个Binder对象，该Binder对象就是第二点中的第一段代码中所写的那个mBinder，它是一个BookManager.Stub，<strong>但在onBind()方法中返回时已经将该BookManger对象给强制转换为IBinder对象了</strong>。<br>所以在Client中调用asInterface()方法时，该方法内部所调用的queryLocalInterface()方法获取到的iin对象是一个IBinder对象，所以它已经不属于BookManager对象了，所以直接创建一个代理类。<br>如果是在同一个进程中，则没有通过onBind()方法，那么这个BookManger.Stub对象就不会转换为IBinder对象，那么就会执行、、、reutrn (BookManager)iin;、、、这段代码。</p>
<p>在跨进程中，我们已经知道了Client中返回的是一个Stub。看一下Stub的完整代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">public static abstract class Stub extends Binder implements BookManager&#123;</div><div class="line">    public static final String DESCRIPTOR = <span class="string">"BookManager"</span>;</div><div class="line"></div><div class="line">    public <span class="function"><span class="title">Stub</span></span>()&#123;</div><div class="line">        attactInterface(this, DESCRIPTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">        <span class="built_in">return</span> this;</div><div class="line">    &#125;</div><div class="line">    public static BookManager asInterface(IBinder obj)&#123;</div><div class="line">        <span class="keyword">if</span>(obj == null)&#123;</div><div class="line">            <span class="built_in">return</span> null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">        <span class="keyword">if</span>((iin != null) &amp;&amp; (iin instanceof BookManager))&#123;</div><div class="line">            <span class="built_in">return</span> (BookManger)iin;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">return</span> new Stub.Proxy(iin);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int <span class="built_in">type</span>) throws RemoteException&#123;</div><div class="line">        switch(code)&#123;</div><div class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">                reply.writeString(DESCRIPTOR);</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> TRANSACT_addBook:</div><div class="line">                data.enfoceInterface(DESCRIPTOR);</div><div class="line">                Book book;</div><div class="line">                <span class="keyword">if</span>(data.readInt() != 0)&#123;</div><div class="line">                    book = Book.CREATOR.createFromParcel(data);</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    book = null;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                this.addBook(book);</div><div class="line">                reply.writeNoException;</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> TRANSACT_getBookList:</div><div class="line">                data.enfoceInterface(DESCRIPTOR);</div><div class="line">                List&lt;Book&gt; bookList = this.getBookList();</div><div class="line">                reply.writeNoException();</div><div class="line">                reply.writeTypeList(bookList);</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class Proxy extends BookManager&#123;</div><div class="line">        private IBinder mRemote;</div><div class="line">        public Proxy(IBinder remote)&#123;</div><div class="line">            this.mRemote = remote;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public String <span class="function"><span class="title">getInterfaceDescriptor</span></span>()&#123;</div><div class="line">            <span class="built_in">return</span> DESCRIPTOR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">            <span class="built_in">return</span> mRemote;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void addBook(Book book) throws RemoteException&#123;</div><div class="line">            Parcel data = Parcel.obtain();</div><div class="line">            Parcel reply = Parcel.obtain();</div><div class="line"></div><div class="line">            try&#123;</div><div class="line">                data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                <span class="keyword">if</span>(book != null)&#123;</div><div class="line">                    data.writeInt(1);</div><div class="line">                    book.writeToParcel(data, 0);</div><div class="line">                &#125; <span class="keyword">else</span>&#123;</div><div class="line">                    data.writeInt(0);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                mRemote.transact(TRANSACT_addBook, data, reply, 0);</div><div class="line">                reply.readException();</div><div class="line">            &#125; finally&#123;</div><div class="line">                data.recycle();</div><div class="line">                reply.recycle();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public List&lt;Book&gt; getBookList() throws RemoteException&#123;</div><div class="line">            Parcel data = Parcel.obtain();</div><div class="line">            Parcel reply = Parcel.obtain();</div><div class="line">            List&lt;Book&gt; result;</div><div class="line">            try&#123;</div><div class="line">                data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                mRemote.transact(TRANSACT_getBookList, data, reply, 0);</div><div class="line">                reply.readException();</div><div class="line">                result = reply.createTypedArrayList(Book.CREATOR);</div><div class="line">            &#125; finally&#123;</div><div class="line">                data.recycle();</div><div class="line">                reply.recycle();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        static final int TRANSACT_addBook = IBinder.FIRST_CALL_TRANSACTION + 0;</div><div class="line">        static final int TRANSACT_getBookList = IBinder.FIRST_CALL_TRANSACTION + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void addBook(Book book) throws RemoteException;</div><div class="line">public List&lt;Book&gt; getBookList() throws RemoteException;</div></pre></td></tr></table></figure></p>
<p>在Service中使用匿名内部类创建一个Binder对象时，必须重写addBook(Book book)和getBookList()。因为该Stub时一个抽象类。<br>在Client中获取到的是Stub中Proxy对象，所以在Client中调用方法时是调用了代理类中的方法。<br>在代理类的方法中，首先要创建两个用于进程间传递的序列化对象data和reply。然后调用mRemote对象的transact()方法（此时transact()方法会让Stub回调onTransact()方法。onTransact()方法执行完之后会把reply返回给对应的方法），根据reply获取要返回的信息并将该信息返回给调用者。<br>其中的重点在于回调了onTransact()方法。因为代理类在Client进程中，而执行的方法是在Service中，所以需要调用transact()。</p>
<p>再看看onTransact()方法，在该方法中调用了对应的方法，虽然这些方法在Stub类中都是抽象的方法，但在Service中创建Stub对象时重写了这些方法，所以在Client中调用到的就是Service中定义的方法。</p>
<h3 id="4、BookManager服务类完整代码代码"><a href="#4、BookManager服务类完整代码代码" class="headerlink" title="4、BookManager服务类完整代码代码"></a>4、BookManager服务类完整代码代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line">public interface IBookManager extends IInterface&#123;</div><div class="line">    public static abstract class Stub extends Binder implements IBookManager&#123;</div><div class="line">        private static final String DESCRITPTOR = <span class="string">"IBookManager"</span>;</div><div class="line"></div><div class="line">        public <span class="function"><span class="title">Stub</span></span>()&#123;</div><div class="line">            attactInterface(this, DESCRIPTOR);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">            <span class="built_in">return</span> this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public static IBookManager asInterface(IBinder obj)&#123;</div><div class="line">            <span class="keyword">if</span>(obj == null)&#123;</div><div class="line">                <span class="built_in">return</span> null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span>((iin != null) &amp;&amp; (iin instanceof IBookManger))&#123;</div><div class="line">                <span class="built_in">return</span> (IBookManager) iin;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">return</span> new Stub.Proxy(obj);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onTransact(int code, Parcel data, Parcel reply, int <span class="built_in">type</span>)&#123;</div><div class="line">            switch(code)&#123;</div><div class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">                    reply.writeString(DESCRIPTOR);</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                <span class="keyword">case</span> TRANSACT_addBook:</div><div class="line">                    data.enforeInterface(DESCRIPTOR);</div><div class="line">                    Book book;</div><div class="line">                    <span class="keyword">if</span>(data.readInt() != 0)&#123;</div><div class="line">                        book = Book.CREATOR.createFromParcel(data);</div><div class="line">                    &#125; <span class="keyword">else</span>&#123;</div><div class="line">                        book = null;</div><div class="line">                    &#125;</div><div class="line">                    this.addBook(book);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                <span class="keyword">case</span> TRANSACT_getBookList:</div><div class="line">                    data.enforeInterface(DESCRIPTOR);</div><div class="line">                    List&lt;Book&gt; result = this.getBookList();</div><div class="line">                    reply.writeNoException();</div><div class="line">                    reply.writeTypeList(result);</div><div class="line">                    <span class="built_in">return</span> ture;</div><div class="line">                <span class="keyword">case</span> TRANSACT_registerListener:</div><div class="line">                    data.enforeInterface(DESCRIPTOR);</div><div class="line">                    IOnNewBookArrivedListener listener;</div><div class="line">                    listener = IOnNewBookArrivedListener.Stub.asInterface(data);</div><div class="line">                    this.registerListener(listener);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                <span class="keyword">case</span> TRANSACT_unregisterListener:</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    IOnNewBookArrivedListener listener1 ;</div><div class="line">                    listener1 = IOnNewBookArrivedListener.Stub.asInterface(data);</div><div class="line">                    this.unregisterListener(listener1);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">return</span> super.onTransact(code, data, reply, <span class="built_in">type</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private static class Proxy implements IBookManager&#123;</div><div class="line">            public Binder mRemote;</div><div class="line"></div><div class="line">            public Proxy(Binder remote)&#123;</div><div class="line">                this.mRemote = remote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public String <span class="function"><span class="title">getInterfaceDescription</span></span>()&#123;</div><div class="line">                <span class="built_in">return</span> DESCRIPTOR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">                <span class="built_in">return</span> mRemote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public void addBook(Book book) throws RemoteException&#123;</div><div class="line">                Parcel data = Parcel.obtain();</div><div class="line">                Parcel reply = Parcel.obtain();</div><div class="line"></div><div class="line">                try&#123;</div><div class="line">                    data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    <span class="keyword">if</span>(book != null)&#123;</div><div class="line">                        data.writeInt(1);</div><div class="line">                        book.writeToParcel(data, 0);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        data.writeInt(0);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    mRemote.transact(TRANSACT_addBook, data, reply, 0);</div><div class="line">                    reply.readException();</div><div class="line">                &#125; finally&#123;</div><div class="line">                    data.recycle();</div><div class="line">                    reply.recycel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public List&lt;Book&gt; getBookList() throws RemoteException&#123;</div><div class="line">                Parcel data = Parcel.obtain();</div><div class="line">                Parcel reply = Parcel.obtain();</div><div class="line">                List&lt;Book&gt; result;</div><div class="line">                try&#123;</div><div class="line">                    data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    mRemote.transact(TRANSACT_getBookList, data, reply, 0);</div><div class="line">                    reply.readException();</div><div class="line">                    result = reply.createTypedArrayList(Book.CREATOR);</div><div class="line">                &#125; finally&#123;</div><div class="line">                    data.recycle();</div><div class="line">                    reply.recycle();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="built_in">return</span> result;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException&#123;</div><div class="line">                Parcel data = Parcel.obtain();</div><div class="line">                Parcel reply = Parcel.obtain();</div><div class="line"></div><div class="line">                try&#123;</div><div class="line">                    data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    data.wirteStrongBinder((listener == null)? null:listener.asBinder());</div><div class="line">                    mRemote.transact(TRANSACT_registerListener, data, reply, 0);</div><div class="line">                    reply.readException();</div><div class="line">                &#125; finally&#123;</div><div class="line">                    data.recycle();</div><div class="line">                    reply.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException&#123;</div><div class="line">                Parcel data = Parcel.obtain();</div><div class="line">                Parcel reply = Parcel.obtain();</div><div class="line"></div><div class="line">                try&#123;</div><div class="line">                    data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    data.writeStrongBinder((listener == null)? null:listener.asBinder());</div><div class="line">                    mRemote.transact(TRANSACT_unregisterListener, data, reply, 0);</div><div class="line">                    reply.readException();</div><div class="line">                &#125; finally&#123;</div><div class="line">                    data.recycle();</div><div class="line">                    reply.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            private static final int TRANSACT_addBook = FIRST_CALL_TRANSACTION + 0;</div><div class="line">            private static final int TRANSACT_getBookList = FIRST_CALL_TRANSACTION + 1;</div><div class="line">            private static final int TRANSACT_registerListener = FIREST_CALL_TRANSACTION + 2;</div><div class="line">            private static final int TRANSACT_unregisterListener = FIREST_CALL_TRANSACTION + 3;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void addBook(Book book) throws RemoteException;</div><div class="line">    public List&lt;Book&gt; getBookList() throws RemoteException;</div><div class="line">    public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException;</div><div class="line">    public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">public interface IOnNewBookArrivedListener extends IInterface&#123;</div><div class="line">    public static abstract class Stub extends Binder implements IOnNewBookArrivedListener&#123;</div><div class="line">        private static final String DESCRIPTOR = <span class="string">"IOnNewBookArrivedListener"</span>;</div><div class="line">        public <span class="function"><span class="title">Stub</span></span>()&#123;</div><div class="line">            attachInterface(this, DESCRIPTOR);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">            <span class="built_in">return</span> this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        pubilc static IOnNewBookArrivedListener asInterface(IBinder obj)&#123;</div><div class="line">            <span class="keyword">if</span>(obj == null)&#123;</div><div class="line">                reutrn null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span>((iin != null) &amp;&amp; (iin instanceof IOnNewBookArrivedListener))&#123;</div><div class="line">                <span class="built_in">return</span> (IOnNewBookArrivedListener)iin;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">return</span> new Stub.Proxy(obj);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean onTransact(int code, Parcel data, Parcel reply, int <span class="built_in">type</span>) throws RemoteException&#123;</div><div class="line">            switch(code)&#123;</div><div class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">                    data.writeString(DESCRIPTOR);</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">                <span class="keyword">case</span> TRANSACT_onNewBookArrived:</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    Book book;</div><div class="line">                    <span class="keyword">if</span>(data.readInt() != null)&#123;</div><div class="line">                        book = Book.CREATOR.createFromParcel(data);</div><div class="line">                    &#125; <span class="keyword">else</span>&#123;</div><div class="line">                        book = null;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    this.onNewBookArrived(book);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">return</span> super.onTransact(code, data, reply, <span class="built_in">type</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private static class Proxy implements IOnNewBookArrivedListener&#123;</div><div class="line">            private IBinder mRemote;</div><div class="line">            public Proxy(IBinder obj)&#123;</div><div class="line">                this.mRemote = obj;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public String <span class="function"><span class="title">getInterfaceDescription</span></span>()&#123;</div><div class="line">                <span class="built_in">return</span> DESCRIPTOR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public IBinder <span class="function"><span class="title">asBinder</span></span>()&#123;</div><div class="line">                <span class="built_in">return</span> mRemote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public void onNewBookArrived(Book book) throws RemoteException&#123;</div><div class="line">                Parcel data = Parcel.obtain();</div><div class="line">                Parcel reply = Parcel.obtain();</div><div class="line"></div><div class="line">                try&#123;</div><div class="line">                    data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    <span class="keyword">if</span>(book != null)&#123;</div><div class="line">                        data.writeInt(1);</div><div class="line">                        data.writeToParcel(Book.CREATOR);</div><div class="line">                    &#125; <span class="keyword">else</span>&#123;</div><div class="line">                        data.writeInt(0);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    mRemote.transact(TRANSACT_onNewBookArrived, data, reply, 0);</div><div class="line">                    reply.readException();</div><div class="line">                &#125; finally&#123;</div><div class="line">                    data.recycle();</div><div class="line">                    reply.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private static final String TRANSACT_onNewBookArrived = FIRST_CALL_TRANSACTION + 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onNewBookArrived(Book book) throws RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AIDL学习]]></title>
      <url>http://yoursite.com/2016/09/24/AIDL%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="AIDL介绍"><a href="#AIDL介绍" class="headerlink" title="AIDL介绍"></a>AIDL介绍</h2><p>Android Interface Definition Language，android接口定义语言。</p>
<p>你可以定义能够让Client和Service之间建立起通信的程序接口。在Android里面，进程与进程间是不能通信和访问各自的内存。而AIDL的存在，则是为了解决这个问题。</p>
<p><img src="/img/aidl/aidl1.png" alt="官方文档"></p>
<p>什么时候需要AIDL，这是个问题，因为AIDL的编写比较复杂，所以你应该在需要的时候才去使用它，例如当其他的App通过跨进程通信来访问你的Service而且你的Service需要处理多个线程。不然的话你就使用继承Binder或使用Messenger的方法。</p>
<h2 id="AIDL的使用"><a href="#AIDL的使用" class="headerlink" title="AIDL的使用"></a>AIDL的使用</h2><h3 id="1、创建bean类"><a href="#1、创建bean类" class="headerlink" title="1、创建bean类"></a>1、创建bean类</h3><p>首先我们要创建一个实现了Parcelable的Javabean类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Book implements Parcelable&#123;</div><div class="line">	private String name;</div><div class="line">	private int price;</div><div class="line"></div><div class="line">	public <span class="function"><span class="title">Book</span></span>()&#123;&#125;</div><div class="line"></div><div class="line">	protected Book(Parcel <span class="keyword">in</span>)&#123;</div><div class="line">		name = in.readString();</div><div class="line">		price = in.readInt();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;()&#123;</div><div class="line">		public Book createFromParcel(Parcel <span class="keyword">in</span>)&#123;</div><div class="line">			<span class="built_in">return</span> new Book(<span class="keyword">in</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Book[] newArray(int size)&#123;</div><div class="line">			<span class="built_in">return</span> new Book[size];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int <span class="function"><span class="title">getPrice</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Price(int price) &#123;</div><div class="line">        this.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>Name(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int <span class="function"><span class="title">describeContents</span></span>()&#123;</div><div class="line">    	<span class="built_in">return</span> 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void writeToParcel(Parcel parcel, int i)&#123;</div><div class="line">    	parcel.writeString(name);</div><div class="line">    	parcel.writeInt(price);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 自己写的</div><div class="line">    */</div><div class="line">    public void <span class="built_in">read</span>FromParcel(Parcel dest)&#123;</div><div class="line">    	//这里的顺序需要和writeToParce()中的顺序一致</div><div class="line">    	name = dest.readString();</div><div class="line">    	price = dest.readInt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中需要注意的是readFromParce()这个方法是自己写上去的，是为了在.aidl文件中可以使用out或inout来定向tag。</p>
<h3 id="2、创建-aidl文件"><a href="#2、创建-aidl文件" class="headerlink" title="2、创建.aidl文件"></a>2、创建.aidl文件</h3><p>怎么新建AIDL文件呢？当然，AndroidStudio已经帮你领到家门口了。直接右键new –&gt; AIDL –&gt; AIDL File</p>
<p>这里如果你填写的AIDL名字和上面的javabean类名相同的会是不行的，你需要先写一个其他的名字，然后再reName一下，改为javabean的类名。</p>
<p>OK，然后我们再来看看AIDL文件的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package com.example.zouxiaobang.aidlex.aidl;</div><div class="line"></div><div class="line">parcelabel Book;</div></pre></td></tr></table></figure></p>
<p>这个文件的作用就是为了引入一个序列化对象Book，只有这样Book对象才能被其他的AIDL文件所使用。<br>这里的包名应该和Book.java的包名一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.example.zouxiaobang.aidlex.aidl;</div><div class="line"></div><div class="line">import com.example.zouxiaobang.aidlex.aidl.Book;</div><div class="line"></div><div class="line">interface BookManager &#123;</div><div class="line">    List&lt;Book&gt; getBooks();</div><div class="line"></div><div class="line">    void addBook(<span class="keyword">in</span> Book book);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要使用到非默认的类型的时候，就需要import了，例如上面的Book。而在传入参数的时候，需要使用到定向tag。需要记住的是aidl文件其实就是一个接口类，所以你的那些方法也就是将来使用与进程间通信所需要的方法。<br>写完之后clean一下project，如果没有错就对了。这时系统会默认给我们生成对应的.java文件，所以我们才可以使用该接口里的方法。</p>
<h3 id="3、服务端的代码"><a href="#3、服务端的代码" class="headerlink" title="3、服务端的代码"></a>3、服务端的代码</h3><p>我们刚刚所做的只是建立了接口，我们都知道，接口的方法是不能调用，这就需要我们去实现这些方法了。这个步骤就在我们的服务端来完成。(这里我们的服务端就是Service)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class AIDLService extends Service &#123;</div><div class="line">    private List&lt;Book&gt; mBooks = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    private final BookManager.Stub mBookManager = new BookManager.<span class="function"><span class="title">Stub</span></span>() &#123;</div><div class="line">        @Override</div><div class="line">        public List&lt;Book&gt; getBooks() throws RemoteException &#123;</div><div class="line">            <span class="keyword">if</span> (mBooks == null)&#123;</div><div class="line">                <span class="built_in">return</span> new ArrayList&lt;Book&gt;();</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">return</span> mBooks;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void addBook(Book book) throws RemoteException &#123;</div><div class="line">            synchronized (AIDLService.class)&#123;</div><div class="line">                <span class="keyword">if</span> (mBooks == null)&#123;</div><div class="line">                    mBooks = new ArrayList&lt;&gt;();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (book == null)&#123;</div><div class="line">                    book = new Book();</div><div class="line">                    book.setPrice(12);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!mBooks.contains(book))&#123;</div><div class="line">                    mBooks.add(book);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onCreate</span></span>() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        Book book = new Book();</div><div class="line">        book.setName(<span class="string">"Android"</span>);</div><div class="line">        book.setPrice(75);</div><div class="line">        mBooks.add(book);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        <span class="built_in">return</span> mBookManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最重要的就是对BookManager这个aidl接口的实现，注意它的实现并不是普通interface那样直接使用接口名，而是BookManger.Stub。我们在Stub实现类中将方法进行逻辑实现。而我们以前说过onBind()方法返回的IBinder对象也是一个AIDL接口，所以我们可以直接让onBind()方法返回AIDL的实现类，即mBookManager。</p>
<p>好了，我们服务端的代码写完了，就先开启它。可以在Activity中使用startService()来启动。</p>
<h3 id="4、客户端的代码"><a href="#4、客户端的代码" class="headerlink" title="4、客户端的代码"></a>4、客户端的代码</h3><p>新建一个App作为客户端，这才能够体现出AIDL的跨进程通信的功能。将服务端的aidl文件都复制到客户端中，记得包名也得是相同的，而且Book这个bean也要复制过去，包名一样得相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    private List&lt;Book&gt; mBooks;</div><div class="line">    private BookManager mBookManager;</div><div class="line">    private boolean isBound;</div><div class="line"></div><div class="line">    private ServiceConnection mConnection = new <span class="function"><span class="title">ServiceConnection</span></span>() &#123;</div><div class="line">        @Override</div><div class="line">        public void onServiceConnected(ComponentName componentName, IBinder service) &#123;</div><div class="line">            mBookManager = BookManager.Stub.asInterface(service);</div><div class="line">            isBound = <span class="literal">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mBookManager != null)&#123;</div><div class="line">                try &#123;</div><div class="line">                    mBooks = mBookManager.getBooks();</div><div class="line">                    Log.i(<span class="string">"books"</span>, mBooks.toString());</div><div class="line">                &#125; catch (RemoteException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onServiceDisconnected(ComponentName componentName) &#123;</div><div class="line">            isBound = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 点击事件:点击添加</div><div class="line">     * @param view</div><div class="line">     */</div><div class="line">    public void addBook(View view)&#123;</div><div class="line">        <span class="keyword">if</span> (!isBound)&#123;</div><div class="line">            Intent intent = new Intent();</div><div class="line">            intent.setAction(<span class="string">"com.example.zouxiaobang.aidlex.service"</span>);</div><div class="line">            intent.setPackage(<span class="string">"com.example.zouxiaobang.aidlex"</span>);</div><div class="line">            <span class="built_in">bind</span>Service(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mBookManager == null)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line"></div><div class="line">        Book book = new Book();</div><div class="line">        book.setName(<span class="string">"App"</span>);</div><div class="line">        book.setPrice(12);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            mBookManager.addBook(book);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        unbindService(mConnection);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时同时打开两个APP，点击客户端的按钮时，即可看到通信的内容。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Service中onBind的返回对象]]></title>
      <url>http://yoursite.com/2016/09/22/Service%E4%B8%ADonBind%E7%9A%84%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="onBind-Intent-intent"><a href="#onBind-Intent-intent" class="headerlink" title="onBind(Intent intent)"></a>onBind(Intent intent)</h2><p>我们都知道这个方法返回一个IBinder对象，该对象是用于与客户端进行通信的。但是IBinder是一个抽象类，它的本质是一个AIDL对象，那么我们应该怎么去创建它呢？</p>
<p>Android给我们提供了三个方法</p>
<ul>
<li>继承Binder类</li>
<li>使用Messager类</li>
<li>使用AIDL</li>
</ul>
<h3 id="1、继承Binder类"><a href="#1、继承Binder类" class="headerlink" title="1、继承Binder类"></a>1、继承Binder类</h3><p>我在介绍Service的bindService()开启Service的时候都是使用继承Binder这个方法来与Client取得联系的，因为这个方法是最简单的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//Service code</div><div class="line">private int mCount;</div><div class="line">private MyBinder mBinder = new MyBinder();</div><div class="line"></div><div class="line">public class MyBinder extends Binder&#123;</div><div class="line">	public int <span class="function"><span class="title">getCount</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> mCount;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public IBinder onBind(Intent intent)&#123;</div><div class="line">	<span class="built_in">return</span> mBinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>client通过bindService()与Service连接时产生的ServiceConnection对象来获取这个MyBinder对象，然后通过操作MyBinder的方法可以与Service取得通信。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//Client code</div><div class="line">private MyService.MyBinder mBinder;</div><div class="line"></div><div class="line">ServiceConnection mConnection = new <span class="function"><span class="title">ServiceConnection</span></span>()&#123;</div><div class="line">	@Override</div><div class="line">	public void onServiceConnected(ComponentName className, IBinder service)&#123;</div><div class="line">		mBinder = (MyService.MyBinder) service;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onServiceDisconnected(ComponentName className)&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void <span class="function"><span class="title">doConnect</span></span>()&#123;</div><div class="line">	<span class="built_in">bind</span>Service(new Intent(this, MyService.class), mConnection, Context.BIND_AUTH_CREATE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int <span class="function"><span class="title">getCount</span></span>()&#123;</div><div class="line">	<span class="built_in">return</span> mBinder.getCount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void <span class="function"><span class="title">doUnconnect</span></span>()&#123;</div><div class="line">	unbindService(mConnection);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、使用Messenger类"><a href="#2、使用Messenger类" class="headerlink" title="2、使用Messenger类"></a>2、使用Messenger类</h3><p>当我们提到IPC(跨进程通信)的时候，总会想起一个很高端的名称–AIDL，但是AIDL是一门很深很难的技术，既然太难，就会有替代品。Android使用了一个更为简单的类来代替编写整个AIDL—-Messager。</p>
<p>Messenger的核心是有Message和Handler来进行线程间通信的。那么在Service中使用Messenger，就必须有Message和Handler的存在。即使用它的步骤如下：</p>
<ul>
<li>在Service中创建一个Handler对象</li>
<li>通过Handler对象创建一个Messager对象–Messenger mMessenger = new Messenger(mHandler);</li>
<li>在onBind()中返回一个IBinder–return mMessenger.getBinder();</li>
<li>在Client中对Service进行连接</li>
<li>在ServiceConnection对象中获取来自Service的Messenger–Messenger rMessenger = new Messenger(service);</li>
<li>使用Messenger来发送数据</li>
</ul>
<p>下面的例子是客户端和后台之间的数据传输<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class MessengerService extends Servcie&#123;</div><div class="line">	private static final int MSG_SAY_HELLO = 0;</div><div class="line"></div><div class="line">	//本地的Messenger对象</div><div class="line">	private Messenger mMessenger;</div><div class="line">	//来自Client的Messenger对象</div><div class="line">	private Messenger cMessenger;</div><div class="line"></div><div class="line">	//获取来自Client的信息并进行处理</div><div class="line">	private Handler mHandler = new <span class="function"><span class="title">Handler</span></span>()&#123;</div><div class="line">		public void handleMessage(Message msg)&#123;</div><div class="line">			switch(msg.what)&#123;</div><div class="line">				<span class="keyword">case</span> MSG_SAY_HELLO:</div><div class="line">					cMessenger = msg.replyTo;</div><div class="line">					<span class="built_in">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public IBinder onBind(Intent intent)&#123;</div><div class="line">		<span class="built_in">return</span> mMessenger.getBinder();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void <span class="function"><span class="title">onCreate</span></span>()&#123;</div><div class="line">		mMessenger = new Messenger(mHandler);</div><div class="line">		int num = 0;</div><div class="line"></div><div class="line">		new <span class="function"><span class="title">Thread</span></span>()&#123;</div><div class="line">			public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">				<span class="keyword">while</span>(num &lt; 100)&#123;</div><div class="line">					SystemClock.sleep(100);</div><div class="line">					num ++;</div><div class="line">					Message msg = new Message();</div><div class="line">					msg.what = 1;</div><div class="line">					Bundle data = new Bundle();</div><div class="line">					data.putExtra(<span class="string">"num"</span>, num);</div><div class="line">					msg.setData(data);</div><div class="line">					cMessenger.send(msg);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">	private Messenger mMessenger;</div><div class="line">	//来自Service的Messenger对象</div><div class="line">	private Messenger rMessenger;</div><div class="line"></div><div class="line">	private Handler mHandler = new <span class="function"><span class="title">Handler</span></span>()&#123;</div><div class="line">		public void handleMessage(Message msg)&#123;</div><div class="line">			switch(msg.what)&#123;</div><div class="line">				<span class="keyword">case</span> 1:</div><div class="line">					Log.i(<span class="string">"tag"</span>, msg.getData().getIntExtra(<span class="string">"num"</span>) + <span class="string">""</span>);</div><div class="line">					<span class="built_in">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	private ServiceConnection mConnection = new <span class="function"><span class="title">ServiceConnection</span></span>()&#123;</div><div class="line">		public void onServiceConnected(ComponentName className, Intent service)&#123;</div><div class="line">			rMessenger = new Messenger(service);</div><div class="line">			mMessenger = new Messenger(mHandler);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public void onServiceDisconnected(ComponentName className)&#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="built_in">bind</span>Service(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void <span class="function"><span class="title">getCount</span></span>()&#123;</div><div class="line">    	Message msg = new Message();</div><div class="line">    	msg.what = 0;</div><div class="line">    	msg.replyTo = mMessenger;</div><div class="line">    	try&#123;</div><div class="line">    		rMessage.send(msg);</div><div class="line">    	&#125; catch(Exception ex)&#123;</div><div class="line"></div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="function"><span class="title">onDestroy</span></span>()&#123;</div><div class="line">    	super.onDestroy();</div><div class="line">    	unbindService(mConnection);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、使用AIDL"><a href="#3、使用AIDL" class="headerlink" title="3、使用AIDL"></a>3、使用AIDL</h3><p>由于AIDL比较复杂，所以请看下一篇博文</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IntentService--拥有独立线程的后台]]></title>
      <url>http://yoursite.com/2016/09/21/IntentService-%E6%8B%A5%E6%9C%89%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8E%E5%8F%B0/</url>
      <content type="html"><![CDATA[<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>同样地，我们先来看看官方对IntentService的介绍</p>
<p><img src="/img/service/intentservice1.png" alt=""></p>
<p>1、IntentService继承自Service，但它是用来处理有异步请求的<br>2、客户端也就是其他的组件通过startService(Intent)方法来发送请求，然后它就会根据这个请求来决定是否开始处理<br>3、使用一个线程处理所有的Intent(当然，它并不是同时进行的)，但它工作完了之后就会自己关闭掉自己。</p>
<p><img src="/img/service/intentservice3.png" alt=""></p>
<p>所有的请求都在一个线程中进行，也许有些请求会花很长的时间，但每次只能处理一个请求。<br>这就是IntentService的缺点，它虽然是异步的，但每次都只能够对一个请求进行处理(工作队列的模式)。但这其实满足了很多对于网络的请求。</p>
<h2 id="IntentService的使用"><a href="#IntentService的使用" class="headerlink" title="IntentService的使用"></a>IntentService的使用</h2><p>创建一个继承自IntentService的类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MyIntentService extends IntentService&#123;</div><div class="line">	public <span class="function"><span class="title">MyIntentService</span></span>()&#123;</div><div class="line">		super(<span class="string">"MyIntentService"</span>);</div><div class="line">		//...</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void onHandleIntent(Intent intent)&#123;</div><div class="line">		//TODO handle your requests</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是最简单的IntentService的类范例</p>
<p><img src="/img/service/intentservice4.png" alt=""></p>
<p>构造方法：在官方文档中的构造方法也是有一个String的参数，这是一个很奇怪的参数，如果你的构造方法有这个参数，那么你就需要有一个构造器。如果没有构造器，那么你的IntentService就会出错。所以一般按照上面的方法来写。super()里面的参数是IntentService开启的线程的线程名。</p>
<p><img src="/img/service/intentservice5.png" alt=""></p>
<p>onHandleIntent(Intent intent)：这是一个抽象方法，所以在编写自己的IntentService类的时候需要重写该方法。在该方法中对Intent请求进行处理，但有可能其中某个请求需要消耗很多的时间，这会拖延了其它请求的进行(当然不会拖延其它Service的请求啦)。而且在这个方法中，当你将所有的请求都处理完了，IntentService会自动stop自己，而不用去调用stopSelf()方法。<br>其中的Intent参数是startService(Intent)方法中的参数传过来的，所以它带来的是其它组件传过来的意图。</p>
<p>其实，IntentService还有几个方法，只是在封装的时候都已经被实现了，所以不需要我们进行重写。但还是有一个方法需要注意的，因为它涉及一个问题，你可能看这篇文章的时候一直有一个问题，就是看了这么久，都不知道IntentService是怎么和Activity等的组件进行交互的。在Service中我们通过绑定来解决这个问题，那么IntentService行不行呢？官方文档第一句话就已经说行了。哪里，我怎么没看到？你看，它说啊，IntentService是继承自Service的，那父类有的public方法，子类自然也有。所以重写onBind(Intent)方法来与之进行数据的交流。</p>
<p>onBind()的用法和Service的用法一致，这里就不再贴代码了，如果不清楚可以去看我的上一篇博文。<br>这里要注意的有两个方面：</p>
<ul>
<li>IntentService的开启方式就是startService()方法，而bindService()也就仅仅只是绑定而已，并没有开启，所以每次要是IntentService具有交流性，都要将这两个方法都使用。因为bindService()方法并没有去调用onHandleIntent()方法。</li>
<li>在onHandleIntent()方法中，请求的处理是一件接一件的，例如你在Activity中同时发送两个Intent给IntentService，那么onHandleIntent()就收到两个Intent，它根据Intent携带的信息来判别不同的请求，然后对这些请求进行处理：intent1 start –&gt; intent1 end –&gt; intent2 start –&gt; intent2 end 也就是说第一个请求还没处理好，第二个请求你就别想动。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Service的理解]]></title>
      <url>http://yoursite.com/2016/09/21/Service%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="初识Service"><a href="#初识Service" class="headerlink" title="初识Service"></a>初识Service</h2><p>对于Service的使用，应该有很多人都对它很有心得，但我却惊奇地发现，每个人的对Service的理解总是有那么些不同，那么，就说说我的心得吧。</p>
<p>首先，看看官方文档对Service的介绍</p>
<p><img src="/img/service/service1.png" alt="官文第一段"></p>
<p>Service是一个app组件，用于在处理长时间的操作。所有的Service都必须在AndroidManifest.xml中进行注册。开启Service的方法有两个</p>
<ul>
<li>Context.startService();</li>
<li>Context.bindService();</li>
</ul>
<p>这两种方法稍下进行详细地介绍，下面继续看官方文档</p>
<p><img src="/img/service/service2.png" alt="官文第二段"></p>
<p>Service默认是运行在主线程中，如果你想启动例如后台播放的MP3，获取网络之类的操作呢，你就得乖乖地自己开启一个新的线程(PS:spawn为产卵的意思，根据我14年英语生涯的理解，还是解释成开启比较好)。当然，你要是选择了IntentService来作为后台的话，那就更好了，因为它自己本身就拥有一个线程，拥有异步操作的优势。</p>
<p>我百度了一下，Service中能否进行耗时的操作，很多都直接说，不能。但是，官方文档第一句就说它就是为了出来长时间操作而来的，那不是自相矛盾。其实不然，Service确实可以进行耗时操作，只是必须直接创建一个新线程，因为Service默认是在main线程中执行的，那么长时间的操作会阻碍主线程的更新，就会产生异常(ANR)。而对于IntentService则没有这个痛苦，稍后也会对它进行介绍。</p>
<h2 id="Service的启动"><a href="#Service的启动" class="headerlink" title="Service的启动"></a>Service的启动</h2><h3 id="1、startService-启动Service"><a href="#1、startService-启动Service" class="headerlink" title="1、startService()启动Service"></a>1、startService()启动Service</h3><p>在Java代码中启动Service：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.startService(new Intent(context, MyService.class));</div></pre></td></tr></table></figure>
<p>在AndroidManifest.xml文件中注册Service：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;.MyService&quot;</div><div class="line">    android:process=&quot;:remote&quot;&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>其中的android:process=”:remote”是新建一个新的线程，线程名叫remote。</p>
<p>接下来我们看看这种方式启动的Service的生命周期</p>
<p><img src="/img/service/service3.png" alt="Unbounded"></p>
<ul>
<li>onCreate()：只会调用一次，即使是多次使用了startService()来开启Service。可以在这个方法里面做一些初始化操作</li>
<li>onStartCommand(Intent intent, int flag, int startId)：当其它组件通过startService()来开启Service时调用它。这个方法的作用很好地说明了一旦你第一次开启了Service，那么你没有消灭它之前，它是一直存在的，直到你退出整个App。</li>
<li>onDestroy()：这个不用多说了吧，当你调用stopService()方法来停止后台运行时，就会调用它。</li>
</ul>
<p>停止后台的代码(两种)</p>
<p>在Activity等组件中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.stopService(Intent name);</div></pre></td></tr></table></figure></p>
<p>在Service自身中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stopSelf();</div><div class="line">//stopSelf(int startId);</div></pre></td></tr></table></figure></p>
<h3 id="2、bindService-绑定Service"><a href="#2、bindService-绑定Service" class="headerlink" title="2、bindService()绑定Service"></a>2、bindService()绑定Service</h3><p><img src="/img/service/service4.png" alt="Bounded"></p>
<p>使用这种方法绑定Service，必须在Service类中重写onBind()方法，而onBind()返回一个IBinder对象。该IBinder对象的作用就是用于与其它组件进行通信的。</p>
<p>在Java中的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private MyService.MyBinder mBinder;</div><div class="line">private boolean mIsBound;</div><div class="line"></div><div class="line">private ServiceConnection mConnection = new <span class="function"><span class="title">ServiceConnection</span></span>()&#123;</div><div class="line">	public void onServiceConnected(ComponentName className, IBinder service)&#123;</div><div class="line">		mBinder = (MyService.MyBinder)service;</div><div class="line">		//TODO Binder class <span class="keyword">in</span> MyService ----fuction</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void onServiceDisconnected(ComponentName className)&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void <span class="function"><span class="title">doBindService</span></span>()&#123;</div><div class="line">	<span class="built_in">bind</span>Service(new Intent(this, MyService.class), mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">	mIsBound = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void <span class="function"><span class="title">doUnbindService</span></span>()&#123;</div><div class="line">	<span class="keyword">if</span>(mIsBound)&#123;</div><div class="line">		unbindService(mConnection);</div><div class="line">		mIsBound = <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void <span class="function"><span class="title">onDestroy</span></span>()&#123;</div><div class="line">	super.onDestroy();</div><div class="line">	<span class="keyword">do</span>UnbindService();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中我们需要创建一个连接–ServiceConnection，将该连接对象传入到bind中，此时如果与Service绑定成，则这个ServiceConnection就会回调onServiceConnected()方法，否则回调onServiceDisconnected()，成功绑定后，我们可以通过onServiceConnected()的参数service来获取后台的IBinder对象，从而操作后台创建的IBinder类中的动作。</p>
<p>现在我们来看看这个Service类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class MyService extends Service&#123;</div><div class="line">	private int mCount = 0;</div><div class="line">	public class MyBinder extends Binder&#123;</div><div class="line">		public int <span class="function"><span class="title">getCount</span></span>()&#123;</div><div class="line">			<span class="built_in">return</span> mCount;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private MyBinder mBinder = new MyBinder();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public IBinder onBind(Intent intent)&#123;</div><div class="line">		<span class="built_in">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void <span class="function"><span class="title">onCreate</span></span>()&#123;</div><div class="line">		super.onCreate();</div><div class="line"></div><div class="line">		new Thread&#123;</div><div class="line">			public void <span class="function"><span class="title">run</span></span>()&#123;</div><div class="line">				<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">					count ++;</div><div class="line">					SystemClock.sleep(100);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，当使用bindService()方法绑定Service时，不能在AndroidManifest.xml文件中写入android:process=”:remote”，而只能在代码中new一个Thread。</p>
<p>这样之后我们可以在Activity中通过mBinder的getCount来获取Service中的信息，而Service也可以通过onBind()方法中的Intent参数来获取Activity传递过来的参数。</p>
<p><a href="https://zouxiaobang.github.io/2016/09/21/IntentService-拥有独立线程的后台/" target="_blank" rel="external">下一篇</a>我将介绍google更加推荐的IntentService。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager与Fragment的配合使用]]></title>
      <url>http://yoursite.com/2016/09/20/ViewPager%E4%B8%8EFragment%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>很多时候我们都需要使用到一种界面，就是微信那种可以左移右移的界面，如果通过Scroller机制去自定义这么一个组件，那也不是不可以，就是特别麻烦，特别是各种滑动冲突，点击事件的截取，都能让你头两个大。幸好，Android提供了这么个组件来解决这个难题。<br>ViewPager的官方文档第一句话就说了ViewPager的左右，就是移来移去。<br><img src="/img/viewPager/viewpager1.png" alt="官方文档"><br>第一段告诉我们这个组件的作用，当然使用它还得实现一个Adapter来控制ViewPager的展示。<br>那么怎么使用比较好呢，下面就说了，通常是跟Fragment配合使用，那么Adapter当然就是使用与Fragment相关的最好了，官方介绍了两个接口，FragmentPagerAdapter和FramentStatePagerAdapter。我们这里以FragmentPagerAdapter举例子。</p>
<p>先给一个项目图片<br><img src="/img/viewPager/viewpager2.png" alt="效果图1"><br><img src="/img/viewPager/viewpager3.png" alt="效果图2"></p>
<p>特色：</p>
<ul>
<li>定制性强，修改ViewPager中内容和标题都不需要改动Adapter类</li>
<li>标题可随手指移动随时移动。</li>
</ul>
<p><a href="https://github.com/zouxiaobang/ViewPagerEx" target="_blank" rel="external">项目代码</a></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="1、main的xml文件"><a href="#1、main的xml文件" class="headerlink" title="1、main的xml文件"></a>1、main的xml文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:id=<span class="string">"@+id/activity_main"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">    &lt;include</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        layout=<span class="string">"@layout/tab_top"</span>/&gt;</div><div class="line"></div><div class="line">    &lt;android.support.v4.view.ViewPager</div><div class="line">        android:id=<span class="string">"@+id/vp_content"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>将ViewPager作为一个组件添加进去<br>其中的tab_top.xml文件就不给出了</p>
<h3 id="2、Fragment类"><a href="#2、Fragment类" class="headerlink" title="2、Fragment类"></a>2、Fragment类</h3><p>总共4个Fragment类，这里只举一个<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class ChatFragment extends Fragment&#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_chat, container, <span class="literal">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3、FragmentAdapter类"><a href="#3、FragmentAdapter类" class="headerlink" title="3、FragmentAdapter类"></a>3、FragmentAdapter类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public class FragmentAdapter extends FragmentPagerAdapter implements ViewPager.OnPageChangeListener &#123;</div><div class="line">    private List&lt;Fragment&gt; mFragments;</div><div class="line">    private ViewPager mPager;</div><div class="line">    private OnScrolledListener mListener;</div><div class="line">    private int currentIndex;</div><div class="line"></div><div class="line">    public FragmentAdapter(FragmentActivity activity, ViewPager pager) &#123;</div><div class="line">        super(activity.getSupportFragmentManager());</div><div class="line"></div><div class="line">        mFragments = ((MainActivity)activity).getFragments();</div><div class="line">        mPager = pager;</div><div class="line">        mPager.setAdapter(this);</div><div class="line">        mPager.setOnPageChangeListener(this);</div><div class="line"></div><div class="line"></div><div class="line">        DisplayMetrics displayMetrics = new DisplayMetrics();</div><div class="line">        activity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Fragment getItem(int position) &#123;</div><div class="line">        <span class="built_in">return</span> mFragments.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int <span class="function"><span class="title">getCount</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mFragments.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPageScrolled(int position, <span class="built_in">float</span> positionOffset, int positionOffsetPixels) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (currentIndex == position)&#123;</div><div class="line">            <span class="keyword">if</span> (mListener != null)&#123;</div><div class="line">                mListener.toRight(currentIndex, positionOffset);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currentIndex &gt; position)&#123;</div><div class="line">            <span class="keyword">if</span> (mListener != null)&#123;</div><div class="line">                mListener.toLeft(currentIndex, positionOffset);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPageSelected(int position) &#123;</div><div class="line">        currentIndex = position;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPageScrollStateChanged(int state) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    interface OnScrolledListener&#123;</div><div class="line">        void toRight(int current, <span class="built_in">float</span> offset);</div><div class="line">        void toLeft(int current, <span class="built_in">float</span> offset);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>OnScrolledListener(OnScrolledListener listener)&#123;</div><div class="line">        mListener = listener;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该Adapter继承了FragmentPagerAdapter，且实现了OnPageChangeListener来解决滑动事件，为了简化滑动事件，该Adapter重新提供了一个接口给外面的Activity调用。</p>
<h3 id="4、Activity类"><a href="#4、Activity类" class="headerlink" title="4、Activity类"></a>4、Activity类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends FragmentActivity &#123;</div><div class="line"></div><div class="line">    @Bind(R.id.tv_chat)</div><div class="line">    TextView mTvChat;</div><div class="line">    @Bind(R.id.tv_friend)</div><div class="line">    TextView mTvFriend;</div><div class="line">    @Bind(R.id.tv_say)</div><div class="line">    TextView mTvSay;</div><div class="line">    @Bind(R.id.tv_mine)</div><div class="line">    TextView mTvMine;</div><div class="line">    @Bind(R.id.vp_content)</div><div class="line">    ViewPager mVpContent;</div><div class="line">    @Bind(R.id.iv_tab_bottom)</div><div class="line">    ImageView mIvTabBottom;</div><div class="line"></div><div class="line">    private ChatFragment mChatFragment;</div><div class="line">    private FriendFragment mFriendFragment;</div><div class="line">    private SayFragment mSayFragment;</div><div class="line">    private MineFragment mMineFragment;</div><div class="line">    private int mWidth;</div><div class="line">    private List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">        ButterKnife.bind(this);</div><div class="line"></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">init</span></span>() &#123;</div><div class="line">        mChatFragment = new ChatFragment();</div><div class="line">        mFriendFragment = new FriendFragment();</div><div class="line">        mSayFragment = new SayFragment();</div><div class="line">        mMineFragment = new MineFragment();</div><div class="line">        mFragments.add(mChatFragment);</div><div class="line">        mFragments.add(mFriendFragment);</div><div class="line">        mFragments.add(mSayFragment);</div><div class="line">        mFragments.add(mMineFragment);</div><div class="line"></div><div class="line">        DisplayMetrics displayMetrics = new DisplayMetrics();</div><div class="line">        getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);</div><div class="line">        mWidth = displayMetrics.widthPixels;</div><div class="line">        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mIvTabBottom</div><div class="line">                .getLayoutParams();</div><div class="line">        lp.width = mWidth / 4;</div><div class="line"></div><div class="line">        FragmentAdapter adapter = new FragmentAdapter(this, mVpContent);</div><div class="line">        adapter.setOnScrolledListener(new FragmentAdapter.<span class="function"><span class="title">OnScrolledListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void toRight(int current, <span class="built_in">float</span> offset) &#123;</div><div class="line">                lp.leftMargin = (int) (offset</div><div class="line">                        * (mWidth / 4) + current</div><div class="line">                        * (mWidth / 4));</div><div class="line">                mIvTabBottom.setLayoutParams(lp);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void toLeft(int current, <span class="built_in">float</span> offset) &#123;</div><div class="line">                lp.leftMargin = (int) (-(1 - offset)</div><div class="line">                        * (mWidth / 4) + current</div><div class="line">                        * (mWidth / 4));</div><div class="line">                mIvTabBottom.setLayoutParams(lp);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        mIvTabBottom.setLayoutParams(lp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Fragment&gt; <span class="function"><span class="title">getFragments</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> mFragments;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @OnClick(&#123;R.id.tv_chat, R.id.tv_friend, R.id.tv_say, R.id.tv_mine&#125;)</div><div class="line">    public void onClick(View view) &#123;</div><div class="line">        int index = 0;</div><div class="line">        switch (view.getId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.tv_chat:</div><div class="line">                index = 0;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.tv_friend:</div><div class="line">                index = 1;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.tv_say:</div><div class="line">                index = 2;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.tv_mine:</div><div class="line">                index = 3;</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        mVpContent.setCurrentItem(index);</div><div class="line">        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mIvTabBottom.getLayoutParams();</div><div class="line">        lp.leftMargin = index * (mWidth/4);</div><div class="line">        mIvTabBottom.setLayoutParams(lp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中需要注意的是，与ViewPager一起使用的Fragment也需要时V4包<br>import android.support.v4.app.Fragment;<br>import android.support.v4.app.FragmentActivity;<br>import android.support.v4.app.FragmentPagerAdapter;<br>import android.support.v4.view.ViewPager;</p>
<p>如果需要添加页面，只需要修改init()方法里的Fragment就可以。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fragment的进阶篇]]></title>
      <url>http://yoursite.com/2016/09/19/Fragment%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      <content type="html"><![CDATA[<h2 id="Fragment的回退"><a href="#Fragment的回退" class="headerlink" title="Fragment的回退"></a>Fragment的回退</h2><p>我们都知道，Activity有一个栈，叫Task栈，只要我们没有finish掉该Activity，点击Back就可以返回到启动它的Activity中去。<br>Fragment也有一个类似的栈，叫回退栈。但是它与Task栈不同的是它必须手动将fragment添加到回退栈中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mTransaction.addToBackStack(null);</div></pre></td></tr></table></figure></p>
<p><img src="/img/Fragment/fragmentba.png" alt="Fragment的回退"><br>栈的结构和操作我就不必多说了，当我们在最后一个fragment中点击back，就会返回与之关联的Activity。</p>
<p>现在我们来看一个例子<br><img src="/img/Fragment/back1.png" alt="第一个fragment"><br> 点击进入第二个fragment<br><img src="/img/Fragment/back2.png" alt="第二个fragment"><br>点击进入第三个fragment<br><img src="/img/Fragment/back3.png" alt="第三个fragment"><br>点击back<br><img src="/img/Fragment/back2.png" alt="第二个fragment"><br>再点击back<br><img src="/img/Fragment/back1.png" alt="第一个fragment"></p>
<p>Activity中的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Bind(R.id.fl_content)</div><div class="line">    FrameLayout mFlContent;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_back_stack);</div><div class="line">        ButterKnife.bind(this);</div><div class="line"></div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">        transaction.add(R.id.fl_content, new BackOneFragment());</div><div class="line">        //将fragment添加到回退栈中</div><div class="line">//        transaction.addToBackStack(null);</div><div class="line">        transaction.commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，如果我们将第一个fragment添加到回退栈，那么在第一个fragment中点击back，会先回到该Activity中(如上面代码，如果FrameLayout中没有任何东西，则点击back会返回一张白布)，而如果不加入回退栈，那么点击back会直接退出该Activity。</p>
<p>fragment的xml代码就不贴出来了，里面就包含了一个EditText和一个Button<br>下面是第一个fragment<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class BackOneFragment extends Fragment &#123;</div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_back_one, container, <span class="literal">false</span>);</div><div class="line">        Button button = (Button) view.findViewById(R.id.btn_2second);</div><div class="line">        button.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view) &#123;</div><div class="line">                FragmentManager manager = getFragmentManager();</div><div class="line">                FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">                transaction.add(R.id.fl_content, new BackTwoFragment());</div><div class="line">//                transaction.replace(R.id.fl_content, new BackTwoFragment());</div><div class="line">                transaction.addToBackStack(null);</div><div class="line">                transaction.commit();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用FragmentTransaction调用add()和replace()的区别在哪里呢？<br>它们的区别就在于从第二个fragment回退到第一个fragment时是否将视图重绘：<br><img src="/img/Fragment/back1.png" alt="调用add()方法"><br><img src="/img/Fragment/back1.png" alt="调用replace()"><br>replace()方法的内部是先调用remove()方法，再调用add()方法，所以会先将视图销毁，再重新绘制，即调用了onDestroyView()和onCreateView();<br>所以尽管已经将事务保存进了回退栈，而事务也并没有被销毁，但视图还是会进行重绘。</p>
<p>而第二个fragment的代码和第一个大同小异，就不再贴出，如果有兴趣可以去看看我的工程代码。<br><a href="https://github.com/zouxiaobang/FragmentProject" target="_blank" rel="external">Fragment示例</a></p>
<h2 id="Fragment的通信"><a href="#Fragment的通信" class="headerlink" title="Fragment的通信"></a>Fragment的通信</h2><p>Fragment的通信有两种：</p>
<ul>
<li>Fragment与Activity的通信</li>
<li>Fragment之间的通信<br>其中，Fragment与Fragment之间的通信一般并不提倡，而应该是由Activity来判断和显示哪一个Fragment。所以这里并不介绍第二种通信。</li>
</ul>
<p>Fragment通过getActivity()来获取与之绑定的Activity的Context对象，而Activity可以通过Fragment实例或者findFragmentById()或findFragmentByTab()来获取Fragment对象。但它们之间一般使用interface接口来实现通信。<br>例子：<br><img src="/img/Fragment/connect1.png" alt="调用add()方法"><br>该界面白色部分为Activity中的组件，而绿色的为Fragment中的组件，在Fragment中的EditText中输入内容后点击显示<br><img src="/img/Fragment/connect2.png" alt="调用add()方法"><br>我们可以看到Activity中的TextView跟着改变，这就是在Activity中获取来着fragment中的信息。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Fragment的代码</div><div class="line">*/</div><div class="line">public class ConnectFragment extends Fragment &#123;</div><div class="line">    @Bind(R.id.et_message)</div><div class="line">    EditText mEtMessage;</div><div class="line">    @Bind(R.id.btn_show)</div><div class="line">    Button mBtnShow;</div><div class="line"></div><div class="line">    private OnGetMessageListener mListener;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_connect, container, <span class="literal">false</span>);</div><div class="line">        ButterKnife.bind(this, view);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @OnClick(R.id.btn_show)</div><div class="line">    public void <span class="function"><span class="title">onClick</span></span>() &#123;</div><div class="line">        String msg = mEtMessage.getText().toString();</div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(msg) &amp;&amp; mListener != null)&#123;</div><div class="line">            mListener.getMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public interface OnGetMessageListener&#123;</div><div class="line">        void getMessage(String msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void <span class="built_in">set</span>OnGetMessageListener(OnGetMessageListener listener)&#123;</div><div class="line">        mListener = listener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">onDestroyView</span></span>() &#123;</div><div class="line">        super.onDestroyView();</div><div class="line">        ButterKnife.unbind(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line">* Activity的代码</div><div class="line">*/</div><div class="line">public class ConnectActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private static final int MSG_GET_MSG = 0;</div><div class="line">    @Bind(R.id.tv_change)</div><div class="line">    TextView mTvChange;</div><div class="line">    @Bind(R.id.fl_content)</div><div class="line">    FrameLayout mFlContent;</div><div class="line"></div><div class="line">    private Handler mHandler = new <span class="function"><span class="title">Handler</span></span>()&#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            switch (msg.what)&#123;</div><div class="line">                <span class="keyword">case</span> MSG_GET_MSG:</div><div class="line">                    mTvChange.setText(msg.getData().getString(<span class="string">"data"</span>));</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_connect);</div><div class="line">        ButterKnife.bind(this);</div><div class="line"></div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">        ConnectFragment fragment = new ConnectFragment();</div><div class="line">        transaction.add(R.id.fl_content, fragment);</div><div class="line">        transaction.commit();</div><div class="line"></div><div class="line">        fragment.setOnGetMessageListener(new ConnectFragment.<span class="function"><span class="title">OnGetMessageListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void getMessage(String msg) &#123;</div><div class="line">                Message message = new Message();</div><div class="line">                Bundle data = new Bundle();</div><div class="line">                data.putString(<span class="string">"data"</span>, msg);</div><div class="line">                message.setData(data);</div><div class="line">                mHandler.sendMessage(message);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在fragment类中创建一个interface接口通过该接口来发送信息，而在Activity中通过该接口获取来自fragment的信息</p>
<p>那么Activity怎么发送数据给Fragment呢？<br>在fragment类中添加public方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void <span class="built_in">set</span>TvChange(String change)&#123;</div><div class="line">    mTvChange.setText(change);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而在Activity中通过引用来调用该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (mFragment == null)</div><div class="line">    mFragment = new ConnectFragment();</div><div class="line"></div><div class="line">mFragment.setTvChange(&quot;activity已经点击了按钮&quot;);</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/zouxiaobang/FragmentProject" target="_blank" rel="external">Fragment示例</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fragment解析]]></title>
      <url>http://yoursite.com/2016/09/19/Fragment%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>很久前就想写Fragment和ViewPager配合使用的博客了，但总是忘了，现在想起来，但觉得还是要先写写Fragment，再写与ViewPager的搭配。</p>
<h2 id="Fragment的介绍"><a href="#Fragment的介绍" class="headerlink" title="Fragment的介绍"></a>Fragment的介绍</h2><h3 id="1、Fragment的特点"><a href="#1、Fragment的特点" class="headerlink" title="1、Fragment的特点"></a>1、Fragment的特点</h3><p>在面对不同大小的手机，我们总是很苦恼，总是一显示，就乱七八糟，除非你copy了一份代码，然后又重写改了一下尺寸。<br>这就是一个特别麻烦的问题，所以Android出现了Fragment这个组件来解决这个问题。<br>Fragment与Activity的关系总是微妙的。Fragment类似于一个ViewGroup，一个Activity可以包含几个Fragment，可以对Fragment进行增删。</p>
<h3 id="2、Fragment的生命周期"><a href="#2、Fragment的生命周期" class="headerlink" title="2、Fragment的生命周期"></a>2、Fragment的生命周期</h3><p>先看两张图(来自官网)<br><img src="/img/Fragment/life1.png" alt="Fragment的生命周期">    <img src="/img/Fragment/life2.png" alt="Fragment与Activity的对比"></p>
<p>相比之下，Fragment所回调的方法更多，它的生命周期被分割得更细。除去与Actiity相同的方法，我们看看这些方法是什么作用：</p>
<ul>
<li>onAttach(Activity)：与Activity进行关联的时候回调</li>
<li>onCreateView(LayoutInflater，ViewGroup，Bundle)：开始创建视图的时候回调</li>
<li>onActivityCreate(Bundle)：与之关联的Activity调用onCreate的时候回调</li>
</ul>
<hr>
<ul>
<li>DestroyView()：当该Fragment的视图被移除时回调</li>
<li>onDetach()：与Activity的关联被取消时回调</li>
</ul>
<p>其中，我们一般重写的onCreateView()方法，而除了该方法，其他方法重写时都需要调用父类该方法，即super.on<em>*</em>()</p>
<p><a href="https://github.com/zouxiaobang/FragmentProject" target="_blank" rel="external">Fragment示例</a></p>
<h2 id="Fragment的使用"><a href="#Fragment的使用" class="headerlink" title="Fragment的使用"></a>Fragment的使用</h2><p>Fragment的使用都需要以下两步：</p>
<ul>
<li>该Fragment的layout的xml文件</li>
<li>继承自Fragment的具体类(继承的是android.app.Fragment)</li>
</ul>
<h3 id="1、静态调用Fragment"><a href="#1、静态调用Fragment" class="headerlink" title="1、静态调用Fragment"></a>1、静态调用Fragment</h3><p><img src="/img/Fragment/fragmentdisplay.png" alt="效果图"><br>其中分为两个Fragment，一个为TitleFragment，一个为ContentFragment。<br>很简单，先写出两个Fragment的布局:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;!-- fragment_title.xml --&gt;</div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">    android:orientation=<span class="string">"horizontal"</span></div><div class="line">    android:background=<span class="string">"#00796b"</span>&gt;</div><div class="line">    &lt;Button</div><div class="line">        android:id=<span class="string">"@+id/btn_left_menu"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:text=<span class="string">"==="</span>/&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:gravity=<span class="string">"center"</span></div><div class="line">        android:text=<span class="string">"Fragment的静态演示"</span></div><div class="line">        android:textColor=<span class="string">"#ffffff"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;!-- fragment_content.xml --&gt;</div><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span></div><div class="line">    android:gravity=<span class="string">"center"</span>&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=<span class="string">"@+id/tv_content"</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:text=<span class="string">"Fragment"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>ok，写完两个布局之后再来写它们的继承类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//标题的Fragment</div><div class="line">public class TitleFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_title, container, <span class="literal">false</span>);</div><div class="line">        Button btnLeftMenu = (Button) view.findViewById(R.id.btn_left_menu);</div><div class="line">        btnLeftMenu.setOnClickListener(new View.<span class="function"><span class="title">OnClickListener</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View view) &#123;</div><div class="line">                //TODO what are you want to <span class="keyword">do</span></div><div class="line">                Toast.makeText(getActivity(), <span class="string">"to do what you want to do "</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//内容的Fragment</div><div class="line">public class ContentFragment extends Fragment &#123;</div><div class="line">    private TextView mTvContent;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_content, container, <span class="literal">false</span>);</div><div class="line">        mTvContent = (TextView) view.findViewById(R.id.tv_content);</div><div class="line"></div><div class="line">        <span class="built_in">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，就算创建好了Fragment，剩下的只是引用了。我们在Activity中来使用它们，即在Activity的布局文件中调用它们<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;!-- activity_main.xml --&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span>&gt;</div><div class="line">    &lt;fragment</div><div class="line">        android:id=<span class="string">"@+id/fragment_title"</span></div><div class="line">        android:name=<span class="string">"com.example.zouxiaobang.fragmentproject.fragment.TitleFragment"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        tools:layout=<span class="string">"@layout/fragment_title"</span>/&gt;</div><div class="line">    &lt;fragment</div><div class="line">        android:id=<span class="string">"@+id/fragment_content"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span></div><div class="line">        android:name=<span class="string">"com.example.zouxiaobang.fragmentproject.fragment.ContentFragment"</span></div><div class="line">        tools:layout=<span class="string">"@layout/fragment_content"</span>/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p>
<p>其中的tools:layout=”@layout/fragment_title”可以不用，这个只是为了在编写代码的时候可以提前预览。<br>而Activity类中不需要进行任何的修改就可以使用了。</p>
<p>从上面的代码中可以看到，Activity类十分简洁，因为所有的逻辑判断都可以在Fragment中完成。如果你觉得不同的Fragment之间的控件进行通信是个问题，那么你可以interface来进行通信或使用Otto框架，这个就不在这里进行详讲了。<br>这是静态的调用方法，那么动态调用呢？</p>
<h3 id="2、动态调用Fragment"><a href="#2、动态调用Fragment" class="headerlink" title="2、动态调用Fragment"></a>2、动态调用Fragment</h3><p>很多app都有这么一个设计，在底部有一行按钮，当我们点击哪一个按钮的时候，就进入一个界面。这个就使用到了Fragment，而且是动态改变。<br>在学习动态加载时，需要先了解动态Fragment的两个类</p>
<ul>
<li>FragmentManager</li>
<li>FragmentTransaction:Fragment的处理事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FragmentManager fm = getFragmentManager();</div><div class="line">FragmentTransaction transaction = fm.beginTransaction();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对Fragment进行增删改都在Transaction中进行处理。<br>FragmentTransaction的常用方法</p>
<ul>
<li>transaction.add(int, Fragment)：将Fragment添加到Activity中</li>
<li>transaction.remove(Fragment)：将Fragment从Activity中移除</li>
<li>transaction.replace(int, Fragment)：使用Fragment替换int所代表的ViewGroup</li>
<li>transaction.hide(Fragment)：将该Fragment隐藏</li>
<li>transaction.show(Fragment)：显示该Fragment</li>
<li>transaction.commit()：提交事务</li>
</ul>
<p>其中最主要的是replace()和commit()方法。</p>
<p>现在来看上面的那个例子：<br><img src="/img/Fragment/fragmentdy.png" alt="效果图"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;!-- activity_main.xml --&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    android:id=<span class="string">"@+id/activity_dynamic"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    &lt;include</div><div class="line">        android:id=<span class="string">"@+id/buttons"</span></div><div class="line">        layout=<span class="string">"@layout/buttons"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_alignParentBottom=<span class="string">"true"</span>/&gt;</div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=<span class="string">"@+id/fl_content"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span></div><div class="line">        android:layout_above=<span class="string">"@id/buttons"</span>/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>include中包含了3个按钮，这个我就不给出来了。<br>FrameLayout是一个ViewGroup，用于存放或替代fragment。<br>接下来看看Activity中的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line"></div><div class="line">    @Bind(R.id.btn_chat)</div><div class="line">    Button mBtnChat;</div><div class="line">    @Bind(R.id.btn_friend)</div><div class="line">    Button mBtnFriend;</div><div class="line">    @Bind(R.id.btn_mine)</div><div class="line">    Button mBtnMine;</div><div class="line">    @Bind(R.id.fl_content)</div><div class="line">    FrameLayout mFlContent;</div><div class="line"></div><div class="line">    private ChatFragment mChatFragment;</div><div class="line">    private FriendFragment mFriendFragment;</div><div class="line">    private MineFragment mMineFragment;</div><div class="line">    private FragmentTransaction mTransaction;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.activity_main);</div><div class="line">        ButterKnife.bind(this);</div><div class="line"></div><div class="line">        //设置默认的页面</div><div class="line">        <span class="built_in">set</span>DefaultFragment();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">setDefaultFragment</span></span>() &#123;</div><div class="line">        mChatFragment = new ChatFragment();</div><div class="line"></div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        mTransaction = manager.beginTransaction();</div><div class="line">        mTransaction.replace(R.id.fl_content, mChatFragment);</div><div class="line"></div><div class="line">        mTransaction.commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @OnClick(&#123;R.id.btn_chat, R.id.btn_friend, R.id.btn_mine&#125;)</div><div class="line">    public void onClick(View view) &#123;</div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        mTransaction = manager.beginTransaction();</div><div class="line">        switch (view.getId()) &#123;</div><div class="line">            <span class="keyword">case</span> R.id.btn_chat:</div><div class="line">                <span class="keyword">if</span> (mChatFragment == null)</div><div class="line">                    mChatFragment = new ChatFragment();</div><div class="line">                mTransaction.replace(R.id.fl_content, mChatFragment);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.btn_friend:</div><div class="line">                <span class="keyword">if</span> (mFriendFragment == null)</div><div class="line">                    mFriendFragment = new FriendFragment();</div><div class="line">                mTransaction.replace(R.id.fl_content, mFriendFragment);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="keyword">case</span> R.id.btn_mine:</div><div class="line">                <span class="keyword">if</span> (mMineFragment == null)</div><div class="line">                    mMineFragment = new MineFragment();</div><div class="line">                mTransaction.replace(R.id.fl_content, mMineFragment);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        mTransaction.commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中有几点是需要注意的<br>1 给出一个默认的fragment<br>2 在FragmentTransaction调用commit()提交了事务之后，该事务就会消失，所以要再次使用它，则需要重新开启。</p>
<p>这是Fragment的基本用法，而Fragment远远不止如此，如果要运用好Fragment，还需要继续看下去<br><a href="https://zouxiaobang.github.io/2016/09/19/Fragment的进阶篇/" target="_blank" rel="external">Fragment的进阶</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GSON与JSON与Java对象]]></title>
      <url>http://yoursite.com/2016/09/18/GSON%E4%B8%8EJSON%E4%B8%8EJava%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="为什么使用Gson"><a href="#为什么使用Gson" class="headerlink" title="为什么使用Gson"></a>为什么使用Gson</h2><p>可能刚开始接触，会有个疑问，有了Json，为什么还会有一个Gson？Gson的存在，是不是多余的？<br>存在，即是有意义的。</p>
<p>Json可以将json转换为jsonObject，但当我们需要使用bean对象时，只能对jsonObject进行操作，这样对对象的操作是不是就不方便了呢，那么，使用Gson就很有必要了。这也是促使我去用它的一个原因。另一个原因就是Gson是google推荐的。</p>
<p><a href="http://download.csdn.net/download/u010637692/8348917" target="_blank" rel="external">gson-2.3.1.jar下载</a><br><a href="https://github.com/zouxiaobang/GsonProject" target="_blank" rel="external">Gson项目实例</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Gson gson = new Gson();</p>
<h3 id="1、简单的转换"><a href="#1、简单的转换" class="headerlink" title="1、简单的转换"></a>1、简单的转换</h3><p>将对象转换为Json:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Person person = new Person();</div><div class="line">person.setName(<span class="string">"John"</span>);</div><div class="line">person.setAge(12);</div><div class="line">person.setSex(<span class="string">"man"</span>);</div><div class="line"></div><div class="line">String json = mGson.toJson(person);</div><div class="line">System.out.println(json);</div></pre></td></tr></table></figure></p>
<p>结果：<br>I/System.out: {“sex”:”man”,”name”:”John”,”age”:12}</p>
<p>将Json转换为对象:<br>json 为 {“sex”:”man”,”name”:”John”,”age”:12}<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String json = <span class="string">"&#123;\"sex\":\"man\",\"name\":\"John\",\"age\":12&#125;"</span>;</div><div class="line">Person person = mGson.fromJson(json, Person.class);</div><div class="line"></div><div class="line">System.out.println(person.getName());</div><div class="line">System.out.println(person.getAge() + <span class="string">""</span>);</div><div class="line">System.out.println(person.getSex());</div><div class="line">System.out.println(person.doSome(<span class="string">"run"</span>));</div></pre></td></tr></table></figure></p>
<p>结果：<br>I/System.out: John<br>I/System.out: 12<br>I/System.out: man<br>I/System.out: John run</p>
<p>通过将json转换为对象的结果可以看出Gson是将json所代表的对象转换过来，而不是JsonObject那样只能读取属性值，而不能操作方法。</p>
<h3 id="2、List的泛型的转换"><a href="#2、List的泛型的转换" class="headerlink" title="2、List的泛型的转换"></a>2、List的泛型的转换</h3><p>将List泛型的对象转换为json<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Person person1 = new Person(<span class="string">"John"</span>, 12, <span class="string">"man"</span>);</div><div class="line">Person person2 = new Person(<span class="string">"May"</span>, 21, <span class="string">"woman"</span>);</div><div class="line">Person person3 = new Person(<span class="string">"David"</span>, 20, <span class="string">"man"</span>);</div><div class="line">List&lt;Person&gt; persons = new ArrayList&lt;&gt;();</div><div class="line">persons.add(person1);</div><div class="line">persons.add(person2);</div><div class="line">persons.add(person3);</div><div class="line"></div><div class="line">String json = mGson.toJson(persons);</div><div class="line">System.out.println(json);</div></pre></td></tr></table></figure></p>
<p>该操作和上面的简单操作是一样的。<br>结果：<br>[{“sex”:”man”,”name”:”John”,”age”:12},{“sex”:”woman”,”name”:”May”,”age”:21},{“sex”:”man”,”name”:”David”,”age”:20}]</p>
<p>将上面的结果作为json传入转换为List泛型的对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String json = <span class="string">"[&#123;\"sex\":\"man\",\"name\":\"John\",\"age\":12&#125;,"</span> +</div><div class="line">                <span class="string">"&#123;\"sex\":\"woman\",\"name\":\"May\",\"age\":21&#125;,"</span> +</div><div class="line">                <span class="string">"&#123;\"sex\":\"man\",\"name\":\"David\",\"age\":20&#125;]"</span>;</div><div class="line"></div><div class="line">List&lt;Person&gt; persons = mGson.fromJson(json, new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType());</div><div class="line"><span class="keyword">for</span> (Person person: persons)&#123;</div><div class="line">    System.out.println(person);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里要将List泛型的类型作为第二个参数传进去，而List泛型获取参数的方法就是：new TypeToken<list<person>&gt;(){}.getType();<br>结果：<br>John : 12 : sex<br>May : 21 : sex<br>David : 20 : sex</list<person></p>
<h3 id="3、Map的转换"><a href="#3、Map的转换" class="headerlink" title="3、Map的转换"></a>3、Map的转换</h3><p>将Map转换为Json：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Person&gt; map = new HashMap&lt;&gt;();</div><div class="line">map.put(<span class="string">"a"</span>, new Person(<span class="string">"John"</span>, 12, <span class="string">"man"</span>));</div><div class="line">map.put(<span class="string">"b"</span>, new Person(<span class="string">"May"</span>, 21, <span class="string">"woman"</span>));</div><div class="line">String json = mGson.toJson(map);</div><div class="line"></div><div class="line">System.out.println(json);</div></pre></td></tr></table></figure></p>
<p>结果：<br>I/System.out: {“b”:{“sex”:”woman”,”name”:”May”,”age”:21},”a”:{“sex”:”man”,”name”:”John”,”age”:12}}</p>
<p>以上面的json转换为Map：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String json = <span class="string">"&#123;\"b\":&#123;\"sex\":\"woman\",\"name\":\"May\",\"age\":21&#125;,"</span> +</div><div class="line">                <span class="string">"\"a\":&#123;\"sex\":\"man\",\"name\":\"John\",\"age\":12&#125;&#125;"</span>;</div><div class="line">Map&lt;String, Person&gt; map = mGson.fromJson(json, new TypeToken&lt;Map&lt;String, Person&gt;&gt;()&#123;&#125;.getType());</div><div class="line"></div><div class="line"><span class="keyword">for</span> (String key: map.keySet())&#123;</div><div class="line">     System.out.println(<span class="string">"key = "</span> + key + <span class="string">", value = "</span> + ((Person)map.get(key)).doSome(<span class="string">" run"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>I/System.out: key = b, value = May  run<br>I/System.out: key = a, value = John  run</p>
<p>如果Map的第二个泛型是一个List泛型呢？那也一样，在转换成Map时强转map.get(key)为List泛型即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[圆形进度条CircleProgress(下)]]></title>
      <url>http://yoursite.com/2016/09/05/%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1CircleProgress-%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h2 id="设置动画"><a href="#设置动画" class="headerlink" title="设置动画"></a>设置动画</h2><h3 id="同样，不说话，先上图"><a href="#同样，不说话，先上图" class="headerlink" title="同样，不说话，先上图"></a>同样，不说话，先上图</h3><p><img src="/img/circleProgress2/CircleProgress.png" alt="拥有波浪形的进度"></p>
<h3 id="波浪形的来历"><a href="#波浪形的来历" class="headerlink" title="波浪形的来历"></a>波浪形的来历</h3><p>这是著名的贝塞尔曲线<br>    贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。<br><a href="http://baike.baidu.com/link?url=LjgifDUq4km2QVT6SySubWYTAQzxCR46hv5cssKt-F3s3iKL0zj-HJurd-IB-1Xh_9dCcnqD9a4MHobmhiwUGNhgBqh9_4oZhRATuftZofZhNpnuaee2aZJkoNgPp0fBlIBmfBB57wqLNCzlubscpa" target="_blank" rel="external">赛贝尔曲线</a><br>好了，这个就不多说了，都是高数。只要记得Android是有配套的API可以调用的</p>
<h3 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h3><p>maxProgress:最大进度<br>currentProgress：现在进度</p>
<h3 id="开始绘制"><a href="#开始绘制" class="headerlink" title="开始绘制"></a>开始绘制</h3><h4 id="1、初始化画笔"><a href="#1、初始化画笔" class="headerlink" title="1、初始化画笔"></a>1、初始化画笔</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mProgressPaint = new Paint();</div><div class="line">mProgressPaint.setAntiAlias(<span class="literal">true</span>);</div><div class="line">mProgressPaint.setColor(mProgressColor);</div><div class="line">//取两层绘制的交集,取上层</div><div class="line">mProgressPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</div></pre></td></tr></table></figure>
<h4 id="2、在缓冲区画布上画"><a href="#2、在缓冲区画布上画" class="headerlink" title="2、在缓冲区画布上画"></a>2、在缓冲区画布上画</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mBitmap = Bitmap.createBitmap((int) mBallRadius*2, (int)mBallRadius*2, Bitmap.Config.ARGB_8888);</div><div class="line">mCanvas = new Canvas(mBitmap);</div></pre></td></tr></table></figure>
<p>要根据图层顺序地画图形<br>1 背景圆<br>2 波浪形<br>3 文本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">int width = getMeasuredWidth();</div><div class="line">      int height = getMeasuredHeight();</div><div class="line"></div><div class="line">      //绘制圆</div><div class="line">      mCanvas.drawCircle(width/2, height/2, mBallRadius, mRoundPaint);</div><div class="line">      //开始绘制波形</div><div class="line">      mPath.reset();</div><div class="line">      //波形的个数</div><div class="line">      int count = (int)(mBallRadius + 1)*2 / space;</div><div class="line">      //波浪高度</div><div class="line">      <span class="built_in">float</span> y1 = (1 - (<span class="built_in">float</span>)currentProgress/maxProgress)*mBallRadius*2 + height/2 - mBallRadius;</div><div class="line">      mPath.moveTo(-width+y1, y1);</div><div class="line">      <span class="built_in">float</span> d = (1-(<span class="built_in">float</span>)currentProgress/maxProgress) * space;</div><div class="line">      <span class="keyword">for</span> (int i = 0;i &lt; count;i ++)&#123;</div><div class="line">      	//贝赛尔曲线</div><div class="line">          mPath.rQuadTo(space, <span class="_">-d</span>, space*2, 0);</div><div class="line">          mPath.rQuadTo(space, d, space*2, 0);</div><div class="line">      &#125;</div><div class="line">      mPath.lineTo(width, y1);</div><div class="line">      mPath.lineTo(width, height);</div><div class="line">      mPath.lineTo(0, height);</div><div class="line">      //实心</div><div class="line">      mPath.close();</div><div class="line">      mCanvas.drawPath(mPath, mProgressPaint);</div><div class="line"></div><div class="line">      //写字</div><div class="line">      mCenterText = currentProgress + <span class="string">" %"</span>;</div><div class="line">      <span class="built_in">float</span> textWidth = mFontPaint.measureText(mCenterText);</div><div class="line">      Paint.FontMetrics fontMetrics = new Paint.FontMetrics();</div><div class="line">      <span class="built_in">float</span> dy = -(fontMetrics.descent + fontMetrics.ascent)/2;</div><div class="line">      <span class="built_in">float</span> x = width/2 - textWidth/2;</div><div class="line">      <span class="built_in">float</span> y = height/2 + dy;</div><div class="line">      mCanvas.drawText(mCenterText, x, y, mFontPaint);</div><div class="line"></div><div class="line">      canvas.drawBitmap(mBitmap, 0, 0, null);</div></pre></td></tr></table></figure></p>
<p>不知道space是什么？来，直接上图<br><img src="/img/circleProgress2/640.png" alt=""><br>space：每个波形的宽度的一半<br>y1为图中的y：波浪到达的高度<br>path：一个矩形<br>d：波浪的高度</p>
<h4 id="3、提供向外接口，设置进度"><a href="#3、提供向外接口，设置进度" class="headerlink" title="3、提供向外接口，设置进度"></a>3、提供向外接口，设置进度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void <span class="built_in">set</span>Progress(int progress)&#123;</div><div class="line">    currentProgress = progress;</div><div class="line">    invalidate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="至此整个绘图结束，只剩调用"><a href="#至此整个绘图结束，只剩调用" class="headerlink" title="至此整个绘图结束，只剩调用"></a>至此整个绘图结束，只剩调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;com.example.zouxiaobang.circleprogress.userdefinedview.CircleProgress</div><div class="line">       android:id=<span class="string">"@+id/cp_test"</span></div><div class="line">       android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">       android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">       app:centerText=<span class="string">"进度"</span></div><div class="line">       app:ballRadius=<span class="string">"100dp"</span></div><div class="line">       app:ballColor=<span class="string">"#00bcd4"</span></div><div class="line">       app:centerTextColor=<span class="string">"#000000"</span></div><div class="line">       app:centerTextSize=<span class="string">"16sp"</span></div><div class="line">       app:progressColor=<span class="string">"#00796b"</span>/&gt;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[圆形进度条CircleProgress(上)]]></title>
      <url>http://yoursite.com/2016/09/04/%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1CircleProgress-%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h2 id="github项目"><a href="#github项目" class="headerlink" title="github项目"></a>github项目</h2><p><a href="https://github.com/zouxiaobang/CircleProgress" target="_blank" rel="external">波浪形圆形进度条</a></p>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h3 id="先上图"><a href="#先上图" class="headerlink" title="先上图"></a>先上图</h3><p><img src="/img/circleProgress1/circleProgress1.png" alt="圆形与文字"></p>
<h3 id="现在开始使用代码来画图"><a href="#现在开始使用代码来画图" class="headerlink" title="现在开始使用代码来画图"></a>现在开始使用代码来画图</h3><h4 id="1、自定义属性"><a href="#1、自定义属性" class="headerlink" title="1、自定义属性"></a>1、自定义属性</h4><p>在value文件夹中新建一个attrs.xml配置文件<br>（注意value文件夹不是什么value21什么的，曾被坑得找不着北）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name="CircleProgress"&gt;</div><div class="line">        &lt;attr name="ballRadius" format="dimension"/&gt;</div><div class="line">        &lt;attr name="ballColor" format="color"/&gt;</div><div class="line">        &lt;attr name="centerText" format="string"/&gt;</div><div class="line">        &lt;attr name="centerTextColor" format="color"/&gt;</div><div class="line">        &lt;attr name="centerTextSize" format="dimension"/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure></p>
<p>此处介绍一下：<br>圆形</p>
<ul>
<li>半径：ballRadius</li>
<li>颜色：ballColor</li>
</ul>
<p>文字</p>
<ul>
<li>文本：centerText</li>
<li>颜色：centerTextColor</li>
<li>大小：centerTextSize</li>
</ul>
<h4 id="2、继承View"><a href="#2、继承View" class="headerlink" title="2、继承View"></a>2、继承View</h4><p>继承并重新它的前三个构造方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public CircleProgress(Context context) &#123;</div><div class="line">       this(context, null);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public CircleProgress(Context context, AttributeSet attrs) &#123;</div><div class="line">       this(context, attrs, 0);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public CircleProgress(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">       super(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">       TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleProgress);</div><div class="line">       mBallRadius = typedArray.getDimension(R.styleable.CircleProgress_ballRadius, 260f);</div><div class="line">       mBallColor = typedArray.getColor(R.styleable.CircleProgress_ballColor, Color.argb(255, 33, 150, 243));</div><div class="line">       mCenterText = typedArray.getString(R.styleable.CircleProgress_centerText);</div><div class="line">       mCenterTextSize = typedArray.getDimension(R.styleable.CircleProgress_centerTextSize, 20f);</div><div class="line">       mCenterTextColor = typedArray.getColor(R.styleable.CircleProgress_centerTextColor, Color.argb(255, 48, 63, 159));</div><div class="line">       typedArray.recycle();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过TypedArray对象获取xml文件中的设置参数<br>记得最后要recycle()回收</p>
<h4 id="3、初始化画笔"><a href="#3、初始化画笔" class="headerlink" title="3、初始化画笔"></a>3、初始化画笔</h4><p>这里需要画两种东西，即圆形和文本，所以需要使用到两种画笔<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mRoundPaint = new Paint();</div><div class="line">mRoundPaint.setColor(mBallColor);</div><div class="line">mRoundPaint.setAntiAlias(<span class="literal">true</span>);</div><div class="line"></div><div class="line">mFontPaint = new Paint();</div><div class="line">mFontPaint.setColor(mCenterTextColor);</div><div class="line">mFontPaint.setAntiAlias(<span class="literal">true</span>);</div><div class="line">mFontPaint.setTextSize(mCenterTextSize);</div><div class="line">mFontPaint.setFakeBoldText(<span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<h4 id="4、对view的测量"><a href="#4、对view的测量" class="headerlink" title="4、对view的测量"></a>4、对view的测量</h4><p>必须测量，不然默认的话就只有match_parent这个尺寸了，不管怎么设置都是这个尺寸<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       <span class="built_in">set</span>MeasuredDimension(measure(widthMeasureSpec), measure(heightMeasureSpec));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 对宽高进行测量</div><div class="line">    * @param measureSpec</div><div class="line">    * @<span class="built_in">return</span></div><div class="line">    */</div><div class="line">   private int measure(int measureSpec) &#123;</div><div class="line">       int result = 0;</div><div class="line">       int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">       int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY)&#123;</div><div class="line">           result = specSize;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result = (int) mBallRadius * 2;</div><div class="line">           <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST)&#123;</div><div class="line">               result = result&lt;specSize?result:specSize;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="built_in">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这时，当我们使用wrap_content的时候宽高是这个圆形的直径<br>（注意：result = (int) mBallRadius * 2; 乘以2才是直径）</p>
<h4 id="5、开始画画"><a href="#5、开始画画" class="headerlink" title="5、开始画画"></a>5、开始画画</h4><p>画个圆之前需要先获得大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int width = getMeasuredWidth();</div><div class="line">int height = getMeasuredHeight();</div></pre></td></tr></table></figure></p>
<p>先画个圆<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas.drawCircle(width/2, height/2, mBallRadius, mRoundPaint);</div></pre></td></tr></table></figure></p>
<h4 id="6、写字"><a href="#6、写字" class="headerlink" title="6、写字"></a>6、写字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">float</span> textWidth = mFontPaint.measureText(mCenterText);</div><div class="line">Paint.FontMetrics fontMetrics = new Paint.FontMetrics();</div><div class="line"><span class="built_in">float</span> dy = -(fontMetrics.descent + fontMetrics.ascent)/2;</div><div class="line"><span class="built_in">float</span> x = width/2 - textWidth/2;</div><div class="line"><span class="built_in">float</span> y = height/2 + dy;</div><div class="line">canvas.drawText(mCenterText, x, y, mFontPaint);</div></pre></td></tr></table></figure>
<p>其中，使用到FontMetrics对象，通过该对象可以测量字体粗体时的大小</p>
<h3 id="画图结束"><a href="#画图结束" class="headerlink" title="画图结束"></a>画图结束</h3><p>先在layout的xml文件中使用看看有没有该效果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;com.example.zouxiaobang.circleprogress.userdefinedview.CircleProgress</div><div class="line">       android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">       android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">       app:centerText=<span class="string">"进度"</span></div><div class="line">       app:ballRadius=<span class="string">"100dp"</span></div><div class="line">       app:ballColor=<span class="string">"#00bcd4"</span></div><div class="line">       app:centerTextColor=<span class="string">"#000000"</span></div><div class="line">       app:centerTextSize=<span class="string">"16sp"</span>/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo命令及markdown语法]]></title>
      <url>http://yoursite.com/2016/08/26/hexo%E5%91%BD%E4%BB%A4%E5%8F%8Amarkdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><h3 id="1、新建"><a href="#1、新建" class="headerlink" title="1、新建"></a>1、新建</h3><pre><code>hexo new &quot;my blog article&quot;
</code></pre><h3 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h3><pre><code>hexo generate
</code></pre><p>或<br>    hexo g<br>将md文件编译成html文件，存在public文件夹中</p>
<h3 id="3、开启本地服务"><a href="#3、开启本地服务" class="headerlink" title="3、开启本地服务"></a>3、开启本地服务</h3><pre><code>hexo server
</code></pre><p>或<br>    hexo s<br>开启后可通过该网址预览(<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>)</p>
<h3 id="4、部署到github中"><a href="#4、部署到github中" class="headerlink" title="4、部署到github中"></a>4、部署到github中</h3><pre><code>hexo deploy
</code></pre><p>或<br>    hexo d</p>
<h3 id="5、清除public"><a href="#5、清除public" class="headerlink" title="5、清除public"></a>5、清除public</h3><pre><code>hexo clean
</code></pre><p>当source文件夹中的资源有改动时就需要用到它</p>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="1、先来一份语法"><a href="#1、先来一份语法" class="headerlink" title="1、先来一份语法"></a>1、先来一份语法</h3><p>分段<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg 两个回车</div></pre></td></tr></table></figure></p>
<p>换行<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg 回车</div></pre></td></tr></table></figure></p>
<p>标题<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg # ~ ###### 表示几级标题，总共有六级</div></pre></td></tr></table></figure></p>
<p>引用<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg &gt;</div></pre></td></tr></table></figure></p>
<p>列表<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg * + - 1.  注意使用时后面有空格</div></pre></td></tr></table></figure></p>
<p>代码区块<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg 开头4个空格， 或转换键</div></pre></td></tr></table></figure></p>
<p>链接<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg [文字]  (链接地址)   中间没有空格</div></pre></td></tr></table></figure></p>
<p>图片<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg ![图片说明]  （图片地址） 中间没有空格，图片可以是本地的，也可以是网络地址</div></pre></td></tr></table></figure></p>
<p>强调<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg 两个星号中间文字，或两个下划线中间文字，或四个星号中间文字，或四个下划线中间文字</div></pre></td></tr></table></figure></p>
<p>代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg 三个``` 开头，再三个结尾。</div></pre></td></tr></table></figure></p>
<h3 id="2、好了，开一篇范文吧"><a href="#2、好了，开一篇范文吧" class="headerlink" title="2、好了，开一篇范文吧"></a>2、好了，开一篇范文吧</h3><p><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">范文</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac下安装Hexo]]></title>
      <url>http://yoursite.com/2016/08/24/Mac%E4%B8%8B%E5%AE%89%E8%A3%85Hexo/</url>
      <content type="html"><![CDATA[<p>这是我的第一篇文章，现在已经是深夜1点多，我还在笔耕不辍。因为构建这个hexo博客，可是弄了我一整夜的时间。</p>
<p>虽然这个博客的style比较丑，但也没办法，以后再改。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1、下载git"><a href="#1、下载git" class="headerlink" title="1、下载git"></a>1、下载git</h3><p>使用下面的指令可查看git是否下载成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git --version</div></pre></td></tr></table></figure>
<h3 id="2、下载Node-js"><a href="#2、下载Node-js" class="headerlink" title="2、下载Node.js"></a>2、下载Node.js</h3><p>使用下面指令可查看node是否下载成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">$ npm -v</div></pre></td></tr></table></figure>
<h3 id="3、（重点）下载Hexo"><a href="#3、（重点）下载Hexo" class="headerlink" title="3、（重点）下载Hexo"></a>3、（重点）下载Hexo</h3><p>记得sudo，不然就各种错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h3 id="4、初始化站点"><a href="#4、初始化站点" class="headerlink" title="4、初始化站点"></a>4、初始化站点</h3><p>要先自己创建一个文件夹，例如hexo，然后进入该文件夹，再执行代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ init hexo</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<h3 id="5、ok，可以进行本地测试了"><a href="#5、ok，可以进行本地测试了" class="headerlink" title="5、ok，可以进行本地测试了"></a>5、ok，可以进行本地测试了</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>我的博客(<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>)</p>
<h3 id="6、部署到GitHub中"><a href="#6、部署到GitHub中" class="headerlink" title="6、部署到GitHub中"></a>6、部署到GitHub中</h3><p>先在GitHub中创建一个repository，名称为用户名.github.io<br>修改hexo根目录下的_config.yml文件，先修改其中最后面的部分：  </p>
<pre><code class="bash">deploy:
    <span class="built_in">type</span>: git
    repository: git@github.com:yourname/yourname.github.io
    branch: master
</code></pre>
<p>（记得在：后面要有一个空格）</p>
<h3 id="7、将文章转换为静态文本"><a href="#7、将文章转换为静态文本" class="headerlink" title="7、将文章转换为静态文本"></a>7、将文章转换为静态文本</h3><pre><code class="bash">$ hexo g
</code></pre>
<p>该网页生成到public文件夹中</p>
<h3 id="8、提交到github中"><a href="#8、提交到github中" class="headerlink" title="8、提交到github中"></a>8、提交到github中</h3><pre><code class="bash">$ npm install hexo-deployer-git --save
$ hexo d
</code></pre>
<p>到此结束</p>
<h3 id="打开博客"><a href="#打开博客" class="headerlink" title="打开博客"></a>打开博客</h3><p>(<a href="https://zouxiaobang.github.io" target="_blank" rel="external">https://zouxiaobang.github.io</a>)</p>
]]></content>
    </entry>
    
  
  
</search>
